{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/constants/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/constants/bt709.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/rgb2xyz.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/arithmetic.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/rgb2hsl.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/xyz2lab.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/rgb2lab.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/lab2xyz.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/xyz2rgb.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/lab2rgb.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/distanceCalculator.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/cie94.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/ciede2000.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/cmetric.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/euclidean.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/manhattan.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/pngQuant.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/paletteQuantizer.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/point.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/pointContainer.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/palette.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/hueStatistics.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/progressTracker.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/neuquant/neuquant.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/neuquant/neuquantFloat.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/rgbquant/colorHistogram.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/rgbquant/rgbquant.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/wu/wuQuant.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/imageQuantizer.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/nearestColor.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/array.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/spaceFillingCurves/hilbertCurve.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/riemersma.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/quality/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/quality/ssim.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/basicAPI.ts"],"sourcesContent":["/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nimport * as constants from './constants';\nimport * as conversion from './conversion';\nimport * as distance from './distance';\nimport * as palette from './palette';\nimport * as image from './image';\nimport * as quality from './quality';\nimport * as utils from './utils';\n\nexport {\n  buildPalette,\n  buildPaletteSync,\n  applyPalette,\n  applyPaletteSync,\n} from './basicAPI';\n\nexport type {\n  ImageQuantization,\n  PaletteQuantization,\n  ColorDistanceFormula,\n} from './basicAPI';\n\nexport { constants, conversion, distance, palette, image, quality, utils };\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\nimport * as bt709 from './bt709';\n\nexport { bt709 };\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\n\n/**\n * sRGB (based on ITU-R Recommendation BT.709)\n * http://en.wikipedia.org/wiki/SRGB\n */\nexport enum Y {\n  RED = 0.2126,\n  GREEN = 0.7152,\n  BLUE = 0.0722,\n  WHITE = 1,\n}\n\nexport enum x {\n  RED = 0.64,\n  GREEN = 0.3,\n  BLUE = 0.15,\n  WHITE = 0.3127,\n}\n\nexport enum y {\n  RED = 0.33,\n  GREEN = 0.6,\n  BLUE = 0.06,\n  WHITE = 0.329,\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { rgb2xyz } from './rgb2xyz';\nexport { rgb2hsl } from './rgb2hsl';\nexport { rgb2lab } from './rgb2lab';\nexport { lab2xyz } from './lab2xyz';\nexport { lab2rgb } from './lab2rgb';\nexport { xyz2lab } from './xyz2lab';\nexport { xyz2rgb } from './xyz2rgb';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2xyz.ts - part of Image Quantization Library\n */\nfunction correctGamma(n: number) {\n  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;\n}\n\nexport function rgb2xyz(r: number, g: number, b: number) {\n  // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\n  r = correctGamma(r / 255);\n  g = correctGamma(g / 255);\n  b = correctGamma(b / 255);\n\n  // Observer. = 2°, Illuminant = D65\n  return {\n    x: r * 0.4124 + g * 0.3576 + b * 0.1805,\n    y: r * 0.2126 + g * 0.7152 + b * 0.0722,\n    z: r * 0.0193 + g * 0.1192 + b * 0.9505,\n  };\n}\n","export function degrees2radians(n: number) {\n  return n * (Math.PI / 180);\n}\n\nexport function max3(a: number, b: number, c: number) {\n  let m = a;\n  if (m < b) m = b;\n  if (m < c) m = c;\n  return m;\n}\n\nexport function min3(a: number, b: number, c: number) {\n  let m = a;\n  if (m > b) m = b;\n  if (m > c) m = c;\n  return m;\n}\n\nexport function intInRange(value: number, low: number, high: number) {\n  if (value > high) value = high;\n  if (value < low) value = low;\n  return value | 0;\n}\n\nexport function inRange0to255Rounded(n: number) {\n  n = Math.round(n);\n  if (n > 255) n = 255;\n  else if (n < 0) n = 0;\n  return n;\n}\n\nexport function inRange0to255(n: number) {\n  if (n > 255) n = 255;\n  else if (n < 0) n = 0;\n  return n;\n}\n\nexport function stableSort<T>(\n  arrayToSort: T[],\n  callback: (a: T, b: T) => number,\n) {\n  const type = typeof arrayToSort[0];\n  let sorted: T[];\n\n  if (type === 'number' || type === 'string') {\n    const ord = Object.create(null);\n    for (let i = 0, l = arrayToSort.length; i < l; i++) {\n      const val = arrayToSort[i] as unknown as string;\n      if (ord[val] || ord[val] === 0) continue;\n      ord[val] = i;\n    }\n\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);\n  } else {\n    const ord2 = arrayToSort.slice(0);\n    sorted = arrayToSort.sort(\n      (a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b),\n    );\n  }\n\n  return sorted;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2hsl.ts - part of Image Quantization Library\n */\nimport { min3, max3 } from '../utils/arithmetic';\n\n/**\n * Calculate HSL from RGB\n * Hue is in degrees [0..360]\n * Lightness: [0..1]\n * Saturation: [0..1]\n * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/\n */\nexport function rgb2hsl(r: number, g: number, b: number) {\n  const min = min3(r, g, b);\n  const max = max3(r, g, b);\n  const delta = max - min;\n  const l = (min + max) / 510;\n\n  let s = 0;\n  if (l > 0 && l < 1) s = delta / (l < 0.5 ? max + min : 510 - max - min);\n\n  let h = 0;\n  if (delta > 0) {\n    if (max === r) {\n      h = (g - b) / delta;\n    } else if (max === g) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n\n    h *= 60;\n    if (h < 0) h += 360;\n  }\n  return { h, s, l };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2lab.ts - part of Image Quantization Library\n */\nconst refX = 0.95047; // ref_X =  95.047   Observer= 2°, Illuminant= D65\nconst refY = 1.0; // ref_Y = 100.000\nconst refZ = 1.08883; // ref_Z = 108.883\n\nfunction pivot(n: number) {\n  return n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116;\n}\n\nexport function xyz2lab(x: number, y: number, z: number) {\n  x = pivot(x / refX);\n  y = pivot(y / refY);\n  z = pivot(z / refZ);\n\n  if (116 * y - 16 < 0) throw new Error('xxx');\n  return {\n    L: Math.max(0, 116 * y - 16),\n    a: 500 * (x - y),\n    b: 200 * (y - z),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2lab.ts - part of Image Quantization Library\n */\nimport { rgb2xyz } from './rgb2xyz';\nimport { xyz2lab } from './xyz2lab';\n\nexport function rgb2lab(r: number, g: number, b: number) {\n  const xyz = rgb2xyz(r, g, b);\n  return xyz2lab(xyz.x, xyz.y, xyz.z);\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2xyz.ts - part of Image Quantization Library\n */\nconst refX = 0.95047; // ref_X =  95.047   Observer= 2°, Illuminant = D65\nconst refY = 1.0; // ref_Y = 100.000\nconst refZ = 1.08883; // ref_Z = 108.883\n\nfunction pivot(n: number) {\n  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;\n}\n\nexport function lab2xyz(L: number, a: number, b: number) {\n  const y = (L + 16) / 116;\n  const x = a / 500 + y;\n  const z = y - b / 200;\n\n  return {\n    x: refX * pivot(x),\n    y: refY * pivot(y),\n    z: refZ * pivot(z),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2rgb.ts - part of Image Quantization Library\n */\nimport { inRange0to255Rounded } from '../utils/arithmetic';\n\n// gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\nfunction correctGamma(n: number) {\n  return n > 0.0031308 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;\n}\n\nexport function xyz2rgb(x: number, y: number, z: number) {\n  // Observer. = 2°, Illuminant = D65\n  const r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986);\n  const g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415);\n  const b = correctGamma(x * 0.0557 + y * -0.204 + z * 1.057);\n\n  return {\n    r: inRange0to255Rounded(r * 255),\n    g: inRange0to255Rounded(g * 255),\n    b: inRange0to255Rounded(b * 255),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2rgb.ts - part of Image Quantization Library\n */\nimport { lab2xyz } from './lab2xyz';\nimport { xyz2rgb } from './xyz2rgb';\n\nexport function lab2rgb(L: number, a: number, b: number) {\n  const xyz = lab2xyz(L, a, b);\n  return xyz2rgb(xyz.x, xyz.y, xyz.z);\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { AbstractDistanceCalculator } from './distanceCalculator';\nexport { CIE94Textiles, CIE94GraphicArts } from './cie94';\nexport { CIEDE2000 } from './ciede2000';\nexport { CMetric } from './cmetric';\nexport {\n  AbstractEuclidean,\n  Euclidean,\n  EuclideanBT709NoAlpha,\n  EuclideanBT709,\n} from './euclidean';\nexport {\n  AbstractManhattan,\n  Manhattan,\n  ManhattanBT709,\n  ManhattanNommyde,\n} from './manhattan';\nexport { PNGQuant } from './pngQuant';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointRGBA } from '../utils/point';\n\nexport abstract class AbstractDistanceCalculator {\n  protected _maxDistance!: number;\n  protected _whitePoint!: {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n  };\n\n  constructor() {\n    this._setDefaults();\n\n    // set default maximal color component deltas (255 - 0 = 255)\n    this.setWhitePoint(255, 255, 255, 255);\n  }\n\n  setWhitePoint(r: number, g: number, b: number, a: number) {\n    this._whitePoint = {\n      r: r > 0 ? 255 / r : 0,\n      g: g > 0 ? 255 / g : 0,\n      b: b > 0 ? 255 / b : 0,\n      a: a > 0 ? 255 / a : 0,\n    };\n    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\n  }\n\n  calculateNormalized(colorA: PointRGBA, colorB: PointRGBA) {\n    return (\n      this.calculateRaw(\n        colorA.r,\n        colorA.g,\n        colorA.b,\n        colorA.a,\n        colorB.r,\n        colorB.g,\n        colorB.b,\n        colorB.a,\n      ) / this._maxDistance\n    );\n  }\n\n  /**\n   * Calculate raw distance (non-normalized)\n   */\n  abstract calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ): number;\n\n  protected abstract _setDefaults(): void;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cie94.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { rgb2lab } from '../conversion/rgb2lab';\nimport { inRange0to255 } from '../utils/arithmetic';\n\n/**\n * CIE94 method of delta-e\n * http://en.wikipedia.org/wiki/Color_difference#CIE94\n */\nexport abstract class AbstractCIE94 extends AbstractDistanceCalculator {\n  /**\n   * Weight in distance: 0.25\n   * Max DeltaE: 100\n   * Max DeltaA: 255\n   */\n  declare protected _kA: number;\n  declare protected _Kl: number;\n  declare protected _K1: number;\n  declare protected _K2: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const lab1 = rgb2lab(\n      inRange0to255(r1 * this._whitePoint.r),\n      inRange0to255(g1 * this._whitePoint.g),\n      inRange0to255(b1 * this._whitePoint.b),\n    );\n    const lab2 = rgb2lab(\n      inRange0to255(r2 * this._whitePoint.r),\n      inRange0to255(g2 * this._whitePoint.g),\n      inRange0to255(b2 * this._whitePoint.b),\n    );\n\n    const dL = lab1.L - lab2.L;\n    const dA = lab1.a - lab2.a;\n    const dB = lab1.b - lab2.b;\n    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);\n    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);\n    const dC = c1 - c2;\n\n    let deltaH = dA * dA + dB * dB - dC * dC;\n    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n\n    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\n\n    // TODO: add alpha channel support\n    return Math.sqrt(\n      (dL / this._Kl) ** 2 +\n        (dC / (1.0 + this._K1 * c1)) ** 2 +\n        (deltaH / (1.0 + this._K2 * c1)) ** 2 +\n        dAlpha ** 2,\n    );\n  }\n}\n\nexport class CIE94Textiles extends AbstractCIE94 {\n  protected _setDefaults() {\n    this._Kl = 2.0;\n    this._K1 = 0.048;\n    this._K2 = 0.014;\n    this._kA = (0.25 * 50) / 255;\n  }\n}\n\nexport class CIE94GraphicArts extends AbstractCIE94 {\n  protected _setDefaults() {\n    this._Kl = 1.0;\n    this._K1 = 0.045;\n    this._K2 = 0.015;\n    this._kA = (0.25 * 100) / 255;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ciede2000.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { rgb2lab } from '../conversion/rgb2lab';\nimport { degrees2radians, inRange0to255 } from '../utils/arithmetic';\n\n/**\n * CIEDE2000 algorithm - Adapted from Sharma et al's MATLAB implementation at\n * http://www.ece.rochester.edu/~gsharma/ciede2000/\n */\nexport class CIEDE2000 extends AbstractDistanceCalculator {\n  /**\n   * Weight in distance: 0.25\n   * Max DeltaE: 100\n   * Max DeltaA: 255\n   */\n  private static readonly _kA = (0.25 * 100) / 255;\n  private static readonly _pow25to7 = 25 ** 7;\n  private static readonly _deg360InRad = degrees2radians(360);\n  private static readonly _deg180InRad = degrees2radians(180);\n  private static readonly _deg30InRad = degrees2radians(30);\n  private static readonly _deg6InRad = degrees2radians(6);\n  private static readonly _deg63InRad = degrees2radians(63);\n  private static readonly _deg275InRad = degrees2radians(275);\n  private static readonly _deg25InRad = degrees2radians(25);\n\n  protected _setDefaults() {}\n\n  private static _calculatehp(b: number, ap: number) {\n    const hp = Math.atan2(b, ap);\n    if (hp >= 0) return hp;\n    return hp + CIEDE2000._deg360InRad;\n  }\n\n  private static _calculateRT(ahp: number, aCp: number) {\n    const aCp_to_7 = aCp ** 7.0;\n    const R_C = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)); // 25^7\n    const delta_theta =\n      CIEDE2000._deg30InRad *\n      Math.exp(\n        -(((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad) ** 2.0),\n      );\n    return -Math.sin(2.0 * delta_theta) * R_C;\n  }\n\n  private static _calculateT(ahp: number) {\n    return (\n      1.0 -\n      0.17 * Math.cos(ahp - CIEDE2000._deg30InRad) +\n      0.24 * Math.cos(ahp * 2.0) +\n      0.32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) -\n      0.2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad)\n    );\n  }\n\n  private static _calculate_ahp(\n    C1pC2p: number,\n    h_bar: number,\n    h1p: number,\n    h2p: number,\n  ) {\n    const hpSum = h1p + h2p;\n    if (C1pC2p === 0) return hpSum;\n    if (h_bar <= CIEDE2000._deg180InRad) return hpSum / 2.0;\n    if (hpSum < CIEDE2000._deg360InRad) {\n      return (hpSum + CIEDE2000._deg360InRad) / 2.0;\n    }\n    return (hpSum - CIEDE2000._deg360InRad) / 2.0;\n  }\n\n  private static _calculate_dHp(\n    C1pC2p: number,\n    h_bar: number,\n    h2p: number,\n    h1p: number,\n  ) {\n    let dhp;\n    if (C1pC2p === 0) {\n      dhp = 0;\n    } else if (h_bar <= CIEDE2000._deg180InRad) {\n      dhp = h2p - h1p;\n    } else if (h2p <= h1p) {\n      dhp = h2p - h1p + CIEDE2000._deg360InRad;\n    } else {\n      dhp = h2p - h1p - CIEDE2000._deg360InRad;\n    }\n    return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);\n  }\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const lab1 = rgb2lab(\n      inRange0to255(r1 * this._whitePoint.r),\n      inRange0to255(g1 * this._whitePoint.g),\n      inRange0to255(b1 * this._whitePoint.b),\n    );\n    const lab2 = rgb2lab(\n      inRange0to255(r2 * this._whitePoint.r),\n      inRange0to255(g2 * this._whitePoint.g),\n      inRange0to255(b2 * this._whitePoint.b),\n    );\n    const dA = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA;\n    const dE2 = this.calculateRawInLab(lab1, lab2);\n\n    return Math.sqrt(dE2 + dA * dA);\n  }\n\n  calculateRawInLab(\n    Lab1: { L: number; a: number; b: number },\n    Lab2: { L: number; a: number; b: number },\n  ) {\n    // Get L,a,b values for color 1\n    const L1 = Lab1.L;\n    const a1 = Lab1.a;\n    const b1 = Lab1.b;\n\n    // Get L,a,b values for color 2\n    const L2 = Lab2.L;\n    const a2 = Lab2.a;\n    const b2 = Lab2.b;\n\n    // Calculate Cprime1, Cprime2, Cabbar\n    const C1 = Math.sqrt(a1 * a1 + b1 * b1);\n    const C2 = Math.sqrt(a2 * a2 + b2 * b2);\n    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2.0) ** 7.0;\n\n    const G =\n      0.5 *\n      (1.0 -\n        Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))); // 25^7\n    const a1p = (1.0 + G) * a1;\n    const a2p = (1.0 + G) * a2;\n\n    const C1p = Math.sqrt(a1p * a1p + b1 * b1);\n    const C2p = Math.sqrt(a2p * a2p + b2 * b2);\n    const C1pC2p = C1p * C2p;\n\n    // Angles in Degree.\n    const h1p = CIEDE2000._calculatehp(b1, a1p);\n    const h2p = CIEDE2000._calculatehp(b2, a2p);\n    const h_bar = Math.abs(h1p - h2p);\n    const dLp = L2 - L1;\n    const dCp = C2p - C1p;\n    const dHp = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);\n    const ahp = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);\n\n    const T = CIEDE2000._calculateT(ahp);\n\n    const aCp = (C1p + C2p) / 2.0;\n    const aLp_minus_50_square = ((L1 + L2) / 2.0 - 50.0) ** 2.0;\n    const S_L =\n      1.0 +\n      (0.015 * aLp_minus_50_square) / Math.sqrt(20.0 + aLp_minus_50_square);\n    const S_C = 1.0 + 0.045 * aCp;\n    const S_H = 1.0 + 0.015 * T * aCp;\n\n    const R_T = CIEDE2000._calculateRT(ahp, aCp);\n\n    const dLpSL = dLp / S_L; // S_L * kL, where kL is 1.0\n    const dCpSC = dCp / S_C; // S_C * kC, where kC is 1.0\n    const dHpSH = dHp / S_H; // S_H * kH, where kH is 1.0\n\n    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cmetric.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\n\n/**\n * TODO: Name it: http://www.compuphase.com/cmetric.htm\n */\nexport class CMetric extends AbstractDistanceCalculator {\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const rmean = ((r1 + r2) / 2) * this._whitePoint.r;\n    const r = (r1 - r2) * this._whitePoint.r;\n    const g = (g1 - g2) * this._whitePoint.g;\n    const b = (b1 - b2) * this._whitePoint.b;\n    const dE =\n      (((512 + rmean) * r * r) >> 8) +\n      4 * g * g +\n      (((767 - rmean) * b * b) >> 8);\n    const dA = (a2 - a1) * this._whitePoint.a;\n\n    return Math.sqrt(dE + dA * dA);\n  }\n\n  protected _setDefaults() {}\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * euclidean.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { Y } from '../constants/bt709';\n\n/**\n * Euclidean color distance\n */\nexport abstract class AbstractEuclidean extends AbstractDistanceCalculator {\n  declare protected _kR: number;\n  declare protected _kG: number;\n  declare protected _kB: number;\n  declare protected _kA: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const dR = r2 - r1;\n    const dG = g2 - g1;\n    const dB = b2 - b1;\n    const dA = a2 - a1;\n    return Math.sqrt(\n      this._kR * dR * dR +\n        this._kG * dG * dG +\n        this._kB * dB * dB +\n        this._kA * dA * dA,\n    );\n  }\n}\n\nexport class Euclidean extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n}\n\n/**\n * Euclidean color distance (RGBQuant modification w Alpha)\n */\nexport class EuclideanBT709 extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n\n/**\n * Euclidean color distance (RGBQuant modification w/o Alpha)\n */\nexport class EuclideanBT709NoAlpha extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    this._kA = 0;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * manhattanNeuQuant.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { Y } from '../constants/bt709';\n\n/**\n * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients\n */\nexport abstract class AbstractManhattan extends AbstractDistanceCalculator {\n  declare protected _kR: number;\n  declare  protected _kG: number;\n  declare protected _kB: number;\n  declare protected _kA: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    let dR = r2 - r1;\n    let dG = g2 - g1;\n    let dB = b2 - b1;\n    let dA = a2 - a1;\n    if (dR < 0) dR = 0 - dR;\n    if (dG < 0) dG = 0 - dG;\n    if (dB < 0) dB = 0 - dB;\n    if (dA < 0) dA = 0 - dA;\n\n    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\n  }\n}\n\nexport class Manhattan extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n}\n\n/**\n * Manhattan distance (Nommyde modification)\n * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320\n */\nexport class ManhattanNommyde extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = 0.4984;\n    this._kG = 0.8625;\n    this._kB = 0.2979;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n\n/**\n * Manhattan distance (sRGB coefficients)\n */\nexport class ManhattanBT709 extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pngQuant.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\n\n/**\n * TODO: check quality of this distance equation\n * TODO: ask author for usage rights\n * taken from:\n * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}\n * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}\n */\nexport class PNGQuant extends AbstractDistanceCalculator {\n  /**\n   * Author's comments\n   * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black\n   * px_b.a   = px.a   + 1*(1-px.a)\n   * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white\n   * px_w.a   = px.a   + 1*(1-px.a)\n   *\n   * px_b.rgb = px.rgb              // difference same as in opaque RGB\n   * px_b.a   = 1\n   * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below\n   * px_w.a   = 1\n   *\n   * (px.rgb - px.a) - (py.rgb - py.a)\n   * (px.rgb - py.rgb) + (py.a - px.a)\n   *\n   */\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const alphas = (a2 - a1) * this._whitePoint.a;\n    return (\n      this._colordifferenceCh(\n        r1 * this._whitePoint.r,\n        r2 * this._whitePoint.r,\n        alphas,\n      ) +\n      this._colordifferenceCh(\n        g1 * this._whitePoint.g,\n        g2 * this._whitePoint.g,\n        alphas,\n      ) +\n      this._colordifferenceCh(\n        b1 * this._whitePoint.b,\n        b2 * this._whitePoint.b,\n        alphas,\n      )\n    );\n  }\n\n  private _colordifferenceCh(x: number, y: number, alphas: number) {\n    // maximum of channel blended on white, and blended on black\n    // premultiplied alpha and backgrounds 0/1 shorten the formula\n    const black = x - y;\n    const white = black + alphas;\n\n    return black * black + white * white;\n  }\n\n  protected _setDefaults() {}\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { AbstractPaletteQuantizer } from './paletteQuantizer';\nexport { NeuQuant } from './neuquant/neuquant';\nexport { NeuQuantFloat } from './neuquant/neuquantFloat';\nexport { RGBQuant } from './rgbquant/rgbquant';\nexport { ColorHistogram } from './rgbquant/colorHistogram';\nexport { WuQuant, WuColorCube } from './wu/wuQuant';\nexport { PaletteQuantizerYieldValue } from './paletteQuantizerYieldValue';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { PaletteQuantizerYieldValue } from './paletteQuantizerYieldValue';\n\nexport abstract class AbstractPaletteQuantizer {\n  abstract sample(pointContainer: PointContainer): void;\n  abstract quantize(): IterableIterator<PaletteQuantizerYieldValue>;\n\n  quantizeSync() {\n    for (const value of this.quantize()) {\n      if (value.palette) {\n        return value.palette;\n      }\n    }\n\n    throw new Error('unreachable');\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * point.ts - part of Image Quantization Library\n */\nimport { Y } from '../constants/bt709';\n\nexport interface PointRGBA {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\n/**\n * v8 optimized class\n * 1) \"constructor\" should have initialization with worst types\n * 2) \"set\" should have |0 / >>> 0\n */\nexport class Point implements PointRGBA {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n  uint32: number;\n  rgba: number[]; // TODO: better name is quadruplet or quad may be?\n  // Lab : { L : number; a : number; b : number };\n\n  static createByQuadruplet(quadruplet: number[]) {\n    const point = new Point();\n\n    point.r = quadruplet[0] | 0;\n    point.g = quadruplet[1] | 0;\n    point.b = quadruplet[2] | 0;\n    point.a = quadruplet[3] | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  static createByRGBA(red: number, green: number, blue: number, alpha: number) {\n    const point = new Point();\n\n    point.r = red | 0;\n    point.g = green | 0;\n    point.b = blue | 0;\n    point.a = alpha | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  static createByUint32(uint32: number) {\n    const point = new Point();\n\n    point.uint32 = uint32 >>> 0;\n    point._loadRGBA();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  constructor() {\n    this.uint32 = -1 >>> 0;\n    this.r = this.g = this.b = this.a = 0;\n    this.rgba = new Array(4);\n    this.rgba[0] = 0;\n    this.rgba[1] = 0;\n    this.rgba[2] = 0;\n    this.rgba[3] = 0;\n    /*\n     this.Lab = {\n     L : 0.0,\n     a : 0.0,\n     b : 0.0\n     };\n     */\n  }\n\n  from(point: Point) {\n    this.r = point.r;\n    this.g = point.g;\n    this.b = point.b;\n    this.a = point.a;\n    this.uint32 = point.uint32;\n    this.rgba[0] = point.r;\n    this.rgba[1] = point.g;\n    this.rgba[2] = point.b;\n    this.rgba[3] = point.a;\n\n    /*\n     this.Lab.L = point.Lab.L;\n     this.Lab.a = point.Lab.a;\n     this.Lab.b = point.Lab.b;\n     */\n  }\n\n  /*\n   * TODO:\n   Luminance from RGB:\n\n   Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]\n   Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]\n   Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]\n   */\n  getLuminosity(useAlphaChannel: boolean) {\n    let r = this.r;\n    let g = this.g;\n    let b = this.b;\n\n    if (useAlphaChannel) {\n      r = Math.min(255, 255 - this.a + (this.a * r) / 255);\n      g = Math.min(255, 255 - this.a + (this.a * g) / 255);\n      b = Math.min(255, 255 - this.a + (this.a * b) / 255);\n    }\n\n    // var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;\n\n    /*\n     if(useAlphaChannel) {\n     luma = (luma * (255 - this.a)) / 255;\n     }\n     */\n\n    return r * Y.RED + g * Y.GREEN + b * Y.BLUE;\n  }\n\n  private _loadUINT32() {\n    this.uint32 =\n      ((this.a << 24) | (this.b << 16) | (this.g << 8) | this.r) >>> 0;\n  }\n\n  private _loadRGBA() {\n    this.r = this.uint32 & 0xff;\n    this.g = (this.uint32 >>> 8) & 0xff;\n    this.b = (this.uint32 >>> 16) & 0xff;\n    this.a = (this.uint32 >>> 24) & 0xff;\n  }\n\n  private _loadQuadruplet() {\n    this.rgba[0] = this.r;\n    this.rgba[1] = this.g;\n    this.rgba[2] = this.b;\n    this.rgba[3] = this.a;\n\n    /*\n     var xyz = rgb2xyz(this.r, this.g, this.b);\n     var lab = xyz2lab(xyz.x, xyz.y, xyz.z);\n     this.lab.l = lab.l;\n     this.lab.a = lab.a;\n     this.lab.b = lab.b;\n     */\n  }\n\n  /*\n   private _loadLab() : void {\n   var Lab = Color.Conversion.rgb2lab(this.r, this.g, this.b);\n   this.Lab.L = Lab.L;\n   this.Lab.a = Lab.a;\n   this.Lab.b = Lab.b;\n   }\n   */\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pointContainer.ts - part of Image Quantization Library\n */\nimport { Point } from './point';\n\n/**\n * v8 optimizations done.\n * fromXXX methods are static to move out polymorphic code from class instance itself.\n */\nexport class PointContainer {\n  private readonly _pointArray: Point[];\n  private _width: number;\n  private _height: number;\n\n  constructor() {\n    this._width = 0;\n    this._height = 0;\n    this._pointArray = [];\n  }\n\n  getWidth() {\n    return this._width;\n  }\n\n  getHeight() {\n    return this._height;\n  }\n\n  setWidth(width: number) {\n    this._width = width;\n  }\n\n  setHeight(height: number) {\n    this._height = height;\n  }\n\n  getPointArray() {\n    return this._pointArray;\n  }\n\n  clone() {\n    const clone = new PointContainer();\n    clone._width = this._width;\n    clone._height = this._height;\n\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      clone._pointArray[i] = Point.createByUint32(\n        this._pointArray[i].uint32 | 0,\n      ); // \"| 0\" is added for v8 optimization\n    }\n\n    return clone;\n  }\n\n  toUint32Array() {\n    const l = this._pointArray.length;\n    const uint32Array = new Uint32Array(l);\n\n    for (let i = 0; i < l; i++) {\n      uint32Array[i] = this._pointArray[i].uint32;\n    }\n\n    return uint32Array;\n  }\n\n  toUint8Array() {\n    return new Uint8Array(this.toUint32Array().buffer);\n  }\n\n  static fromHTMLImageElement(img: HTMLImageElement) {\n    const width = img.naturalWidth;\n    const height = img.naturalHeight;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const ctx = canvas.getContext('2d')!;\n    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\n\n    return PointContainer.fromHTMLCanvasElement(canvas);\n  }\n\n  static fromHTMLCanvasElement(canvas: HTMLCanvasElement) {\n    const width = canvas.width;\n    const height = canvas.height;\n\n    const ctx = canvas.getContext('2d')!;\n    const imgData = ctx.getImageData(0, 0, width, height);\n\n    return PointContainer.fromImageData(imgData);\n  }\n\n  static fromImageData(imageData: ImageData) {\n    const width = imageData.width;\n    const height = imageData.height;\n\n    return PointContainer.fromUint8Array(imageData.data, width, height);\n  }\n\n  static fromUint8Array(\n    uint8Array: number[] | Uint8Array | Uint8ClampedArray,\n    width: number,\n    height: number,\n  ) {\n    switch (Object.prototype.toString.call(uint8Array)) {\n      case '[object Uint8ClampedArray]':\n      case '[object Uint8Array]':\n        break;\n\n      default:\n        uint8Array = new Uint8Array(uint8Array);\n    }\n\n    const uint32Array = new Uint32Array((uint8Array as Uint8Array).buffer);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n\n  static fromUint32Array(\n    uint32Array: Uint32Array,\n    width: number,\n    height: number,\n  ) {\n    const container = new PointContainer();\n\n    container._width = width;\n    container._height = height;\n\n    for (let i = 0, l = uint32Array.length; i < l; i++) {\n      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0); // \"| 0\" is added for v8 optimization\n    }\n\n    return container;\n  }\n\n  static fromBuffer(buffer: Buffer, width: number, height: number) {\n    const uint32Array = new Uint32Array(\n      buffer.buffer,\n      buffer.byteOffset,\n      buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT,\n    );\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * palette.ts - part of Image Quantization Library\n */\n\nimport { Point } from './point';\nimport { PointContainer } from './pointContainer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { rgb2hsl } from '../conversion/rgb2hsl';\n\n// TODO: make paletteArray via pointContainer, so, export will be available via pointContainer.exportXXX\n\nconst hueGroups = 10;\n\nexport function hueGroup(hue: number, segmentsNumber: number) {\n  const maxHue = 360;\n  const seg = maxHue / segmentsNumber;\n  const half = seg / 2;\n\n  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\n    if (hue >= mid && hue < mid + seg) return i;\n  }\n  return 0;\n}\n\nexport class Palette {\n  private readonly _pointContainer: PointContainer;\n  private readonly _pointArray: Point[] = [];\n  private _i32idx: { [key: string]: number } = {};\n\n  constructor() {\n    this._pointContainer = new PointContainer();\n    this._pointContainer.setHeight(1);\n    this._pointArray = this._pointContainer.getPointArray();\n  }\n\n  add(color: Point) {\n    this._pointArray.push(color);\n    this._pointContainer.setWidth(this._pointArray.length);\n  }\n\n  has(color: Point) {\n    for (let i = this._pointArray.length - 1; i >= 0; i--) {\n      if (color.uint32 === this._pointArray[i].uint32) return true;\n    }\n\n    return false;\n  }\n\n  // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\n  getNearestColor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    color: Point,\n  ) {\n    return this._pointArray[\n      this._getNearestIndex(colorDistanceCalculator, color) | 0\n    ];\n  }\n\n  getPointContainer() {\n    return this._pointContainer;\n  }\n\n  // TOTRY: use HUSL - http://boronine.com/husl/\n  /*\n   public nearestIndexByUint32(i32) {\n   var idx : number = this._nearestPointFromCache(\"\" + i32);\n   if (idx >= 0) return idx;\n\n   var min = 1000,\n   rgb = [\n   (i32 & 0xff),\n   (i32 >>> 8) & 0xff,\n   (i32 >>> 16) & 0xff,\n   (i32 >>> 24) & 0xff\n   ],\n   len = this._pointArray.length;\n\n   idx = 0;\n   for (var i = 0; i < len; i++) {\n   var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\n\n   if (dist < min) {\n   min = dist;\n   idx = i;\n   }\n   }\n\n   this._i32idx[i32] = idx;\n   return idx;\n   }\n   */\n\n  private _nearestPointFromCache(key: string) {\n    return typeof this._i32idx[key] === 'number' ? this._i32idx[key] : -1;\n  }\n\n  private _getNearestIndex(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    point: Point,\n  ) {\n    let idx = this._nearestPointFromCache('' + point.uint32);\n    if (idx >= 0) return idx;\n\n    let minimalDistance = Number.MAX_VALUE;\n\n    idx = 0;\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      const p = this._pointArray[i];\n      const distance = colorDistanceCalculator.calculateRaw(\n        point.r,\n        point.g,\n        point.b,\n        point.a,\n        p.r,\n        p.g,\n        p.b,\n        p.a,\n      );\n\n      if (distance < minimalDistance) {\n        minimalDistance = distance;\n        idx = i;\n      }\n    }\n\n    this._i32idx[point.uint32] = idx;\n    return idx;\n  }\n\n  /*\n   public reduce(histogram : ColorHistogram, colors : number) {\n   if (this._pointArray.length > colors) {\n   var idxi32 = histogram.getImportanceSortedColorsIDXI32();\n\n   // quantize histogram to existing palette\n   var keep = [], uniqueColors = 0, idx, pruned = false;\n\n   for (var i = 0, len = idxi32.length; i < len; i++) {\n   // palette length reached, unset all remaining colors (sparse palette)\n   if (uniqueColors >= colors) {\n   this.prunePal(keep);\n   pruned = true;\n   break;\n   } else {\n   idx = this.nearestIndexByUint32(idxi32[i]);\n   if (keep.indexOf(idx) < 0) {\n   keep.push(idx);\n   uniqueColors++;\n   }\n   }\n   }\n\n   if (!pruned) {\n   this.prunePal(keep);\n   }\n   }\n   }\n\n   // TODO: check usage, not tested!\n   public prunePal(keep : number[]) {\n   var colors = this._pointArray.length;\n   for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n   if (keep.indexOf(colorIndex) < 0) {\n\n   if(colorIndex + 1 < colors) {\n   this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\n   }\n   --colors;\n   //this._pointArray[colorIndex] = null;\n   }\n   }\n   console.log(\"colors pruned: \" + (this._pointArray.length - colors));\n   this._pointArray.length = colors;\n   this._i32idx = {};\n   }\n   */\n\n  // TODO: group very low lum and very high lum colors\n  // TODO: pass custom sort order\n  // TODO: sort criteria function should be placed to HueStats class\n  sort() {\n    this._i32idx = {};\n    this._pointArray.sort((a: Point, b: Point) => {\n      const hslA = rgb2hsl(a.r, a.g, a.b);\n      const hslB = rgb2hsl(b.r, b.g, b.b);\n\n      // sort all grays + whites together\n      const hueA =\n        a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);\n      const hueB =\n        b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);\n      /*\n       var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\n       var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\n       */\n\n      const hueDiff = hueB - hueA;\n      if (hueDiff) return -hueDiff;\n\n      /*\n       var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\n       if (lumDiff) return -lumDiff;\n       */\n      const lA = a.getLuminosity(true);\n      const lB = b.getLuminosity(true);\n\n      if (lB - lA !== 0) return lB - lA;\n\n      const satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);\n      if (satDiff) return -satDiff;\n\n      return 0;\n    });\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nimport * as arithmetic from './arithmetic';\nimport { HueStatistics } from './hueStatistics';\nimport { Palette } from './palette';\nimport { Point } from './point';\nimport { PointContainer } from './pointContainer';\nimport { ProgressTracker } from './progressTracker';\n\nexport {\n  Point,\n  PointContainer,\n  Palette,\n  HueStatistics,\n  ProgressTracker,\n  arithmetic,\n};\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * hueStatistics.ts - part of Image Quantization Library\n */\nimport { rgb2hsl } from '../conversion/rgb2hsl';\nimport { hueGroup } from './palette';\n\nclass HueGroup {\n  num = 0;\n  cols: number[] = [];\n}\n\nexport class HueStatistics {\n  private _numGroups: number;\n  private _minCols: number;\n  private _stats: HueGroup[];\n  private _groupsFull: number;\n\n  constructor(numGroups: number, minCols: number) {\n    this._numGroups = numGroups;\n    this._minCols = minCols;\n    this._stats = [];\n\n    for (let i = 0; i <= numGroups; i++) {\n      this._stats[i] = new HueGroup();\n    }\n\n    this._groupsFull = 0;\n  }\n\n  check(i32: number) {\n    if (this._groupsFull === this._numGroups + 1) {\n      this.check = () => {};\n    }\n\n    const r = i32 & 0xff;\n    const g = (i32 >>> 8) & 0xff;\n    const b = (i32 >>> 16) & 0xff;\n    const hg =\n      r === g && g === b\n        ? 0\n        : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);\n    const gr = this._stats[hg];\n    const min = this._minCols;\n\n    gr.num++;\n\n    if (gr.num > min) {\n      return;\n    }\n    if (gr.num === min) {\n      this._groupsFull++;\n    }\n\n    if (gr.num <= min) {\n      this._stats[hg].cols.push(i32);\n    }\n  }\n\n  injectIntoDictionary(histG: Record<string, number>) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col: number) => {\n          if (!histG[col]) {\n            histG[col] = 1;\n          } else {\n            histG[col]++;\n          }\n        });\n      }\n    }\n  }\n\n  injectIntoArray(histG: string[]) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col: unknown) => {\n          if (histG.indexOf(col as string) === -1) {\n            histG.push(col as string);\n          }\n        });\n      }\n    }\n  }\n}\n","export class ProgressTracker {\n  static readonly steps = 100;\n\n  progress: number;\n\n  private _step: number;\n  private _range: number;\n  private _last: number;\n  private _progressRange: number;\n\n  constructor(valueRange: number, progressRange: number) {\n    this._range = valueRange;\n    this._progressRange = progressRange;\n    this._step = Math.max(1, (this._range / (ProgressTracker.steps + 1)) | 0);\n    this._last = -this._step;\n    this.progress = 0;\n  }\n\n  shouldNotify(current: number) {\n    if (current - this._last >= this._step) {\n      this._last = current;\n      this.progress = Math.min(\n        (this._progressRange * this._last) / this._range,\n        this._progressRange,\n      );\n      return true;\n    }\n\n    return false;\n  }\n}\n","/*\n * NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\n\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\n// bias for colour values\nconst networkBiasShift = 3;\n\nclass Neuron {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n\n  constructor(defaultValue: number) {\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  /**\n   * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\n   * @example\n   * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\n   */\n  toPoint() {\n    return Point.createByRGBA(\n      this.r >> networkBiasShift,\n      this.g >> networkBiasShift,\n      this.b >> networkBiasShift,\n      this.a >> networkBiasShift,\n    );\n  }\n\n  subtract(r: number, g: number, b: number, a: number) {\n    this.r -= r | 0;\n    this.g -= g | 0;\n    this.b -= b | 0;\n    this.a -= a | 0;\n  }\n\n  /*\n   public subtract(r : number, g : number, b : number, a : number) : void {\n   this.r = (-r + this.r) | 0;\n   this.g = (-g + this.g) | 0;\n   this.b = (-b + this.b) | 0;\n   this.a = (-a + this.a) | 0;\n\n   this.r -= r;\n   this.g -= g;\n   this.b -= b;\n   this.a -= a;\n\n   this.r -= r | 0;\n   this.g -= g | 0;\n   this.b -= b | 0;\n   this.a -= a | 0;\n   }\n   */\n}\n\nexport class NeuQuant extends AbstractPaletteQuantizer {\n  /*\n   four primes near 500 - assume no image has a length so large\n   that it is divisible by all four primes\n   */\n  private static readonly _prime1 = 499;\n  private static readonly _prime2 = 491;\n  private static readonly _prime3 = 487;\n  private static readonly _prime4 = 503;\n  private static readonly _minpicturebytes = NeuQuant._prime4;\n\n  // no. of learning cycles\n  private static readonly _nCycles = 100;\n\n  // defs for freq and bias\n  private static readonly _initialBiasShift = 16;\n\n  // bias for fractions\n  private static readonly _initialBias = 1 << NeuQuant._initialBiasShift;\n  private static readonly _gammaShift = 10;\n\n  // gamma = 1024\n  // TODO: why gamma is never used?\n  // private static _gamma : number     = (1 << NeuQuant._gammaShift);\n  private static readonly _betaShift = 10;\n  private static readonly _beta = NeuQuant._initialBias >> NeuQuant._betaShift;\n\n  // beta = 1/1024\n  private static readonly _betaGamma =\n    NeuQuant._initialBias << (NeuQuant._gammaShift - NeuQuant._betaShift);\n\n  /*\n   * for 256 cols, radius starts\n   */\n  private static readonly _radiusBiasShift = 6;\n\n  // at 32.0 biased by 6 bits\n  private static readonly _radiusBias = 1 << NeuQuant._radiusBiasShift;\n\n  // and decreases by a factor of 1/30 each cycle\n  private static readonly _radiusDecrease = 30;\n\n  /* defs for decreasing alpha factor */\n\n  // alpha starts at 1.0\n  private static readonly _alphaBiasShift = 10;\n\n  // biased by 10 bits\n  private static readonly _initAlpha = 1 << NeuQuant._alphaBiasShift;\n\n  /* radBias and alphaRadBias used for radpower calculation */\n  private static readonly _radBiasShift = 8;\n  private static readonly _radBias = 1 << NeuQuant._radBiasShift;\n  private static readonly _alphaRadBiasShift =\n    NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;\n  private static readonly _alphaRadBias = 1 << NeuQuant._alphaRadBiasShift;\n\n  private _pointArray: Point[];\n  private readonly _networkSize: number;\n  private _network!: Neuron[];\n\n  /** sampling factor 1..30 */\n  private readonly _sampleFactor!: number;\n  private _radPower!: number[];\n\n  // bias and freq arrays for learning\n  private _freq!: number[];\n\n  /* for network lookup - really 256 */\n  private _bias!: number[];\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n    );\n  }\n\n  sample(pointContainer: PointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize(): IterableIterator<PaletteQuantizerYieldValue> {\n    this._init();\n\n    yield* this._learn();\n\n    yield {\n      palette: this._buildPalette(),\n      progress: 100,\n    };\n  }\n\n  private _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new Neuron(\n        ((i << (networkBiasShift + 8)) / this._networkSize) | 0,\n      );\n\n      // 1/this._networkSize\n      this._freq[i] = (NeuQuant._initialBias / this._networkSize) | 0;\n      this._bias[i] = 0;\n    }\n  }\n\n  /**\n   * Main Learning Loop\n   */\n  private *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < NeuQuant._minpicturebytes) sampleFactor = 1;\n\n    const alphadec = (30 + (sampleFactor - 1) / 3) | 0;\n    const pointsToSample = (pointsNumber / sampleFactor) | 0;\n\n    let delta = (pointsToSample / NeuQuant._nCycles) | 0;\n    let alpha = NeuQuant._initAlpha;\n    let radius = (this._networkSize >> 3) * NeuQuant._radiusBias;\n\n    let rad = radius >> NeuQuant._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] =\n        (alpha * (((rad * rad - i * i) * NeuQuant._radBias) / (rad * rad))) >>>\n        0;\n    }\n\n    let step;\n    if (pointsNumber < NeuQuant._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % NeuQuant._prime1 !== 0) {\n      step = NeuQuant._prime1;\n    } else if (pointsNumber % NeuQuant._prime2 !== 0) {\n      step = NeuQuant._prime2;\n    } else if (pointsNumber % NeuQuant._prime3 !== 0) {\n      step = NeuQuant._prime3;\n    } else {\n      step = NeuQuant._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n\n      /* alter neighbours */\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= (alpha / alphadec) | 0;\n        radius -= (radius / NeuQuant._radiusDecrease) | 0;\n        rad = radius >> NeuQuant._radiusBiasShift;\n\n        if (rad <= 1) rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] =\n            (alpha *\n              (((rad * rad - j * j) * NeuQuant._radBias) / (rad * rad))) >>>\n            0;\n        }\n      }\n    }\n  }\n\n  private _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  /**\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\n   */\n  private _alterNeighbour(\n    rad: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    al: number,\n  ) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / NeuQuant._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  /**\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   */\n  private _alterSingle(\n    alpha: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    a: number,\n  ) {\n    alpha /= NeuQuant._initAlpha;\n\n    /* alter hit neuron */\n    const n = this._network[i];\n    n.subtract(\n      alpha * (n.r - r),\n      alpha * (n.g - g),\n      alpha * (n.b - b),\n      alpha * (n.a - a),\n    );\n  }\n\n  /**\n   * Search for biased BGR values\n   * description:\n   *    finds closest neuron (min dist) and updates freq\n   *    finds best neuron (min dist-bias) and returns position\n   *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\n   *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\n   *\n   * Original distance equation:\n   *        dist = abs(dR) + abs(dG) + abs(dB)\n   */\n  private _contest(b: number, g: number, r: number, a: number) {\n    const multiplier = (255 * 4) << networkBiasShift;\n\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist =\n        (this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier) |\n        0;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist =\n        dist -\n        (this._bias[i] >> (NeuQuant._initialBiasShift - networkBiasShift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> NeuQuant._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << NeuQuant._gammaShift;\n    }\n    this._freq[bestpos] += NeuQuant._beta;\n    this._bias[bestpos] -= NeuQuant._betaGamma;\n    return bestbiaspos;\n  }\n}\n","/*\n * NeuQuantFloat Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\n// bias for colour values\nconst networkBiasShift = 3;\n\nclass NeuronFloat {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n\n  constructor(defaultValue: number) {\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  /**\n   * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\n   * @example\n   * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\n   */\n  toPoint() {\n    return Point.createByRGBA(\n      this.r >> networkBiasShift,\n      this.g >> networkBiasShift,\n      this.b >> networkBiasShift,\n      this.a >> networkBiasShift,\n    );\n  }\n\n  subtract(r: number, g: number, b: number, a: number) {\n    this.r -= r;\n    this.g -= g;\n    this.b -= b;\n    this.a -= a;\n  }\n}\n\nexport class NeuQuantFloat extends AbstractPaletteQuantizer {\n  /*\n   four primes near 500 - assume no image has a length so large\n   that it is divisible by all four primes\n   */\n  private static readonly _prime1 = 499;\n  private static readonly _prime2 = 491;\n  private static readonly _prime3 = 487;\n  private static readonly _prime4 = 503;\n  private static readonly _minpicturebytes = NeuQuantFloat._prime4;\n\n  // no. of learning cycles\n  private static readonly _nCycles = 100;\n\n  // defs for freq and bias\n  private static readonly _initialBiasShift = 16;\n\n  // bias for fractions\n  private static readonly _initialBias = 1 << NeuQuantFloat._initialBiasShift;\n  private static readonly _gammaShift = 10;\n\n  // gamma = 1024\n  // TODO: why gamma is never used?\n  // private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\n  private static readonly _betaShift = 10;\n  private static readonly _beta =\n    NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift;\n\n  // beta = 1/1024\n  private static readonly _betaGamma =\n    NeuQuantFloat._initialBias <<\n    (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift);\n\n  /*\n   * for 256 cols, radius starts\n   */\n  private static readonly _radiusBiasShift = 6;\n\n  // at 32.0 biased by 6 bits\n  private static readonly _radiusBias = 1 << NeuQuantFloat._radiusBiasShift;\n\n  // and decreases by a factor of 1/30 each cycle\n  private static readonly _radiusDecrease = 30;\n\n  /* defs for decreasing alpha factor */\n\n  // alpha starts at 1.0\n  private static readonly _alphaBiasShift = 10;\n\n  // biased by 10 bits\n  private static readonly _initAlpha = 1 << NeuQuantFloat._alphaBiasShift;\n\n  /* radBias and alphaRadBias used for radpower calculation */\n  private static readonly _radBiasShift = 8;\n  private static readonly _radBias = 1 << NeuQuantFloat._radBiasShift;\n  private static readonly _alphaRadBiasShift =\n    NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\n  private static readonly _alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift;\n\n  private _pointArray!: Point[];\n  private readonly _networkSize!: number;\n  private _network!: NeuronFloat[];\n\n  /** sampling factor 1..30 */\n  private readonly _sampleFactor!: number;\n  private _radPower!: number[];\n\n  // bias and freq arrays for learning\n  private _freq!: number[];\n\n  /* for network lookup - really 256 */\n  private _bias!: number[];\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n    );\n  }\n\n  sample(pointContainer: PointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize() {\n    this._init();\n    yield* this._learn();\n\n    yield {\n      palette: this._buildPalette(),\n      progress: 100,\n    };\n  }\n\n  private _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new NeuronFloat(\n        (i << (networkBiasShift + 8)) / this._networkSize,\n      );\n\n      // 1/this._networkSize\n      this._freq[i] = NeuQuantFloat._initialBias / this._networkSize;\n      this._bias[i] = 0;\n    }\n  }\n\n  /**\n   * Main Learning Loop\n   */\n  private *_learn(): IterableIterator<PaletteQuantizerYieldValue> {\n    let sampleFactor = this._sampleFactor;\n\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < NeuQuantFloat._minpicturebytes) sampleFactor = 1;\n\n    const alphadec = 30 + (sampleFactor - 1) / 3;\n    const pointsToSample = pointsNumber / sampleFactor;\n\n    let delta = (pointsToSample / NeuQuantFloat._nCycles) | 0;\n    let alpha = NeuQuantFloat._initAlpha;\n    let radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\n\n    let rad = radius >> NeuQuantFloat._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] =\n        alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));\n    }\n\n    let step;\n    if (pointsNumber < NeuQuantFloat._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % NeuQuantFloat._prime1 !== 0) {\n      step = NeuQuantFloat._prime1;\n    } else if (pointsNumber % NeuQuantFloat._prime2 !== 0) {\n      step = NeuQuantFloat._prime2;\n    } else if (pointsNumber % NeuQuantFloat._prime3 !== 0) {\n      step = NeuQuantFloat._prime3;\n    } else {\n      step = NeuQuantFloat._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n\n      /* alter neighbours */\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / NeuQuantFloat._radiusDecrease;\n        rad = radius >> NeuQuantFloat._radiusBiasShift;\n\n        if (rad <= 1) rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] =\n            alpha *\n            (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));\n        }\n      }\n    }\n  }\n\n  private _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  /**\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\n   */\n  private _alterNeighbour(\n    rad: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    al: number,\n  ) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  /**\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   */\n  private _alterSingle(\n    alpha: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    a: number,\n  ) {\n    alpha /= NeuQuantFloat._initAlpha;\n\n    /* alter hit neuron */\n    const n = this._network[i];\n    n.subtract(\n      alpha * (n.r - r),\n      alpha * (n.g - g),\n      alpha * (n.b - b),\n      alpha * (n.a - a),\n    );\n  }\n\n  /**\n   * Search for biased BGR values\n   * description:\n   *    finds closest neuron (min dist) and updates freq\n   *    finds best neuron (min dist-bias) and returns position\n   *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\n   *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\n   *\n   * Original distance equation:\n   *        dist = abs(dR) + abs(dG) + abs(dB)\n   */\n  private _contest(b: number, g: number, r: number, al: number) {\n    const multiplier = (255 * 4) << networkBiasShift;\n\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist =\n        this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist =\n        dist -\n        (this._bias[i] >> (NeuQuantFloat._initialBiasShift - networkBiasShift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> NeuQuantFloat._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << NeuQuantFloat._gammaShift;\n    }\n    this._freq[bestpos] += NeuQuantFloat._beta;\n    this._bias[bestpos] -= NeuQuantFloat._betaGamma;\n    return bestbiaspos;\n  }\n}\n","/*\n * Copyright (c) 2015, Leon Sorokin\n * All rights reserved. (MIT Licensed)\n *\n * ColorHistogram.js - an image quantization lib\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * colorHistogram.ts - part of Image Quantization Library\n */\nimport { HueStatistics } from '../../utils/hueStatistics';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { stableSort } from '../../utils/arithmetic';\n\ninterface Box {\n  x: number;\n  y: number;\n  h: number;\n  w: number;\n}\n\nexport class ColorHistogram {\n  private static _boxSize = [64, 64];\n  private static _boxPixels = 2;\n  private static _hueGroups = 10;\n\n  // 1 = by global population, 2 = subregion population threshold\n  private _method: number;\n\n  // HueStatistics instance\n  private _hueStats: HueStatistics;\n\n  private _histogram: { [color: string]: number };\n\n  // # of highest-frequency colors to start with for palette reduction\n  private _initColors: number;\n\n  // if > 0, enables hues stats and min-color retention per group\n  private _minHueCols: number;\n\n  constructor(method: number, colors: number) {\n    // 1 = by global population, 2 = subregion population threshold\n    this._method = method;\n\n    // if > 0, enables hues stats and min-color retention per group\n    this._minHueCols = colors << 2; // opts.minHueCols || 0;\n\n    // # of highest-frequency colors to start with for palette reduction\n    this._initColors = colors << 2;\n\n    // HueStatistics instance\n    this._hueStats = new HueStatistics(\n      ColorHistogram._hueGroups,\n      this._minHueCols,\n    );\n\n    this._histogram = Object.create(null);\n  }\n\n  sample(pointContainer: PointContainer) {\n    switch (this._method) {\n      case 1:\n        this._colorStats1D(pointContainer);\n        break;\n      case 2:\n        this._colorStats2D(pointContainer);\n        break;\n    }\n  }\n\n  getImportanceSortedColorsIDXI32() {\n    // TODO: fix typing issue in stableSort func\n    const sorted = stableSort(\n      Object.keys(this._histogram),\n      (a, b) => this._histogram[b] - this._histogram[a],\n    );\n    if (sorted.length === 0) {\n      return [];\n    }\n\n    let idxi32;\n    switch (this._method) {\n      case 1:\n        const initialColorsLimit = Math.min(sorted.length, this._initColors);\n        const last = sorted[initialColorsLimit - 1];\n        const freq = this._histogram[last];\n\n        idxi32 = sorted.slice(0, initialColorsLimit);\n\n        // add any cut off colors with same freq as last\n        let pos = initialColorsLimit;\n        const len = sorted.length;\n        while (pos < len && this._histogram[sorted[pos]] === freq) {\n          idxi32.push(sorted[pos++]);\n        }\n\n        // inject min huegroup colors\n        this._hueStats.injectIntoArray(idxi32);\n        break;\n\n      case 2:\n        idxi32 = sorted;\n        break;\n\n      default:\n        // TODO: rethink errors\n        throw new Error('Incorrect method');\n    }\n\n    // int32-ify values\n    return idxi32.map((v) => +v);\n  }\n\n  // global top-population\n  private _colorStats1D(pointContainer: PointContainer) {\n    const histG = this._histogram;\n    const pointArray = pointContainer.getPointArray();\n    const len = pointArray.length;\n\n    for (let i = 0; i < len; i++) {\n      const col = pointArray[i].uint32;\n\n      // collect hue stats\n      this._hueStats.check(col);\n\n      if (col in histG) {\n        histG[col]++;\n      } else {\n        histG[col] = 1;\n      }\n    }\n  }\n\n  // population threshold within subregions\n  // FIXME: this can over-reduce (few/no colors same?), need a way to keep\n  // important colors that dont ever reach local thresholds (gradients?)\n  private _colorStats2D(pointContainer: PointContainer) {\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const pointArray = pointContainer.getPointArray();\n\n    const boxW = ColorHistogram._boxSize[0];\n    const boxH = ColorHistogram._boxSize[1];\n    const area = boxW * boxH;\n    const boxes = this._makeBoxes(width, height, boxW, boxH);\n    const histG = this._histogram;\n\n    boxes.forEach((box) => {\n      let effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;\n      if (effc < 2) effc = 2;\n\n      const histL: Record<string, number> = {};\n      this._iterateBox(box, width, (i) => {\n        const col = pointArray[i].uint32;\n\n        // collect hue stats\n        this._hueStats.check(col);\n\n        if (col in histG) {\n          histG[col]++;\n        } else if (col in histL) {\n          if (++histL[col] >= effc) {\n            histG[col] = histL[col];\n          }\n        } else {\n          histL[col] = 1;\n        }\n      });\n    });\n\n    // inject min huegroup colors\n    this._hueStats.injectIntoDictionary(histG);\n  }\n\n  // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\n  private _iterateBox(bbox: Box, wid: number, fn: (i: number) => void) {\n    const b = bbox;\n    const i0 = b.y * wid + b.x;\n    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\n    const incr = wid - b.w + 1;\n\n    let cnt = 0;\n    let i = i0;\n\n    do {\n      fn.call(this, i);\n      i += ++cnt % b.w === 0 ? incr : 1;\n    } while (i <= i1);\n  }\n\n  /**\n   *    partitions a rectangle of width x height into\n   *    array of boxes stepX x stepY (or less)\n   */\n  private _makeBoxes(\n    width: number,\n    height: number,\n    stepX: number,\n    stepY: number,\n  ) {\n    const wrem = width % stepX;\n    const hrem = height % stepY;\n    const xend = width - wrem;\n    const yend = height - hrem;\n    const boxesArray = [];\n\n    for (let y = 0; y < height; y += stepY) {\n      for (let x = 0; x < width; x += stepX) {\n        boxesArray.push({\n          x,\n          y,\n          w: x === xend ? wrem : stepX,\n          h: y === yend ? hrem : stepY,\n        });\n      }\n    }\n\n    return boxesArray;\n  }\n}\n","/*\n * Copyright (c) 2015, Leon Sorokin\n * All rights reserved. (MIT Licensed)\n *\n * RGBQuant.js - an image quantization lib\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgbquant.ts - part of Image Quantization Library\n */\n\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { ColorHistogram } from './colorHistogram';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { stableSort } from '../../utils/arithmetic';\nimport { ProgressTracker } from '../../utils';\n\nclass RemovedColor {\n  readonly index: number;\n  readonly color: Point;\n  readonly distance: number;\n\n  constructor(index: number, color: Point, distance: number) {\n    this.index = index;\n    this.color = color;\n    this.distance = distance;\n  }\n}\n\n// TODO: make input/output image and input/output palettes with instances of class Point only!\nexport class RGBQuant extends AbstractPaletteQuantizer {\n  // desired final palette size\n  private readonly _colors: number;\n\n  // color-distance threshold for initial reduction pass\n  private readonly _initialDistance: number;\n\n  // subsequent passes threshold\n  private readonly _distanceIncrement: number;\n\n  // accumulated histogram\n  private readonly _histogram: ColorHistogram;\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n    method = 2,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    // desired final palette size\n    this._colors = colors;\n\n    // histogram to accumulate\n    this._histogram = new ColorHistogram(method, colors);\n\n    this._initialDistance = 0.01;\n    this._distanceIncrement = 0.005;\n  }\n\n  // gathers histogram info\n  sample(image: PointContainer) {\n    /*\n     var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];\n\n     for (var i = 0, l = pointArray.length; i < l; i++) {\n     var color = pointArray[i];\n     for (var componentIndex = 0; componentIndex < 4; componentIndex++) {\n     if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];\n     if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];\n     }\n     }\n     var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];\n     this._distance.setWhitePoint(rd, gd, bd, ad);\n\n     this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;\n     */\n\n    this._histogram.sample(image);\n  }\n\n  // reduces histogram to palette, remaps & memoizes reduced colors\n  *quantize() {\n    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\n    if (idxi32.length === 0) {\n      throw new Error('No colors in image');\n    }\n\n    yield* this._buildPalette(idxi32);\n  }\n\n  // reduces similar colors from an importance-sorted Uint32 rgba array\n  private *_buildPalette(\n    idxi32: number[],\n  ): IterableIterator<PaletteQuantizerYieldValue> {\n    // reduce histogram to create initial palette\n    // build full rgb palette\n    const palette = new Palette();\n    const colorArray = palette.getPointContainer().getPointArray();\n    const usageArray = new Array(idxi32.length);\n\n    for (let i = 0; i < idxi32.length; i++) {\n      colorArray.push(Point.createByUint32(idxi32[i]));\n      usageArray[i] = 1;\n    }\n\n    const len = colorArray.length;\n    const memDist = [];\n\n    let palLen = len;\n    let thold = this._initialDistance;\n\n    // palette already at or below desired length\n    const tracker = new ProgressTracker(palLen - this._colors, 99);\n    while (palLen > this._colors) {\n      memDist.length = 0;\n\n      // iterate palette\n      for (let i = 0; i < len; i++) {\n        if (tracker.shouldNotify(len - palLen)) {\n          yield {\n            progress: tracker.progress,\n          };\n        }\n\n        if (usageArray[i] === 0) continue;\n        const pxi = colorArray[i];\n        // if (!pxi) continue;\n\n        for (let j = i + 1; j < len; j++) {\n          if (usageArray[j] === 0) continue;\n          const pxj = colorArray[j];\n          // if (!pxj) continue;\n\n          const dist = this._distance.calculateNormalized(pxi, pxj);\n          if (dist < thold) {\n            // store index,rgb,dist\n            memDist.push(new RemovedColor(j, pxj, dist));\n            usageArray[j] = 0;\n            palLen--;\n          }\n        }\n      }\n      // palette reduction pass\n      // console.log(\"palette length: \" + palLen);\n\n      // if palette is still much larger than target, increment by larger initDist\n      thold +=\n        palLen > this._colors * 3\n          ? this._initialDistance\n          : this._distanceIncrement;\n    }\n\n    // if palette is over-reduced, re-add removed colors with largest distances from last round\n    if (palLen < this._colors) {\n      // sort descending\n      stableSort(memDist, (a, b) => b.distance - a.distance);\n\n      let k = 0;\n      while (palLen < this._colors && k < memDist.length) {\n        const removedColor = memDist[k];\n        // re-inject rgb into final palette\n        usageArray[removedColor.index] = 1;\n        palLen++;\n        k++;\n      }\n    }\n\n    let colors = colorArray.length;\n    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n      if (usageArray[colorIndex] === 0) {\n        if (colorIndex !== colors - 1) {\n          colorArray[colorIndex] = colorArray[colors - 1];\n        }\n        --colors;\n      }\n    }\n    colorArray.length = colors;\n\n    palette.sort();\n\n    yield {\n      palette,\n      progress: 100,\n    };\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * wuQuant.ts - part of Image Quantization Library\n */\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\nfunction createArray1D(dimension1: number) {\n  const a = [];\n  for (let k = 0; k < dimension1; k++) {\n    a[k] = 0;\n  }\n  return a;\n}\n\nfunction createArray4D(\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n  dimension4: number,\n): number[][][][] {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = new Array(dimension4);\n        for (let l = 0; l < dimension4; l++) {\n          a[i][j][k][l] = 0;\n        }\n      }\n    }\n  }\n  return a;\n}\n\nfunction createArray3D(\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n): number[][][] {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = 0;\n      }\n    }\n  }\n  return a;\n}\n\nfunction fillArray3D<T>(\n  a: T[][][],\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n  value: T,\n) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = [];\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = [];\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = value;\n      }\n    }\n  }\n}\n\nfunction fillArray1D<T>(a: T[], dimension1: number, value: T) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = value;\n  }\n}\n\nexport class WuColorCube {\n  redMinimum!: number;\n  redMaximum!: number;\n  greenMinimum!: number;\n  greenMaximum!: number;\n  blueMinimum!: number;\n  blueMaximum!: number;\n  volume!: number;\n  alphaMinimum!: number;\n  alphaMaximum!: number;\n}\n\nexport class WuQuant extends AbstractPaletteQuantizer {\n  private static readonly _alpha = 3;\n  private static readonly _red = 2;\n  private static readonly _green = 1;\n  private static readonly _blue = 0;\n\n  private _reds!: number[];\n  private _greens!: number[];\n  private _blues!: number[];\n  private _alphas!: number[];\n  private _sums!: number[];\n\n  private _weights!: number[][][][];\n  private _momentsRed!: number[][][][];\n  private _momentsGreen!: number[][][][];\n  private _momentsBlue!: number[][][][];\n  private _momentsAlpha!: number[][][][];\n  private _moments!: number[][][][];\n  private _table!: number[];\n  private _pixels!: Point[];\n\n  private _cubes!: WuColorCube[];\n  private _colors!: number;\n\n  private _significantBitsPerChannel!: number;\n  private _maxSideIndex!: number;\n  private _alphaMaxSideIndex!: number;\n  private _sideSize!: number;\n  private _alphaSideSize!: number;\n\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n    significantBitsPerChannel = 5,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._setQuality(significantBitsPerChannel);\n    this._initialize(colors);\n  }\n\n  sample(image: PointContainer) {\n    const pointArray = image.getPointArray();\n\n    for (let i = 0, l = pointArray.length; i < l; i++) {\n      this._addColor(pointArray[i]);\n    }\n\n    this._pixels = this._pixels.concat(pointArray);\n  }\n\n  *quantize() {\n    yield* this._preparePalette();\n\n    const palette = new Palette();\n\n    // generates palette\n    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\n      if (this._sums[paletteIndex] > 0) {\n        const sum = this._sums[paletteIndex];\n        const r = this._reds[paletteIndex] / sum;\n        const g = this._greens[paletteIndex] / sum;\n        const b = this._blues[paletteIndex] / sum;\n        const a = this._alphas[paletteIndex] / sum;\n\n        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\n        palette.add(color);\n      }\n    }\n\n    palette.sort();\n\n    yield {\n      palette,\n      progress: 100,\n    };\n  }\n\n  private *_preparePalette() {\n    // preprocess the colors\n    yield* this._calculateMoments();\n\n    let next = 0;\n    const volumeVariance = createArray1D(this._colors);\n\n    // processes the cubes\n    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\n      // if cut is possible; make it\n      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\n        volumeVariance[next] =\n          this._cubes[next].volume > 1\n            ? this._calculateVariance(this._cubes[next])\n            : 0.0;\n        volumeVariance[cubeIndex] =\n          this._cubes[cubeIndex].volume > 1\n            ? this._calculateVariance(this._cubes[cubeIndex])\n            : 0.0;\n      } else {\n        // the cut was not possible, revert the index\n        volumeVariance[next] = 0.0;\n        cubeIndex--;\n      }\n\n      next = 0;\n      let temp = volumeVariance[0];\n\n      for (let index = 1; index <= cubeIndex; ++index) {\n        if (volumeVariance[index] > temp) {\n          temp = volumeVariance[index];\n          next = index;\n        }\n      }\n\n      if (temp <= 0.0) {\n        this._colors = cubeIndex + 1;\n        break;\n      }\n    }\n\n    const lookupRed = [];\n    const lookupGreen = [];\n    const lookupBlue = [];\n    const lookupAlpha = [];\n\n    // precalculates lookup tables\n    for (let k = 0; k < this._colors; ++k) {\n      const weight = WuQuant._volume(this._cubes[k], this._weights);\n\n      if (weight > 0) {\n        lookupRed[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsRed) / weight) | 0;\n        lookupGreen[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsGreen) / weight) | 0;\n        lookupBlue[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsBlue) / weight) | 0;\n        lookupAlpha[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight) | 0;\n      } else {\n        lookupRed[k] = 0;\n        lookupGreen[k] = 0;\n        lookupBlue[k] = 0;\n        lookupAlpha[k] = 0;\n      }\n    }\n\n    this._reds = createArray1D(this._colors + 1);\n    this._greens = createArray1D(this._colors + 1);\n    this._blues = createArray1D(this._colors + 1);\n    this._alphas = createArray1D(this._colors + 1);\n    this._sums = createArray1D(this._colors + 1);\n\n    // scans and adds colors\n    for (let index = 0, l = this._pixels.length; index < l; index++) {\n      const color = this._pixels[index];\n\n      const match = -1;\n\n      let bestMatch = match;\n      let bestDistance = Number.MAX_VALUE;\n\n      for (let lookup = 0; lookup < this._colors; lookup++) {\n        const foundRed = lookupRed[lookup];\n        const foundGreen = lookupGreen[lookup];\n        const foundBlue = lookupBlue[lookup];\n        const foundAlpha = lookupAlpha[lookup];\n\n        const distance = this._distance.calculateRaw(\n          foundRed,\n          foundGreen,\n          foundBlue,\n          foundAlpha,\n          color.r,\n          color.g,\n          color.b,\n          color.a,\n        );\n\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = lookup;\n        }\n      }\n\n      this._reds[bestMatch] += color.r;\n      this._greens[bestMatch] += color.g;\n      this._blues[bestMatch] += color.b;\n      this._alphas[bestMatch] += color.a;\n      this._sums[bestMatch]++;\n    }\n  }\n\n  private _addColor(color: Point) {\n    const bitsToRemove = 8 - this._significantBitsPerChannel;\n    const indexRed = (color.r >> bitsToRemove) + 1;\n    const indexGreen = (color.g >> bitsToRemove) + 1;\n    const indexBlue = (color.b >> bitsToRemove) + 1;\n    const indexAlpha = (color.a >> bitsToRemove) + 1;\n\n    // if(color.a > 10) {\n    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\n    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\n    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\n    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\n    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\n    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] +=\n      this._table[color.r] +\n      this._table[color.g] +\n      this._table[color.b] +\n      this._table[color.a];\n    // }\n  }\n\n  /**\n   * Converts the histogram to a series of _moments.\n   */\n  private *_calculateMoments(): IterableIterator<PaletteQuantizerYieldValue> {\n    const area: number[] = [];\n    const areaRed: number[] = [];\n    const areaGreen: number[] = [];\n    const areaBlue: number[] = [];\n    const areaAlpha: number[] = [];\n    const area2: number[] = [];\n\n    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaRed = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaGreen = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaBlue = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaAlpha = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xarea2 = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n\n    let trackerProgress = 0;\n    const tracker = new ProgressTracker(\n      this._alphaMaxSideIndex * this._maxSideIndex,\n      99,\n    );\n\n    for (\n      let alphaIndex = 1;\n      alphaIndex <= this._alphaMaxSideIndex;\n      ++alphaIndex\n    ) {\n      fillArray3D<number>(\n        xarea,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaRed,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaGreen,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaBlue,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaAlpha,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xarea2,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n\n      for (\n        let redIndex = 1;\n        redIndex <= this._maxSideIndex;\n        ++redIndex, ++trackerProgress\n      ) {\n        if (tracker.shouldNotify(trackerProgress)) {\n          yield {\n            progress: tracker.progress,\n          };\n        }\n\n        fillArray1D<number>(area, this._sideSize, 0);\n        fillArray1D<number>(areaRed, this._sideSize, 0);\n        fillArray1D<number>(areaGreen, this._sideSize, 0);\n        fillArray1D<number>(areaBlue, this._sideSize, 0);\n        fillArray1D<number>(areaAlpha, this._sideSize, 0);\n        fillArray1D<number>(area2, this._sideSize, 0);\n\n        for (\n          let greenIndex = 1;\n          greenIndex <= this._maxSideIndex;\n          ++greenIndex\n        ) {\n          let line = 0;\n          let lineRed = 0;\n          let lineGreen = 0;\n          let lineBlue = 0;\n          let lineAlpha = 0;\n          let line2 = 0.0;\n\n          for (\n            let blueIndex = 1;\n            blueIndex <= this._maxSideIndex;\n            ++blueIndex\n          ) {\n            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineRed +=\n              this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineGreen +=\n              this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineBlue +=\n              this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineAlpha +=\n              this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\n            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\n\n            area[blueIndex] += line;\n            areaRed[blueIndex] += lineRed;\n            areaGreen[blueIndex] += lineGreen;\n            areaBlue[blueIndex] += lineBlue;\n            areaAlpha[blueIndex] += lineAlpha;\n            area2[blueIndex] += line2;\n\n            xarea[redIndex][greenIndex][blueIndex] =\n              xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\n            xareaRed[redIndex][greenIndex][blueIndex] =\n              xareaRed[redIndex - 1][greenIndex][blueIndex] +\n              areaRed[blueIndex];\n            xareaGreen[redIndex][greenIndex][blueIndex] =\n              xareaGreen[redIndex - 1][greenIndex][blueIndex] +\n              areaGreen[blueIndex];\n            xareaBlue[redIndex][greenIndex][blueIndex] =\n              xareaBlue[redIndex - 1][greenIndex][blueIndex] +\n              areaBlue[blueIndex];\n            xareaAlpha[redIndex][greenIndex][blueIndex] =\n              xareaAlpha[redIndex - 1][greenIndex][blueIndex] +\n              areaAlpha[blueIndex];\n            xarea2[redIndex][greenIndex][blueIndex] =\n              xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\n\n            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] +\n              xarea[redIndex][greenIndex][blueIndex];\n            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsRed[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaRed[redIndex][greenIndex][blueIndex];\n            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaGreen[redIndex][greenIndex][blueIndex];\n            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaBlue[redIndex][greenIndex][blueIndex];\n            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaAlpha[redIndex][greenIndex][blueIndex];\n            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] +\n              xarea2[redIndex][greenIndex][blueIndex];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Computes the volume of the cube in a specific moment.\n   */\n  private static _volumeFloat(cube: WuColorCube, moment: number[][][][]) {\n    return (\n      moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMinimum\n      ] -\n        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n          cube.blueMinimum\n        ])\n    );\n  }\n\n  /**\n   * Computes the volume of the cube in a specific moment.\n   */\n  private static _volume(cube: WuColorCube, moment: number[][][][]) {\n    return WuQuant._volumeFloat(cube, moment) | 0;\n  }\n\n  /**\n   * Splits the cube in given position][and color direction.\n   */\n  private static _top(\n    cube: WuColorCube,\n    direction: number,\n    position: number,\n    moment: number[][][][],\n  ) {\n    let result;\n    switch (direction) {\n      case WuQuant._alpha:\n        result =\n          moment[position][cube.redMaximum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[position][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[position][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[position][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (moment[position][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n            moment[position][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[position][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] +\n            moment[position][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._red:\n        result =\n          moment[cube.alphaMaximum][position][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMaximum][position][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][position][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][position][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (moment[cube.alphaMaximum][position][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n            moment[cube.alphaMaximum][position][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][position][cube.greenMaximum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][position][cube.greenMinimum][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._green:\n        result =\n          moment[cube.alphaMaximum][cube.redMaximum][position][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][position][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMaximum][position][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][position][\n            cube.blueMaximum\n          ] -\n          (moment[cube.alphaMaximum][cube.redMaximum][position][\n            cube.blueMinimum\n          ] -\n            moment[cube.alphaMaximum][cube.redMinimum][position][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMaximum][position][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][position][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._blue:\n        result =\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n            position\n          ] -\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            position\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            position\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            position\n          ] -\n          (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            position\n          ] -\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              position\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              position\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              position\n            ]);\n        break;\n      default:\n        throw new Error('impossible');\n    }\n\n    return result | 0;\n  }\n\n  /**\n   * Splits the cube in a given color direction at its minimum.\n   */\n  private static _bottom(\n    cube: WuColorCube,\n    direction: number,\n    moment: number[][][][],\n  ) {\n    switch (direction) {\n      case WuQuant._alpha:\n        return (\n          -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._red:\n        return (\n          -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._green:\n        return (\n          -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._blue:\n        return (\n          -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMinimum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMinimum\n          ] -\n          (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      default:\n        // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?\n        return 0;\n    }\n  }\n\n  /**\n   * Calculates statistical variance for a given cube.\n   */\n  private _calculateVariance(cube: WuColorCube) {\n    const volumeRed = WuQuant._volume(cube, this._momentsRed);\n    const volumeGreen = WuQuant._volume(cube, this._momentsGreen);\n    const volumeBlue = WuQuant._volume(cube, this._momentsBlue);\n    const volumeAlpha = WuQuant._volume(cube, this._momentsAlpha);\n    const volumeMoment = WuQuant._volumeFloat(cube, this._moments);\n    const volumeWeight = WuQuant._volume(cube, this._weights);\n    const distance =\n      volumeRed * volumeRed +\n      volumeGreen * volumeGreen +\n      volumeBlue * volumeBlue +\n      volumeAlpha * volumeAlpha;\n\n    return volumeMoment - distance / volumeWeight;\n  }\n\n  /**\n   * Finds the optimal (maximal) position for the cut.\n   */\n  private _maximize(\n    cube: WuColorCube,\n    direction: number,\n    first: number,\n    last: number,\n    wholeRed: number,\n    wholeGreen: number,\n    wholeBlue: number,\n    wholeAlpha: number,\n    wholeWeight: number,\n  ) {\n    const bottomRed = WuQuant._bottom(cube, direction, this._momentsRed) | 0;\n    const bottomGreen =\n      WuQuant._bottom(cube, direction, this._momentsGreen) | 0;\n    const bottomBlue = WuQuant._bottom(cube, direction, this._momentsBlue) | 0;\n    const bottomAlpha =\n      WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;\n    const bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;\n\n    let result = 0.0;\n    let cutPosition = -1;\n\n    for (let position = first; position < last; ++position) {\n      // determines the cube cut at a certain position\n      let halfRed =\n        bottomRed + WuQuant._top(cube, direction, position, this._momentsRed);\n      let halfGreen =\n        bottomGreen +\n        WuQuant._top(cube, direction, position, this._momentsGreen);\n      let halfBlue =\n        bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue);\n      let halfAlpha =\n        bottomAlpha +\n        WuQuant._top(cube, direction, position, this._momentsAlpha);\n      let halfWeight =\n        bottomWeight + WuQuant._top(cube, direction, position, this._weights);\n\n      // the cube cannot be cut at bottom (this would lead to empty cube)\n      if (halfWeight !== 0) {\n        let halfDistance =\n          halfRed * halfRed +\n          halfGreen * halfGreen +\n          halfBlue * halfBlue +\n          halfAlpha * halfAlpha;\n        let temp = halfDistance / halfWeight;\n\n        halfRed = wholeRed - halfRed;\n        halfGreen = wholeGreen - halfGreen;\n        halfBlue = wholeBlue - halfBlue;\n        halfAlpha = wholeAlpha - halfAlpha;\n        halfWeight = wholeWeight - halfWeight;\n\n        if (halfWeight !== 0) {\n          halfDistance =\n            halfRed * halfRed +\n            halfGreen * halfGreen +\n            halfBlue * halfBlue +\n            halfAlpha * halfAlpha;\n          temp += halfDistance / halfWeight;\n\n          if (temp > result) {\n            result = temp;\n            cutPosition = position;\n          }\n        }\n      }\n    }\n\n    return { max: result, position: cutPosition };\n  }\n\n  // Cuts a cube with another one.\n  private _cut(first: WuColorCube, second: WuColorCube) {\n    let direction;\n\n    const wholeRed = WuQuant._volume(first, this._momentsRed);\n    const wholeGreen = WuQuant._volume(first, this._momentsGreen);\n    const wholeBlue = WuQuant._volume(first, this._momentsBlue);\n    const wholeAlpha = WuQuant._volume(first, this._momentsAlpha);\n    const wholeWeight = WuQuant._volume(first, this._weights);\n\n    const red = this._maximize(\n      first,\n      WuQuant._red,\n      first.redMinimum + 1,\n      first.redMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const green = this._maximize(\n      first,\n      WuQuant._green,\n      first.greenMinimum + 1,\n      first.greenMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const blue = this._maximize(\n      first,\n      WuQuant._blue,\n      first.blueMinimum + 1,\n      first.blueMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const alpha = this._maximize(\n      first,\n      WuQuant._alpha,\n      first.alphaMinimum + 1,\n      first.alphaMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n\n    if (\n      alpha.max >= red.max &&\n      alpha.max >= green.max &&\n      alpha.max >= blue.max\n    ) {\n      direction = WuQuant._alpha;\n\n      // cannot split empty cube\n      if (alpha.position < 0) return false;\n    } else if (\n      red.max >= alpha.max &&\n      red.max >= green.max &&\n      red.max >= blue.max\n    ) {\n      direction = WuQuant._red;\n    } else if (\n      green.max >= alpha.max &&\n      green.max >= red.max &&\n      green.max >= blue.max\n    ) {\n      direction = WuQuant._green;\n    } else {\n      direction = WuQuant._blue;\n    }\n\n    second.redMaximum = first.redMaximum;\n    second.greenMaximum = first.greenMaximum;\n    second.blueMaximum = first.blueMaximum;\n    second.alphaMaximum = first.alphaMaximum;\n\n    // cuts in a certain direction\n    switch (direction) {\n      case WuQuant._red:\n        second.redMinimum = first.redMaximum = red.position;\n        second.greenMinimum = first.greenMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._green:\n        second.greenMinimum = first.greenMaximum = green.position;\n        second.redMinimum = first.redMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._blue:\n        second.blueMinimum = first.blueMaximum = blue.position;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._alpha:\n        second.alphaMinimum = first.alphaMaximum = alpha.position;\n        second.blueMinimum = first.blueMinimum;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        break;\n    }\n\n    // determines the volumes after cut\n    first.volume =\n      (first.redMaximum - first.redMinimum) *\n      (first.greenMaximum - first.greenMinimum) *\n      (first.blueMaximum - first.blueMinimum) *\n      (first.alphaMaximum - first.alphaMinimum);\n    second.volume =\n      (second.redMaximum - second.redMinimum) *\n      (second.greenMaximum - second.greenMinimum) *\n      (second.blueMaximum - second.blueMinimum) *\n      (second.alphaMaximum - second.alphaMinimum);\n\n    // the cut was successful\n    return true;\n  }\n\n  private _initialize(colors: number) {\n    this._colors = colors;\n\n    // creates all the _cubes\n    this._cubes = [];\n\n    // initializes all the _cubes\n    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\n      this._cubes[cubeIndex] = new WuColorCube();\n    }\n\n    // resets the reference minimums\n    this._cubes[0].redMinimum = 0;\n    this._cubes[0].greenMinimum = 0;\n    this._cubes[0].blueMinimum = 0;\n    this._cubes[0].alphaMinimum = 0;\n\n    // resets the reference maximums\n    this._cubes[0].redMaximum = this._maxSideIndex;\n    this._cubes[0].greenMaximum = this._maxSideIndex;\n    this._cubes[0].blueMaximum = this._maxSideIndex;\n    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\n\n    this._weights = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsRed = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsGreen = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsBlue = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsAlpha = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._moments = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n\n    this._table = [];\n    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\n      this._table[tableIndex] = tableIndex * tableIndex;\n    }\n\n    this._pixels = [];\n  }\n\n  private _setQuality(significantBitsPerChannel = 5) {\n    this._significantBitsPerChannel = significantBitsPerChannel;\n    this._maxSideIndex = 1 << this._significantBitsPerChannel;\n    this._alphaMaxSideIndex = this._maxSideIndex;\n\n    this._sideSize = this._maxSideIndex + 1;\n    this._alphaSideSize = this._alphaMaxSideIndex + 1;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\n\nexport { AbstractImageQuantizer } from './imageQuantizer';\nexport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nexport { NearestColor } from './nearestColor';\nexport { ErrorDiffusionArray, ErrorDiffusionArrayKernel } from './array';\nexport { ErrorDiffusionRiemersma } from './riemersma';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\n\nexport abstract class AbstractImageQuantizer {\n  abstract quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue>;\n\n  quantizeSync(pointContainer: PointContainer, palette: Palette) {\n    for (const value of this.quantize(pointContainer, palette)) {\n      if (value.pointContainer) {\n        return value.pointContainer;\n      }\n    }\n\n    throw new Error('unreachable');\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * nearestColor.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nimport { ProgressTracker } from '../utils/progressTracker';\n\nexport class NearestColor extends AbstractImageQuantizer {\n  private _distance: AbstractDistanceCalculator;\n\n  constructor(colorDistanceCalculator: AbstractDistanceCalculator) {\n    super();\n    this._distance = colorDistanceCalculator;\n  }\n\n  /**\n   * Mutates pointContainer\n   */\n  *quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue> {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n\n    const tracker = new ProgressTracker(height, 99);\n    for (let y = 0; y < height; y++) {\n      if (tracker.shouldNotify(y)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n      for (let x = 0, idx = y * width; x < width; x++, idx++) {\n        // Image pixel\n        const point = pointArray[idx];\n        // Reduced pixel\n        point.from(palette.getNearestColor(this._distance, point));\n      }\n    }\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { Point } from '../utils/point';\nimport { inRange0to255Rounded } from '../utils/arithmetic';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nimport { ProgressTracker } from '../utils/progressTracker';\n\n// TODO: is it the best name for this enum \"kernel\"?\nexport enum ErrorDiffusionArrayKernel {\n  FloydSteinberg = 0,\n  FalseFloydSteinberg,\n  Stucki,\n  Atkinson,\n  Jarvis,\n  Burkes,\n  Sierra,\n  TwoSierra,\n  SierraLite,\n}\n\n// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\nexport class ErrorDiffusionArray extends AbstractImageQuantizer {\n  private _minColorDistance: number;\n  private _serpentine: boolean;\n  private _kernel!: number[][];\n  /** true = GIMP, false = XNVIEW */\n  private _calculateErrorLikeGIMP: boolean;\n\n  private _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    kernel: ErrorDiffusionArrayKernel,\n    serpentine = true,\n    minimumColorDistanceToDither = 0,\n    calculateErrorLikeGIMP = false,\n  ) {\n    super();\n    this._setKernel(kernel);\n\n    this._distance = colorDistanceCalculator;\n    this._minColorDistance = minimumColorDistanceToDither;\n    this._serpentine = serpentine;\n    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\n  }\n\n  /**\n   * adapted from http://jsbin.com/iXofIji/2/edit by PAEz\n   * fixed version. it doesn't use image pixels as error storage, also it doesn't have 0.3 + 0.3 + 0.3 + 0.3 = 0 error\n   * Mutates pointContainer\n   */\n  *quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue> {\n    const pointArray = pointContainer.getPointArray();\n    const originalPoint = new Point();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorLines: number[][][] = [];\n\n    let dir = 1;\n    let maxErrorLines = 1;\n\n    // initial error lines (number is taken from dithering kernel)\n    for (const kernel of this._kernel) {\n      const kernelErrorLines = kernel[2] + 1;\n      if (maxErrorLines < kernelErrorLines) maxErrorLines = kernelErrorLines;\n    }\n    for (let i = 0; i < maxErrorLines; i++) {\n      this._fillErrorLine((errorLines[i] = []), width);\n    }\n\n    const tracker = new ProgressTracker(height, 99);\n    for (let y = 0; y < height; y++) {\n      if (tracker.shouldNotify(y)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      // always serpentine\n      if (this._serpentine) dir *= -1;\n\n      const lni = y * width;\n      const xStart = dir === 1 ? 0 : width - 1;\n      const xEnd = dir === 1 ? width : -1;\n\n      // cyclic shift with erasing\n      this._fillErrorLine(errorLines[0], width);\n      // TODO: why it is needed to cast types here?\n      errorLines.push(errorLines.shift() as number[][]);\n\n      const errorLine = errorLines[0];\n      for (\n        let x = xStart, idx = lni + xStart;\n        x !== xEnd;\n        x += dir, idx += dir\n      ) {\n        // Image pixel\n        const point = pointArray[idx];\n        // originalPoint = new Utils.Point(),\n        const error = errorLine[x];\n\n        originalPoint.from(point);\n\n        const correctedPoint = Point.createByRGBA(\n          inRange0to255Rounded(point.r + error[0]),\n          inRange0to255Rounded(point.g + error[1]),\n          inRange0to255Rounded(point.b + error[2]),\n          inRange0to255Rounded(point.a + error[3]),\n        );\n\n        // Reduced pixel\n        const palettePoint = palette.getNearestColor(\n          this._distance,\n          correctedPoint,\n        );\n        point.from(palettePoint);\n\n        // dithering strength\n        if (this._minColorDistance) {\n          const dist = this._distance.calculateNormalized(\n            originalPoint,\n            palettePoint,\n          );\n          if (dist < this._minColorDistance) continue;\n        }\n\n        // Component distance\n        let er;\n        let eg;\n        let eb;\n        let ea;\n        if (this._calculateErrorLikeGIMP) {\n          er = correctedPoint.r - palettePoint.r;\n          eg = correctedPoint.g - palettePoint.g;\n          eb = correctedPoint.b - palettePoint.b;\n          ea = correctedPoint.a - palettePoint.a;\n        } else {\n          er = originalPoint.r - palettePoint.r;\n          eg = originalPoint.g - palettePoint.g;\n          eb = originalPoint.b - palettePoint.b;\n          ea = originalPoint.a - palettePoint.a;\n        }\n\n        const dStart = dir === 1 ? 0 : this._kernel.length - 1;\n        const dEnd = dir === 1 ? this._kernel.length : -1;\n\n        for (let i = dStart; i !== dEnd; i += dir) {\n          const x1 = this._kernel[i][1] * dir;\n          const y1 = this._kernel[i][2];\n\n          if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n            const d = this._kernel[i][0];\n            const e = errorLines[y1][x1 + x];\n\n            e[0] += er * d;\n            e[1] += eg * d;\n            e[2] += eb * d;\n            e[3] += ea * d;\n          }\n        }\n      }\n    }\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n\n  private _fillErrorLine(errorLine: number[][], width: number) {\n    // shrink\n    if (errorLine.length > width) {\n      errorLine.length = width;\n    }\n\n    // reuse existing arrays\n    const l = errorLine.length;\n    for (let i = 0; i < l; i++) {\n      const error = errorLine[i];\n      error[0] = error[1] = error[2] = error[3] = 0;\n    }\n\n    // create missing arrays\n    for (let i = l; i < width; i++) {\n      errorLine[i] = [0.0, 0.0, 0.0, 0.0];\n    }\n  }\n\n  private _setKernel(kernel: ErrorDiffusionArrayKernel) {\n    switch (kernel) {\n      case ErrorDiffusionArrayKernel.FloydSteinberg:\n        this._kernel = [\n          [7 / 16, 1, 0],\n          [3 / 16, -1, 1],\n          [5 / 16, 0, 1],\n          [1 / 16, 1, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.FalseFloydSteinberg:\n        this._kernel = [\n          [3 / 8, 1, 0],\n          [3 / 8, 0, 1],\n          [2 / 8, 1, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Stucki:\n        this._kernel = [\n          [8 / 42, 1, 0],\n          [4 / 42, 2, 0],\n          [2 / 42, -2, 1],\n          [4 / 42, -1, 1],\n          [8 / 42, 0, 1],\n          [4 / 42, 1, 1],\n          [2 / 42, 2, 1],\n          [1 / 42, -2, 2],\n          [2 / 42, -1, 2],\n          [4 / 42, 0, 2],\n          [2 / 42, 1, 2],\n          [1 / 42, 2, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Atkinson:\n        this._kernel = [\n          [1 / 8, 1, 0],\n          [1 / 8, 2, 0],\n          [1 / 8, -1, 1],\n          [1 / 8, 0, 1],\n          [1 / 8, 1, 1],\n          [1 / 8, 0, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Jarvis:\n        this._kernel = [\n          // Jarvis, Judice, and Ninke / JJN?\n          [7 / 48, 1, 0],\n          [5 / 48, 2, 0],\n          [3 / 48, -2, 1],\n          [5 / 48, -1, 1],\n          [7 / 48, 0, 1],\n          [5 / 48, 1, 1],\n          [3 / 48, 2, 1],\n          [1 / 48, -2, 2],\n          [3 / 48, -1, 2],\n          [5 / 48, 0, 2],\n          [3 / 48, 1, 2],\n          [1 / 48, 2, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Burkes:\n        this._kernel = [\n          [8 / 32, 1, 0],\n          [4 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [8 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Sierra:\n        this._kernel = [\n          [5 / 32, 1, 0],\n          [3 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [5 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1],\n          [2 / 32, -1, 2],\n          [3 / 32, 0, 2],\n          [2 / 32, 1, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.TwoSierra:\n        this._kernel = [\n          [4 / 16, 1, 0],\n          [3 / 16, 2, 0],\n          [1 / 16, -2, 1],\n          [2 / 16, -1, 1],\n          [3 / 16, 0, 1],\n          [2 / 16, 1, 1],\n          [1 / 16, 2, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.SierraLite:\n        this._kernel = [\n          [2 / 4, 1, 0],\n          [1 / 4, -1, 1],\n          [1 / 4, 0, 1],\n        ];\n        break;\n\n      default:\n        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);\n    }\n  }\n}\n","import { ProgressTracker } from '../../utils/progressTracker';\nimport { ImageQuantizerYieldValue } from '../imageQuantizerYieldValue';\n\nenum Direction {\n  NONE = 0,\n  UP,\n  LEFT,\n  RIGHT,\n  DOWN,\n}\n\ninterface Data {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  level: number;\n  index: number;\n  tracker: ProgressTracker;\n  callback(x: number, y: number): void;\n}\n\nexport function* hilbertCurve(\n  width: number,\n  height: number,\n  callback: (x: number, y: number) => void,\n) {\n  const maxBound = Math.max(width, height);\n  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);\n  const tracker = new ProgressTracker(width * height, 99);\n  const data = {\n    width,\n    height,\n    level,\n    callback,\n    tracker,\n    index: 0,\n    x: 0,\n    y: 0,\n  };\n  yield* walkHilbert(data, Direction.UP);\n  visit(data, Direction.NONE);\n}\n\nfunction* walkHilbert(\n  data: Data,\n  direction: Direction,\n): IterableIterator<ImageQuantizerYieldValue> {\n  if (data.level < 1) return;\n\n  if (data.tracker.shouldNotify(data.index)) {\n    yield { progress: data.tracker.progress };\n  }\n  data.level--;\n  switch (direction) {\n    case Direction.LEFT:\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.DOWN);\n      break;\n\n    case Direction.RIGHT:\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.UP);\n      break;\n\n    case Direction.UP:\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.RIGHT);\n      break;\n\n    case Direction.DOWN:\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.LEFT);\n      break;\n\n    default:\n      break;\n  }\n  data.level++;\n}\n\nfunction visit(data: Data, direction: Direction) {\n  if (\n    data.x >= 0 &&\n    data.x < data.width &&\n    data.y >= 0 &&\n    data.y < data.height\n  ) {\n    data.callback(data.x, data.y);\n    data.index++;\n  }\n  switch (direction) {\n    case Direction.LEFT:\n      data.x--;\n      break;\n    case Direction.RIGHT:\n      data.x++;\n      break;\n    case Direction.UP:\n      data.y--;\n      break;\n    case Direction.DOWN:\n      data.y++;\n      break;\n  }\n}\n","/**\n * @preserve\n * MIT License\n *\n * Copyright 2015-2018 Igor Bezkrovnyi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * riemersma.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { hilbertCurve } from './spaceFillingCurves/hilbertCurve';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { Point } from '../utils/point';\nimport { inRange0to255Rounded } from '../utils/arithmetic';\n\nexport class ErrorDiffusionRiemersma extends AbstractImageQuantizer {\n  private _distance: AbstractDistanceCalculator;\n  private _weights: number[];\n  private _errorQueueSize: number;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    errorQueueSize = 16,\n    errorPropagation = 1,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._errorQueueSize = errorQueueSize;\n    this._weights = ErrorDiffusionRiemersma._createWeights(\n      errorPropagation,\n      errorQueueSize,\n    );\n  }\n\n  /**\n   * Mutates pointContainer\n   */\n  *quantize(pointContainer: PointContainer, palette: Palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorQueue: Array<{\n      r: number;\n      g: number;\n      b: number;\n      a: number;\n    }> = [];\n\n    let head = 0;\n\n    for (let i = 0; i < this._errorQueueSize; i++) {\n      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };\n    }\n\n    yield* hilbertCurve(width, height, (x, y) => {\n      const p = pointArray[x + y * width];\n      let { r, g, b, a } = p;\n      for (let i = 0; i < this._errorQueueSize; i++) {\n        const weight = this._weights[i];\n        const e = errorQueue[(i + head) % this._errorQueueSize];\n\n        r += e.r * weight;\n        g += e.g * weight;\n        b += e.b * weight;\n        a += e.a * weight;\n      }\n\n      const correctedPoint = Point.createByRGBA(\n        inRange0to255Rounded(r),\n        inRange0to255Rounded(g),\n        inRange0to255Rounded(b),\n        inRange0to255Rounded(a),\n      );\n\n      const quantizedPoint = palette.getNearestColor(\n        this._distance,\n        correctedPoint,\n      );\n\n      // update head and calculate tail\n      head = (head + 1) % this._errorQueueSize;\n      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\n\n      // update error with new value\n      errorQueue[tail].r = p.r - quantizedPoint.r;\n      errorQueue[tail].g = p.g - quantizedPoint.g;\n      errorQueue[tail].b = p.b - quantizedPoint.b;\n      errorQueue[tail].a = p.a - quantizedPoint.a;\n\n      // update point\n      p.from(quantizedPoint);\n    });\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n\n  private static _createWeights(\n    errorPropagation: number,\n    errorQueueSize: number,\n  ) {\n    const weights = [];\n\n    const multiplier = Math.exp(\n      Math.log(errorQueueSize) / (errorQueueSize - 1),\n    );\n    for (let i = 0, next = 1; i < errorQueueSize; i++) {\n      weights[i] = (((next + 0.5) | 0) / errorQueueSize) * errorPropagation;\n      next *= multiplier;\n    }\n\n    return weights;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { ssim } from './ssim';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ssim.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { Y } from '../constants/bt709';\n\n// based on https://github.com/rhys-e/structural-similarity\n// http://en.wikipedia.org/wiki/Structural_similarity\nconst K1 = 0.01;\nconst K2 = 0.03;\n\nexport function ssim(image1: PointContainer, image2: PointContainer) {\n  if (\n    image1.getHeight() !== image2.getHeight() ||\n    image1.getWidth() !== image2.getWidth()\n  ) {\n    throw new Error('Images have different sizes!');\n  }\n\n  const bitsPerComponent = 8;\n  const L = (1 << bitsPerComponent) - 1;\n  const c1 = (K1 * L) ** 2;\n  const c2 = (K2 * L) ** 2;\n\n  let numWindows = 0;\n  let mssim = 0.0;\n\n  // calculate ssim for each window\n  iterate(\n    image1,\n    image2,\n    (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {\n      // calculate variance and covariance\n      let sigxy = 0.0;\n      let sigsqx = 0.0;\n      let sigsqy = 0.0;\n\n      for (let i = 0; i < lumaValues1.length; i++) {\n        sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;\n        sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;\n\n        sigxy +=\n          (lumaValues1[i] - averageLumaValue1) *\n          (lumaValues2[i] - averageLumaValue2);\n      }\n\n      const numPixelsInWin = lumaValues1.length - 1;\n      sigsqx /= numPixelsInWin;\n      sigsqy /= numPixelsInWin;\n      sigxy /= numPixelsInWin;\n\n      // perform ssim calculation on window\n      const numerator =\n        (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\n      const denominator =\n        (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) *\n        (sigsqx + sigsqy + c2);\n      const ssim = numerator / denominator;\n\n      mssim += ssim;\n      numWindows++;\n    },\n  );\n  return mssim / numWindows;\n}\n\nfunction iterate(\n  image1: PointContainer,\n  image2: PointContainer,\n  callback: (\n    lumaValues1: number[],\n    lumaValues2: number[],\n    averageLumaValue1: number,\n    averageLumaValue2: number,\n  ) => void,\n) {\n  const windowSize = 8;\n  const width = image1.getWidth();\n  const height = image1.getHeight();\n\n  for (let y = 0; y < height; y += windowSize) {\n    for (let x = 0; x < width; x += windowSize) {\n      // avoid out-of-width/height\n      const windowWidth = Math.min(windowSize, width - x);\n      const windowHeight = Math.min(windowSize, height - y);\n\n      const lumaValues1 = calculateLumaValuesForWindow(\n        image1,\n        x,\n        y,\n        windowWidth,\n        windowHeight,\n      );\n      const lumaValues2 = calculateLumaValuesForWindow(\n        image2,\n        x,\n        y,\n        windowWidth,\n        windowHeight,\n      );\n      const averageLuma1 = calculateAverageLuma(lumaValues1);\n      const averageLuma2 = calculateAverageLuma(lumaValues2);\n\n      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\n    }\n  }\n}\n\nfunction calculateLumaValuesForWindow(\n  image: PointContainer,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) {\n  const pointArray = image.getPointArray();\n  const lumaValues = [];\n\n  let counter = 0;\n\n  for (let j = y; j < y + height; j++) {\n    const offset = j * image.getWidth();\n    for (let i = x; i < x + width; i++) {\n      const point = pointArray[offset + i];\n      lumaValues[counter] =\n        point.r * Y.RED + point.g * Y.GREEN + point.b * Y.BLUE;\n      counter++;\n    }\n  }\n\n  return lumaValues;\n}\n\nfunction calculateAverageLuma(lumaValues: number[]) {\n  let sumLuma = 0.0;\n  for (const luma of lumaValues) {\n    sumLuma += luma;\n  }\n\n  return sumLuma / lumaValues.length;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * helper.ts - part of Image Quantization Library\n */\nimport * as distance from './distance';\nimport * as image from './image';\nimport * as palette from './palette';\nimport { AbstractDistanceCalculator } from './distance/distanceCalculator';\nimport { PointContainer } from './utils/pointContainer';\nimport { Palette } from './utils/palette';\n\nconst setImmediateImpl =\n  typeof setImmediate === 'function'\n    ? setImmediate\n    : typeof process !== 'undefined' && typeof process?.nextTick === 'function'\n    ? (callback: () => void) => process.nextTick(callback)\n    : (callback: () => void) => setTimeout(callback, 0);\n\nexport type ColorDistanceFormula =\n  | 'cie94-textiles'\n  | 'cie94-graphic-arts'\n  | 'ciede2000'\n  | 'color-metric'\n  | 'euclidean'\n  | 'euclidean-bt709-noalpha'\n  | 'euclidean-bt709'\n  | 'manhattan'\n  | 'manhattan-bt709'\n  | 'manhattan-nommyde'\n  | 'pngquant';\n\nexport type PaletteQuantization =\n  | 'neuquant'\n  | 'neuquant-float'\n  | 'rgbquant'\n  | 'wuquant';\n\nexport type ImageQuantization =\n  | 'nearest'\n  | 'riemersma'\n  | 'floyd-steinberg'\n  | 'false-floyd-steinberg'\n  | 'stucki'\n  | 'atkinson'\n  | 'jarvis'\n  | 'burkes'\n  | 'sierra'\n  | 'two-sierra'\n  | 'sierra-lite';\n\nexport interface ProgressOptions {\n  onProgress?: (progress: number) => void;\n}\n\nexport interface ApplyPaletteOptions {\n  colorDistanceFormula?: ColorDistanceFormula;\n  imageQuantization?: ImageQuantization;\n}\n\nexport interface BuildPaletteOptions {\n  colorDistanceFormula?: ColorDistanceFormula;\n  paletteQuantization?: PaletteQuantization;\n  colors?: number;\n}\n\nexport function buildPaletteSync(\n  images: PointContainer[],\n  {\n    colorDistanceFormula,\n    paletteQuantization,\n    colors,\n  }: BuildPaletteOptions = {},\n) {\n  const distanceCalculator =\n    colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(\n    distanceCalculator,\n    paletteQuantization,\n    colors,\n  );\n  images.forEach((image) => paletteQuantizer.sample(image));\n  return paletteQuantizer.quantizeSync();\n}\n\nexport async function buildPalette(\n  images: PointContainer[],\n  {\n    colorDistanceFormula,\n    paletteQuantization,\n    colors,\n    onProgress,\n  }: BuildPaletteOptions & ProgressOptions = {},\n) {\n  return new Promise<Palette>((resolve, reject) => {\n    const distanceCalculator =\n      colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(\n      distanceCalculator,\n      paletteQuantization,\n      colors,\n    );\n    images.forEach((image) => paletteQuantizer.sample(image));\n\n    let palette: Palette;\n    const iterator = paletteQuantizer.quantize();\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(palette);\n        } else {\n          if (result.value.palette) palette = result.value.palette;\n          if (onProgress) onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\n\nexport function applyPaletteSync(\n  image: PointContainer,\n  palette: Palette,\n  { colorDistanceFormula, imageQuantization }: ApplyPaletteOptions = {},\n) {\n  const distanceCalculator =\n    colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const imageQuantizer = imageQuantizationToImageQuantizer(\n    distanceCalculator,\n    imageQuantization,\n  );\n  return imageQuantizer.quantizeSync(image, palette);\n}\n\nexport async function applyPalette(\n  image: PointContainer,\n  palette: Palette,\n  {\n    colorDistanceFormula,\n    imageQuantization,\n    onProgress,\n  }: ApplyPaletteOptions & ProgressOptions = {},\n) {\n  return new Promise<PointContainer>((resolve, reject) => {\n    const distanceCalculator =\n      colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const imageQuantizer = imageQuantizationToImageQuantizer(\n      distanceCalculator,\n      imageQuantization,\n    );\n\n    let outPointContainer: PointContainer;\n    const iterator = imageQuantizer.quantize(image, palette);\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(outPointContainer);\n        } else {\n          if (result.value.pointContainer) {\n            outPointContainer = result.value.pointContainer;\n          }\n          if (onProgress) onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\n\nfunction colorDistanceFormulaToColorDistance(\n  colorDistanceFormula: ColorDistanceFormula = 'euclidean-bt709',\n) {\n  switch (colorDistanceFormula) {\n    case 'cie94-graphic-arts':\n      return new distance.CIE94GraphicArts();\n    case 'cie94-textiles':\n      return new distance.CIE94Textiles();\n    case 'ciede2000':\n      return new distance.CIEDE2000();\n    case 'color-metric':\n      return new distance.CMetric();\n    case 'euclidean':\n      return new distance.Euclidean();\n    case 'euclidean-bt709':\n      return new distance.EuclideanBT709();\n    case 'euclidean-bt709-noalpha':\n      return new distance.EuclideanBT709NoAlpha();\n    case 'manhattan':\n      return new distance.Manhattan();\n    case 'manhattan-bt709':\n      return new distance.ManhattanBT709();\n    case 'manhattan-nommyde':\n      return new distance.ManhattanNommyde();\n    case 'pngquant':\n      return new distance.PNGQuant();\n    default:\n      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);\n  }\n}\n\nfunction imageQuantizationToImageQuantizer(\n  distanceCalculator: AbstractDistanceCalculator,\n  imageQuantization: ImageQuantization = 'floyd-steinberg',\n) {\n  switch (imageQuantization) {\n    case 'nearest':\n      return new image.NearestColor(distanceCalculator);\n    case 'riemersma':\n      return new image.ErrorDiffusionRiemersma(distanceCalculator);\n    case 'floyd-steinberg':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.FloydSteinberg,\n      );\n    case 'false-floyd-steinberg':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.FalseFloydSteinberg,\n      );\n    case 'stucki':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Stucki,\n      );\n    case 'atkinson':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Atkinson,\n      );\n    case 'jarvis':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Jarvis,\n      );\n    case 'burkes':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Burkes,\n      );\n    case 'sierra':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Sierra,\n      );\n    case 'two-sierra':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.TwoSierra,\n      );\n    case 'sierra-lite':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.SierraLite,\n      );\n    default:\n      throw new Error(`Unknown imageQuantization ${imageQuantization}`);\n  }\n}\n\nfunction paletteQuantizationToPaletteQuantizer(\n  distanceCalculator: AbstractDistanceCalculator,\n  paletteQuantization: PaletteQuantization = 'wuquant',\n  colors = 256,\n) {\n  switch (paletteQuantization) {\n    case 'neuquant':\n      return new palette.NeuQuant(distanceCalculator, colors);\n    case 'rgbquant':\n      return new palette.RGBQuant(distanceCalculator, colors);\n    case 'wuquant':\n      return new palette.WuQuant(distanceCalculator, colors);\n    case 'neuquant-float':\n      return new palette.NeuQuantFloat(distanceCalculator, colors);\n    default:\n      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]}},
    {"offset": {"line": 3082, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3088, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/constants/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/constants/bt709.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/rgb2xyz.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/arithmetic.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/rgb2hsl.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/xyz2lab.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/rgb2lab.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/lab2xyz.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/xyz2rgb.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/conversion/lab2rgb.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/distanceCalculator.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/cie94.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/ciede2000.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/cmetric.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/euclidean.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/manhattan.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/distance/pngQuant.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/paletteQuantizer.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/point.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/pointContainer.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/palette.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/hueStatistics.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/utils/progressTracker.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/neuquant/neuquant.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/neuquant/neuquantFloat.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/rgbquant/colorHistogram.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/rgbquant/rgbquant.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/palette/wu/wuQuant.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/imageQuantizer.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/nearestColor.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/array.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/spaceFillingCurves/hilbertCurve.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/image/riemersma.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/quality/index.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/quality/ssim.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/basicAPI.ts","file:///workspaces/Water-Quality-Analyzer/node_modules/image-q/src/index.ts"],"sourcesContent":["/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\nimport * as bt709 from './bt709';\n\nexport { bt709 };\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\n\n/**\n * sRGB (based on ITU-R Recommendation BT.709)\n * http://en.wikipedia.org/wiki/SRGB\n */\nexport enum Y {\n  RED = 0.2126,\n  GREEN = 0.7152,\n  BLUE = 0.0722,\n  WHITE = 1,\n}\n\nexport enum x {\n  RED = 0.64,\n  GREEN = 0.3,\n  BLUE = 0.15,\n  WHITE = 0.3127,\n}\n\nexport enum y {\n  RED = 0.33,\n  GREEN = 0.6,\n  BLUE = 0.06,\n  WHITE = 0.329,\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { rgb2xyz } from './rgb2xyz';\nexport { rgb2hsl } from './rgb2hsl';\nexport { rgb2lab } from './rgb2lab';\nexport { lab2xyz } from './lab2xyz';\nexport { lab2rgb } from './lab2rgb';\nexport { xyz2lab } from './xyz2lab';\nexport { xyz2rgb } from './xyz2rgb';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2xyz.ts - part of Image Quantization Library\n */\nfunction correctGamma(n: number) {\n  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;\n}\n\nexport function rgb2xyz(r: number, g: number, b: number) {\n  // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\n  r = correctGamma(r / 255);\n  g = correctGamma(g / 255);\n  b = correctGamma(b / 255);\n\n  // Observer. = 2°, Illuminant = D65\n  return {\n    x: r * 0.4124 + g * 0.3576 + b * 0.1805,\n    y: r * 0.2126 + g * 0.7152 + b * 0.0722,\n    z: r * 0.0193 + g * 0.1192 + b * 0.9505,\n  };\n}\n","export function degrees2radians(n: number) {\n  return n * (Math.PI / 180);\n}\n\nexport function max3(a: number, b: number, c: number) {\n  let m = a;\n  if (m < b) m = b;\n  if (m < c) m = c;\n  return m;\n}\n\nexport function min3(a: number, b: number, c: number) {\n  let m = a;\n  if (m > b) m = b;\n  if (m > c) m = c;\n  return m;\n}\n\nexport function intInRange(value: number, low: number, high: number) {\n  if (value > high) value = high;\n  if (value < low) value = low;\n  return value | 0;\n}\n\nexport function inRange0to255Rounded(n: number) {\n  n = Math.round(n);\n  if (n > 255) n = 255;\n  else if (n < 0) n = 0;\n  return n;\n}\n\nexport function inRange0to255(n: number) {\n  if (n > 255) n = 255;\n  else if (n < 0) n = 0;\n  return n;\n}\n\nexport function stableSort<T>(\n  arrayToSort: T[],\n  callback: (a: T, b: T) => number,\n) {\n  const type = typeof arrayToSort[0];\n  let sorted: T[];\n\n  if (type === 'number' || type === 'string') {\n    const ord = Object.create(null);\n    for (let i = 0, l = arrayToSort.length; i < l; i++) {\n      const val = arrayToSort[i] as unknown as string;\n      if (ord[val] || ord[val] === 0) continue;\n      ord[val] = i;\n    }\n\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);\n  } else {\n    const ord2 = arrayToSort.slice(0);\n    sorted = arrayToSort.sort(\n      (a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b),\n    );\n  }\n\n  return sorted;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2hsl.ts - part of Image Quantization Library\n */\nimport { min3, max3 } from '../utils/arithmetic';\n\n/**\n * Calculate HSL from RGB\n * Hue is in degrees [0..360]\n * Lightness: [0..1]\n * Saturation: [0..1]\n * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/\n */\nexport function rgb2hsl(r: number, g: number, b: number) {\n  const min = min3(r, g, b);\n  const max = max3(r, g, b);\n  const delta = max - min;\n  const l = (min + max) / 510;\n\n  let s = 0;\n  if (l > 0 && l < 1) s = delta / (l < 0.5 ? max + min : 510 - max - min);\n\n  let h = 0;\n  if (delta > 0) {\n    if (max === r) {\n      h = (g - b) / delta;\n    } else if (max === g) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n\n    h *= 60;\n    if (h < 0) h += 360;\n  }\n  return { h, s, l };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2lab.ts - part of Image Quantization Library\n */\nconst refX = 0.95047; // ref_X =  95.047   Observer= 2°, Illuminant= D65\nconst refY = 1.0; // ref_Y = 100.000\nconst refZ = 1.08883; // ref_Z = 108.883\n\nfunction pivot(n: number) {\n  return n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116;\n}\n\nexport function xyz2lab(x: number, y: number, z: number) {\n  x = pivot(x / refX);\n  y = pivot(y / refY);\n  z = pivot(z / refZ);\n\n  if (116 * y - 16 < 0) throw new Error('xxx');\n  return {\n    L: Math.max(0, 116 * y - 16),\n    a: 500 * (x - y),\n    b: 200 * (y - z),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2lab.ts - part of Image Quantization Library\n */\nimport { rgb2xyz } from './rgb2xyz';\nimport { xyz2lab } from './xyz2lab';\n\nexport function rgb2lab(r: number, g: number, b: number) {\n  const xyz = rgb2xyz(r, g, b);\n  return xyz2lab(xyz.x, xyz.y, xyz.z);\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2xyz.ts - part of Image Quantization Library\n */\nconst refX = 0.95047; // ref_X =  95.047   Observer= 2°, Illuminant = D65\nconst refY = 1.0; // ref_Y = 100.000\nconst refZ = 1.08883; // ref_Z = 108.883\n\nfunction pivot(n: number) {\n  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;\n}\n\nexport function lab2xyz(L: number, a: number, b: number) {\n  const y = (L + 16) / 116;\n  const x = a / 500 + y;\n  const z = y - b / 200;\n\n  return {\n    x: refX * pivot(x),\n    y: refY * pivot(y),\n    z: refZ * pivot(z),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2rgb.ts - part of Image Quantization Library\n */\nimport { inRange0to255Rounded } from '../utils/arithmetic';\n\n// gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\nfunction correctGamma(n: number) {\n  return n > 0.0031308 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;\n}\n\nexport function xyz2rgb(x: number, y: number, z: number) {\n  // Observer. = 2°, Illuminant = D65\n  const r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986);\n  const g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415);\n  const b = correctGamma(x * 0.0557 + y * -0.204 + z * 1.057);\n\n  return {\n    r: inRange0to255Rounded(r * 255),\n    g: inRange0to255Rounded(g * 255),\n    b: inRange0to255Rounded(b * 255),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2rgb.ts - part of Image Quantization Library\n */\nimport { lab2xyz } from './lab2xyz';\nimport { xyz2rgb } from './xyz2rgb';\n\nexport function lab2rgb(L: number, a: number, b: number) {\n  const xyz = lab2xyz(L, a, b);\n  return xyz2rgb(xyz.x, xyz.y, xyz.z);\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { AbstractDistanceCalculator } from './distanceCalculator';\nexport { CIE94Textiles, CIE94GraphicArts } from './cie94';\nexport { CIEDE2000 } from './ciede2000';\nexport { CMetric } from './cmetric';\nexport {\n  AbstractEuclidean,\n  Euclidean,\n  EuclideanBT709NoAlpha,\n  EuclideanBT709,\n} from './euclidean';\nexport {\n  AbstractManhattan,\n  Manhattan,\n  ManhattanBT709,\n  ManhattanNommyde,\n} from './manhattan';\nexport { PNGQuant } from './pngQuant';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointRGBA } from '../utils/point';\n\nexport abstract class AbstractDistanceCalculator {\n  protected _maxDistance!: number;\n  protected _whitePoint!: {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n  };\n\n  constructor() {\n    this._setDefaults();\n\n    // set default maximal color component deltas (255 - 0 = 255)\n    this.setWhitePoint(255, 255, 255, 255);\n  }\n\n  setWhitePoint(r: number, g: number, b: number, a: number) {\n    this._whitePoint = {\n      r: r > 0 ? 255 / r : 0,\n      g: g > 0 ? 255 / g : 0,\n      b: b > 0 ? 255 / b : 0,\n      a: a > 0 ? 255 / a : 0,\n    };\n    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\n  }\n\n  calculateNormalized(colorA: PointRGBA, colorB: PointRGBA) {\n    return (\n      this.calculateRaw(\n        colorA.r,\n        colorA.g,\n        colorA.b,\n        colorA.a,\n        colorB.r,\n        colorB.g,\n        colorB.b,\n        colorB.a,\n      ) / this._maxDistance\n    );\n  }\n\n  /**\n   * Calculate raw distance (non-normalized)\n   */\n  abstract calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ): number;\n\n  protected abstract _setDefaults(): void;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cie94.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { rgb2lab } from '../conversion/rgb2lab';\nimport { inRange0to255 } from '../utils/arithmetic';\n\n/**\n * CIE94 method of delta-e\n * http://en.wikipedia.org/wiki/Color_difference#CIE94\n */\nexport abstract class AbstractCIE94 extends AbstractDistanceCalculator {\n  /**\n   * Weight in distance: 0.25\n   * Max DeltaE: 100\n   * Max DeltaA: 255\n   */\n  declare protected _kA: number;\n  declare protected _Kl: number;\n  declare protected _K1: number;\n  declare protected _K2: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const lab1 = rgb2lab(\n      inRange0to255(r1 * this._whitePoint.r),\n      inRange0to255(g1 * this._whitePoint.g),\n      inRange0to255(b1 * this._whitePoint.b),\n    );\n    const lab2 = rgb2lab(\n      inRange0to255(r2 * this._whitePoint.r),\n      inRange0to255(g2 * this._whitePoint.g),\n      inRange0to255(b2 * this._whitePoint.b),\n    );\n\n    const dL = lab1.L - lab2.L;\n    const dA = lab1.a - lab2.a;\n    const dB = lab1.b - lab2.b;\n    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);\n    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);\n    const dC = c1 - c2;\n\n    let deltaH = dA * dA + dB * dB - dC * dC;\n    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n\n    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\n\n    // TODO: add alpha channel support\n    return Math.sqrt(\n      (dL / this._Kl) ** 2 +\n        (dC / (1.0 + this._K1 * c1)) ** 2 +\n        (deltaH / (1.0 + this._K2 * c1)) ** 2 +\n        dAlpha ** 2,\n    );\n  }\n}\n\nexport class CIE94Textiles extends AbstractCIE94 {\n  protected _setDefaults() {\n    this._Kl = 2.0;\n    this._K1 = 0.048;\n    this._K2 = 0.014;\n    this._kA = (0.25 * 50) / 255;\n  }\n}\n\nexport class CIE94GraphicArts extends AbstractCIE94 {\n  protected _setDefaults() {\n    this._Kl = 1.0;\n    this._K1 = 0.045;\n    this._K2 = 0.015;\n    this._kA = (0.25 * 100) / 255;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ciede2000.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { rgb2lab } from '../conversion/rgb2lab';\nimport { degrees2radians, inRange0to255 } from '../utils/arithmetic';\n\n/**\n * CIEDE2000 algorithm - Adapted from Sharma et al's MATLAB implementation at\n * http://www.ece.rochester.edu/~gsharma/ciede2000/\n */\nexport class CIEDE2000 extends AbstractDistanceCalculator {\n  /**\n   * Weight in distance: 0.25\n   * Max DeltaE: 100\n   * Max DeltaA: 255\n   */\n  private static readonly _kA = (0.25 * 100) / 255;\n  private static readonly _pow25to7 = 25 ** 7;\n  private static readonly _deg360InRad = degrees2radians(360);\n  private static readonly _deg180InRad = degrees2radians(180);\n  private static readonly _deg30InRad = degrees2radians(30);\n  private static readonly _deg6InRad = degrees2radians(6);\n  private static readonly _deg63InRad = degrees2radians(63);\n  private static readonly _deg275InRad = degrees2radians(275);\n  private static readonly _deg25InRad = degrees2radians(25);\n\n  protected _setDefaults() {}\n\n  private static _calculatehp(b: number, ap: number) {\n    const hp = Math.atan2(b, ap);\n    if (hp >= 0) return hp;\n    return hp + CIEDE2000._deg360InRad;\n  }\n\n  private static _calculateRT(ahp: number, aCp: number) {\n    const aCp_to_7 = aCp ** 7.0;\n    const R_C = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)); // 25^7\n    const delta_theta =\n      CIEDE2000._deg30InRad *\n      Math.exp(\n        -(((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad) ** 2.0),\n      );\n    return -Math.sin(2.0 * delta_theta) * R_C;\n  }\n\n  private static _calculateT(ahp: number) {\n    return (\n      1.0 -\n      0.17 * Math.cos(ahp - CIEDE2000._deg30InRad) +\n      0.24 * Math.cos(ahp * 2.0) +\n      0.32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) -\n      0.2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad)\n    );\n  }\n\n  private static _calculate_ahp(\n    C1pC2p: number,\n    h_bar: number,\n    h1p: number,\n    h2p: number,\n  ) {\n    const hpSum = h1p + h2p;\n    if (C1pC2p === 0) return hpSum;\n    if (h_bar <= CIEDE2000._deg180InRad) return hpSum / 2.0;\n    if (hpSum < CIEDE2000._deg360InRad) {\n      return (hpSum + CIEDE2000._deg360InRad) / 2.0;\n    }\n    return (hpSum - CIEDE2000._deg360InRad) / 2.0;\n  }\n\n  private static _calculate_dHp(\n    C1pC2p: number,\n    h_bar: number,\n    h2p: number,\n    h1p: number,\n  ) {\n    let dhp;\n    if (C1pC2p === 0) {\n      dhp = 0;\n    } else if (h_bar <= CIEDE2000._deg180InRad) {\n      dhp = h2p - h1p;\n    } else if (h2p <= h1p) {\n      dhp = h2p - h1p + CIEDE2000._deg360InRad;\n    } else {\n      dhp = h2p - h1p - CIEDE2000._deg360InRad;\n    }\n    return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);\n  }\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const lab1 = rgb2lab(\n      inRange0to255(r1 * this._whitePoint.r),\n      inRange0to255(g1 * this._whitePoint.g),\n      inRange0to255(b1 * this._whitePoint.b),\n    );\n    const lab2 = rgb2lab(\n      inRange0to255(r2 * this._whitePoint.r),\n      inRange0to255(g2 * this._whitePoint.g),\n      inRange0to255(b2 * this._whitePoint.b),\n    );\n    const dA = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA;\n    const dE2 = this.calculateRawInLab(lab1, lab2);\n\n    return Math.sqrt(dE2 + dA * dA);\n  }\n\n  calculateRawInLab(\n    Lab1: { L: number; a: number; b: number },\n    Lab2: { L: number; a: number; b: number },\n  ) {\n    // Get L,a,b values for color 1\n    const L1 = Lab1.L;\n    const a1 = Lab1.a;\n    const b1 = Lab1.b;\n\n    // Get L,a,b values for color 2\n    const L2 = Lab2.L;\n    const a2 = Lab2.a;\n    const b2 = Lab2.b;\n\n    // Calculate Cprime1, Cprime2, Cabbar\n    const C1 = Math.sqrt(a1 * a1 + b1 * b1);\n    const C2 = Math.sqrt(a2 * a2 + b2 * b2);\n    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2.0) ** 7.0;\n\n    const G =\n      0.5 *\n      (1.0 -\n        Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))); // 25^7\n    const a1p = (1.0 + G) * a1;\n    const a2p = (1.0 + G) * a2;\n\n    const C1p = Math.sqrt(a1p * a1p + b1 * b1);\n    const C2p = Math.sqrt(a2p * a2p + b2 * b2);\n    const C1pC2p = C1p * C2p;\n\n    // Angles in Degree.\n    const h1p = CIEDE2000._calculatehp(b1, a1p);\n    const h2p = CIEDE2000._calculatehp(b2, a2p);\n    const h_bar = Math.abs(h1p - h2p);\n    const dLp = L2 - L1;\n    const dCp = C2p - C1p;\n    const dHp = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);\n    const ahp = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);\n\n    const T = CIEDE2000._calculateT(ahp);\n\n    const aCp = (C1p + C2p) / 2.0;\n    const aLp_minus_50_square = ((L1 + L2) / 2.0 - 50.0) ** 2.0;\n    const S_L =\n      1.0 +\n      (0.015 * aLp_minus_50_square) / Math.sqrt(20.0 + aLp_minus_50_square);\n    const S_C = 1.0 + 0.045 * aCp;\n    const S_H = 1.0 + 0.015 * T * aCp;\n\n    const R_T = CIEDE2000._calculateRT(ahp, aCp);\n\n    const dLpSL = dLp / S_L; // S_L * kL, where kL is 1.0\n    const dCpSC = dCp / S_C; // S_C * kC, where kC is 1.0\n    const dHpSH = dHp / S_H; // S_H * kH, where kH is 1.0\n\n    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cmetric.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\n\n/**\n * TODO: Name it: http://www.compuphase.com/cmetric.htm\n */\nexport class CMetric extends AbstractDistanceCalculator {\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const rmean = ((r1 + r2) / 2) * this._whitePoint.r;\n    const r = (r1 - r2) * this._whitePoint.r;\n    const g = (g1 - g2) * this._whitePoint.g;\n    const b = (b1 - b2) * this._whitePoint.b;\n    const dE =\n      (((512 + rmean) * r * r) >> 8) +\n      4 * g * g +\n      (((767 - rmean) * b * b) >> 8);\n    const dA = (a2 - a1) * this._whitePoint.a;\n\n    return Math.sqrt(dE + dA * dA);\n  }\n\n  protected _setDefaults() {}\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * euclidean.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { Y } from '../constants/bt709';\n\n/**\n * Euclidean color distance\n */\nexport abstract class AbstractEuclidean extends AbstractDistanceCalculator {\n  declare protected _kR: number;\n  declare protected _kG: number;\n  declare protected _kB: number;\n  declare protected _kA: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const dR = r2 - r1;\n    const dG = g2 - g1;\n    const dB = b2 - b1;\n    const dA = a2 - a1;\n    return Math.sqrt(\n      this._kR * dR * dR +\n        this._kG * dG * dG +\n        this._kB * dB * dB +\n        this._kA * dA * dA,\n    );\n  }\n}\n\nexport class Euclidean extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n}\n\n/**\n * Euclidean color distance (RGBQuant modification w Alpha)\n */\nexport class EuclideanBT709 extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n\n/**\n * Euclidean color distance (RGBQuant modification w/o Alpha)\n */\nexport class EuclideanBT709NoAlpha extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    this._kA = 0;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * manhattanNeuQuant.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { Y } from '../constants/bt709';\n\n/**\n * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients\n */\nexport abstract class AbstractManhattan extends AbstractDistanceCalculator {\n  declare protected _kR: number;\n  declare  protected _kG: number;\n  declare protected _kB: number;\n  declare protected _kA: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    let dR = r2 - r1;\n    let dG = g2 - g1;\n    let dB = b2 - b1;\n    let dA = a2 - a1;\n    if (dR < 0) dR = 0 - dR;\n    if (dG < 0) dG = 0 - dG;\n    if (dB < 0) dB = 0 - dB;\n    if (dA < 0) dA = 0 - dA;\n\n    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\n  }\n}\n\nexport class Manhattan extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n}\n\n/**\n * Manhattan distance (Nommyde modification)\n * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320\n */\nexport class ManhattanNommyde extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = 0.4984;\n    this._kG = 0.8625;\n    this._kB = 0.2979;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n\n/**\n * Manhattan distance (sRGB coefficients)\n */\nexport class ManhattanBT709 extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pngQuant.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\n\n/**\n * TODO: check quality of this distance equation\n * TODO: ask author for usage rights\n * taken from:\n * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}\n * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}\n */\nexport class PNGQuant extends AbstractDistanceCalculator {\n  /**\n   * Author's comments\n   * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black\n   * px_b.a   = px.a   + 1*(1-px.a)\n   * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white\n   * px_w.a   = px.a   + 1*(1-px.a)\n   *\n   * px_b.rgb = px.rgb              // difference same as in opaque RGB\n   * px_b.a   = 1\n   * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below\n   * px_w.a   = 1\n   *\n   * (px.rgb - px.a) - (py.rgb - py.a)\n   * (px.rgb - py.rgb) + (py.a - px.a)\n   *\n   */\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const alphas = (a2 - a1) * this._whitePoint.a;\n    return (\n      this._colordifferenceCh(\n        r1 * this._whitePoint.r,\n        r2 * this._whitePoint.r,\n        alphas,\n      ) +\n      this._colordifferenceCh(\n        g1 * this._whitePoint.g,\n        g2 * this._whitePoint.g,\n        alphas,\n      ) +\n      this._colordifferenceCh(\n        b1 * this._whitePoint.b,\n        b2 * this._whitePoint.b,\n        alphas,\n      )\n    );\n  }\n\n  private _colordifferenceCh(x: number, y: number, alphas: number) {\n    // maximum of channel blended on white, and blended on black\n    // premultiplied alpha and backgrounds 0/1 shorten the formula\n    const black = x - y;\n    const white = black + alphas;\n\n    return black * black + white * white;\n  }\n\n  protected _setDefaults() {}\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { AbstractPaletteQuantizer } from './paletteQuantizer';\nexport { NeuQuant } from './neuquant/neuquant';\nexport { NeuQuantFloat } from './neuquant/neuquantFloat';\nexport { RGBQuant } from './rgbquant/rgbquant';\nexport { ColorHistogram } from './rgbquant/colorHistogram';\nexport { WuQuant, WuColorCube } from './wu/wuQuant';\nexport { PaletteQuantizerYieldValue } from './paletteQuantizerYieldValue';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { PaletteQuantizerYieldValue } from './paletteQuantizerYieldValue';\n\nexport abstract class AbstractPaletteQuantizer {\n  abstract sample(pointContainer: PointContainer): void;\n  abstract quantize(): IterableIterator<PaletteQuantizerYieldValue>;\n\n  quantizeSync() {\n    for (const value of this.quantize()) {\n      if (value.palette) {\n        return value.palette;\n      }\n    }\n\n    throw new Error('unreachable');\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * point.ts - part of Image Quantization Library\n */\nimport { Y } from '../constants/bt709';\n\nexport interface PointRGBA {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\n/**\n * v8 optimized class\n * 1) \"constructor\" should have initialization with worst types\n * 2) \"set\" should have |0 / >>> 0\n */\nexport class Point implements PointRGBA {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n  uint32: number;\n  rgba: number[]; // TODO: better name is quadruplet or quad may be?\n  // Lab : { L : number; a : number; b : number };\n\n  static createByQuadruplet(quadruplet: number[]) {\n    const point = new Point();\n\n    point.r = quadruplet[0] | 0;\n    point.g = quadruplet[1] | 0;\n    point.b = quadruplet[2] | 0;\n    point.a = quadruplet[3] | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  static createByRGBA(red: number, green: number, blue: number, alpha: number) {\n    const point = new Point();\n\n    point.r = red | 0;\n    point.g = green | 0;\n    point.b = blue | 0;\n    point.a = alpha | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  static createByUint32(uint32: number) {\n    const point = new Point();\n\n    point.uint32 = uint32 >>> 0;\n    point._loadRGBA();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  constructor() {\n    this.uint32 = -1 >>> 0;\n    this.r = this.g = this.b = this.a = 0;\n    this.rgba = new Array(4);\n    this.rgba[0] = 0;\n    this.rgba[1] = 0;\n    this.rgba[2] = 0;\n    this.rgba[3] = 0;\n    /*\n     this.Lab = {\n     L : 0.0,\n     a : 0.0,\n     b : 0.0\n     };\n     */\n  }\n\n  from(point: Point) {\n    this.r = point.r;\n    this.g = point.g;\n    this.b = point.b;\n    this.a = point.a;\n    this.uint32 = point.uint32;\n    this.rgba[0] = point.r;\n    this.rgba[1] = point.g;\n    this.rgba[2] = point.b;\n    this.rgba[3] = point.a;\n\n    /*\n     this.Lab.L = point.Lab.L;\n     this.Lab.a = point.Lab.a;\n     this.Lab.b = point.Lab.b;\n     */\n  }\n\n  /*\n   * TODO:\n   Luminance from RGB:\n\n   Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]\n   Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]\n   Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]\n   */\n  getLuminosity(useAlphaChannel: boolean) {\n    let r = this.r;\n    let g = this.g;\n    let b = this.b;\n\n    if (useAlphaChannel) {\n      r = Math.min(255, 255 - this.a + (this.a * r) / 255);\n      g = Math.min(255, 255 - this.a + (this.a * g) / 255);\n      b = Math.min(255, 255 - this.a + (this.a * b) / 255);\n    }\n\n    // var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;\n\n    /*\n     if(useAlphaChannel) {\n     luma = (luma * (255 - this.a)) / 255;\n     }\n     */\n\n    return r * Y.RED + g * Y.GREEN + b * Y.BLUE;\n  }\n\n  private _loadUINT32() {\n    this.uint32 =\n      ((this.a << 24) | (this.b << 16) | (this.g << 8) | this.r) >>> 0;\n  }\n\n  private _loadRGBA() {\n    this.r = this.uint32 & 0xff;\n    this.g = (this.uint32 >>> 8) & 0xff;\n    this.b = (this.uint32 >>> 16) & 0xff;\n    this.a = (this.uint32 >>> 24) & 0xff;\n  }\n\n  private _loadQuadruplet() {\n    this.rgba[0] = this.r;\n    this.rgba[1] = this.g;\n    this.rgba[2] = this.b;\n    this.rgba[3] = this.a;\n\n    /*\n     var xyz = rgb2xyz(this.r, this.g, this.b);\n     var lab = xyz2lab(xyz.x, xyz.y, xyz.z);\n     this.lab.l = lab.l;\n     this.lab.a = lab.a;\n     this.lab.b = lab.b;\n     */\n  }\n\n  /*\n   private _loadLab() : void {\n   var Lab = Color.Conversion.rgb2lab(this.r, this.g, this.b);\n   this.Lab.L = Lab.L;\n   this.Lab.a = Lab.a;\n   this.Lab.b = Lab.b;\n   }\n   */\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pointContainer.ts - part of Image Quantization Library\n */\nimport { Point } from './point';\n\n/**\n * v8 optimizations done.\n * fromXXX methods are static to move out polymorphic code from class instance itself.\n */\nexport class PointContainer {\n  private readonly _pointArray: Point[];\n  private _width: number;\n  private _height: number;\n\n  constructor() {\n    this._width = 0;\n    this._height = 0;\n    this._pointArray = [];\n  }\n\n  getWidth() {\n    return this._width;\n  }\n\n  getHeight() {\n    return this._height;\n  }\n\n  setWidth(width: number) {\n    this._width = width;\n  }\n\n  setHeight(height: number) {\n    this._height = height;\n  }\n\n  getPointArray() {\n    return this._pointArray;\n  }\n\n  clone() {\n    const clone = new PointContainer();\n    clone._width = this._width;\n    clone._height = this._height;\n\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      clone._pointArray[i] = Point.createByUint32(\n        this._pointArray[i].uint32 | 0,\n      ); // \"| 0\" is added for v8 optimization\n    }\n\n    return clone;\n  }\n\n  toUint32Array() {\n    const l = this._pointArray.length;\n    const uint32Array = new Uint32Array(l);\n\n    for (let i = 0; i < l; i++) {\n      uint32Array[i] = this._pointArray[i].uint32;\n    }\n\n    return uint32Array;\n  }\n\n  toUint8Array() {\n    return new Uint8Array(this.toUint32Array().buffer);\n  }\n\n  static fromHTMLImageElement(img: HTMLImageElement) {\n    const width = img.naturalWidth;\n    const height = img.naturalHeight;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const ctx = canvas.getContext('2d')!;\n    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\n\n    return PointContainer.fromHTMLCanvasElement(canvas);\n  }\n\n  static fromHTMLCanvasElement(canvas: HTMLCanvasElement) {\n    const width = canvas.width;\n    const height = canvas.height;\n\n    const ctx = canvas.getContext('2d')!;\n    const imgData = ctx.getImageData(0, 0, width, height);\n\n    return PointContainer.fromImageData(imgData);\n  }\n\n  static fromImageData(imageData: ImageData) {\n    const width = imageData.width;\n    const height = imageData.height;\n\n    return PointContainer.fromUint8Array(imageData.data, width, height);\n  }\n\n  static fromUint8Array(\n    uint8Array: number[] | Uint8Array | Uint8ClampedArray,\n    width: number,\n    height: number,\n  ) {\n    switch (Object.prototype.toString.call(uint8Array)) {\n      case '[object Uint8ClampedArray]':\n      case '[object Uint8Array]':\n        break;\n\n      default:\n        uint8Array = new Uint8Array(uint8Array);\n    }\n\n    const uint32Array = new Uint32Array((uint8Array as Uint8Array).buffer);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n\n  static fromUint32Array(\n    uint32Array: Uint32Array,\n    width: number,\n    height: number,\n  ) {\n    const container = new PointContainer();\n\n    container._width = width;\n    container._height = height;\n\n    for (let i = 0, l = uint32Array.length; i < l; i++) {\n      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0); // \"| 0\" is added for v8 optimization\n    }\n\n    return container;\n  }\n\n  static fromBuffer(buffer: Buffer, width: number, height: number) {\n    const uint32Array = new Uint32Array(\n      buffer.buffer,\n      buffer.byteOffset,\n      buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT,\n    );\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * palette.ts - part of Image Quantization Library\n */\n\nimport { Point } from './point';\nimport { PointContainer } from './pointContainer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { rgb2hsl } from '../conversion/rgb2hsl';\n\n// TODO: make paletteArray via pointContainer, so, export will be available via pointContainer.exportXXX\n\nconst hueGroups = 10;\n\nexport function hueGroup(hue: number, segmentsNumber: number) {\n  const maxHue = 360;\n  const seg = maxHue / segmentsNumber;\n  const half = seg / 2;\n\n  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\n    if (hue >= mid && hue < mid + seg) return i;\n  }\n  return 0;\n}\n\nexport class Palette {\n  private readonly _pointContainer: PointContainer;\n  private readonly _pointArray: Point[] = [];\n  private _i32idx: { [key: string]: number } = {};\n\n  constructor() {\n    this._pointContainer = new PointContainer();\n    this._pointContainer.setHeight(1);\n    this._pointArray = this._pointContainer.getPointArray();\n  }\n\n  add(color: Point) {\n    this._pointArray.push(color);\n    this._pointContainer.setWidth(this._pointArray.length);\n  }\n\n  has(color: Point) {\n    for (let i = this._pointArray.length - 1; i >= 0; i--) {\n      if (color.uint32 === this._pointArray[i].uint32) return true;\n    }\n\n    return false;\n  }\n\n  // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\n  getNearestColor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    color: Point,\n  ) {\n    return this._pointArray[\n      this._getNearestIndex(colorDistanceCalculator, color) | 0\n    ];\n  }\n\n  getPointContainer() {\n    return this._pointContainer;\n  }\n\n  // TOTRY: use HUSL - http://boronine.com/husl/\n  /*\n   public nearestIndexByUint32(i32) {\n   var idx : number = this._nearestPointFromCache(\"\" + i32);\n   if (idx >= 0) return idx;\n\n   var min = 1000,\n   rgb = [\n   (i32 & 0xff),\n   (i32 >>> 8) & 0xff,\n   (i32 >>> 16) & 0xff,\n   (i32 >>> 24) & 0xff\n   ],\n   len = this._pointArray.length;\n\n   idx = 0;\n   for (var i = 0; i < len; i++) {\n   var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\n\n   if (dist < min) {\n   min = dist;\n   idx = i;\n   }\n   }\n\n   this._i32idx[i32] = idx;\n   return idx;\n   }\n   */\n\n  private _nearestPointFromCache(key: string) {\n    return typeof this._i32idx[key] === 'number' ? this._i32idx[key] : -1;\n  }\n\n  private _getNearestIndex(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    point: Point,\n  ) {\n    let idx = this._nearestPointFromCache('' + point.uint32);\n    if (idx >= 0) return idx;\n\n    let minimalDistance = Number.MAX_VALUE;\n\n    idx = 0;\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      const p = this._pointArray[i];\n      const distance = colorDistanceCalculator.calculateRaw(\n        point.r,\n        point.g,\n        point.b,\n        point.a,\n        p.r,\n        p.g,\n        p.b,\n        p.a,\n      );\n\n      if (distance < minimalDistance) {\n        minimalDistance = distance;\n        idx = i;\n      }\n    }\n\n    this._i32idx[point.uint32] = idx;\n    return idx;\n  }\n\n  /*\n   public reduce(histogram : ColorHistogram, colors : number) {\n   if (this._pointArray.length > colors) {\n   var idxi32 = histogram.getImportanceSortedColorsIDXI32();\n\n   // quantize histogram to existing palette\n   var keep = [], uniqueColors = 0, idx, pruned = false;\n\n   for (var i = 0, len = idxi32.length; i < len; i++) {\n   // palette length reached, unset all remaining colors (sparse palette)\n   if (uniqueColors >= colors) {\n   this.prunePal(keep);\n   pruned = true;\n   break;\n   } else {\n   idx = this.nearestIndexByUint32(idxi32[i]);\n   if (keep.indexOf(idx) < 0) {\n   keep.push(idx);\n   uniqueColors++;\n   }\n   }\n   }\n\n   if (!pruned) {\n   this.prunePal(keep);\n   }\n   }\n   }\n\n   // TODO: check usage, not tested!\n   public prunePal(keep : number[]) {\n   var colors = this._pointArray.length;\n   for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n   if (keep.indexOf(colorIndex) < 0) {\n\n   if(colorIndex + 1 < colors) {\n   this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\n   }\n   --colors;\n   //this._pointArray[colorIndex] = null;\n   }\n   }\n   console.log(\"colors pruned: \" + (this._pointArray.length - colors));\n   this._pointArray.length = colors;\n   this._i32idx = {};\n   }\n   */\n\n  // TODO: group very low lum and very high lum colors\n  // TODO: pass custom sort order\n  // TODO: sort criteria function should be placed to HueStats class\n  sort() {\n    this._i32idx = {};\n    this._pointArray.sort((a: Point, b: Point) => {\n      const hslA = rgb2hsl(a.r, a.g, a.b);\n      const hslB = rgb2hsl(b.r, b.g, b.b);\n\n      // sort all grays + whites together\n      const hueA =\n        a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);\n      const hueB =\n        b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);\n      /*\n       var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\n       var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\n       */\n\n      const hueDiff = hueB - hueA;\n      if (hueDiff) return -hueDiff;\n\n      /*\n       var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\n       if (lumDiff) return -lumDiff;\n       */\n      const lA = a.getLuminosity(true);\n      const lB = b.getLuminosity(true);\n\n      if (lB - lA !== 0) return lB - lA;\n\n      const satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);\n      if (satDiff) return -satDiff;\n\n      return 0;\n    });\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nimport * as arithmetic from './arithmetic';\nimport { HueStatistics } from './hueStatistics';\nimport { Palette } from './palette';\nimport { Point } from './point';\nimport { PointContainer } from './pointContainer';\nimport { ProgressTracker } from './progressTracker';\n\nexport {\n  Point,\n  PointContainer,\n  Palette,\n  HueStatistics,\n  ProgressTracker,\n  arithmetic,\n};\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * hueStatistics.ts - part of Image Quantization Library\n */\nimport { rgb2hsl } from '../conversion/rgb2hsl';\nimport { hueGroup } from './palette';\n\nclass HueGroup {\n  num = 0;\n  cols: number[] = [];\n}\n\nexport class HueStatistics {\n  private _numGroups: number;\n  private _minCols: number;\n  private _stats: HueGroup[];\n  private _groupsFull: number;\n\n  constructor(numGroups: number, minCols: number) {\n    this._numGroups = numGroups;\n    this._minCols = minCols;\n    this._stats = [];\n\n    for (let i = 0; i <= numGroups; i++) {\n      this._stats[i] = new HueGroup();\n    }\n\n    this._groupsFull = 0;\n  }\n\n  check(i32: number) {\n    if (this._groupsFull === this._numGroups + 1) {\n      this.check = () => {};\n    }\n\n    const r = i32 & 0xff;\n    const g = (i32 >>> 8) & 0xff;\n    const b = (i32 >>> 16) & 0xff;\n    const hg =\n      r === g && g === b\n        ? 0\n        : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);\n    const gr = this._stats[hg];\n    const min = this._minCols;\n\n    gr.num++;\n\n    if (gr.num > min) {\n      return;\n    }\n    if (gr.num === min) {\n      this._groupsFull++;\n    }\n\n    if (gr.num <= min) {\n      this._stats[hg].cols.push(i32);\n    }\n  }\n\n  injectIntoDictionary(histG: Record<string, number>) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col: number) => {\n          if (!histG[col]) {\n            histG[col] = 1;\n          } else {\n            histG[col]++;\n          }\n        });\n      }\n    }\n  }\n\n  injectIntoArray(histG: string[]) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col: unknown) => {\n          if (histG.indexOf(col as string) === -1) {\n            histG.push(col as string);\n          }\n        });\n      }\n    }\n  }\n}\n","export class ProgressTracker {\n  static readonly steps = 100;\n\n  progress: number;\n\n  private _step: number;\n  private _range: number;\n  private _last: number;\n  private _progressRange: number;\n\n  constructor(valueRange: number, progressRange: number) {\n    this._range = valueRange;\n    this._progressRange = progressRange;\n    this._step = Math.max(1, (this._range / (ProgressTracker.steps + 1)) | 0);\n    this._last = -this._step;\n    this.progress = 0;\n  }\n\n  shouldNotify(current: number) {\n    if (current - this._last >= this._step) {\n      this._last = current;\n      this.progress = Math.min(\n        (this._progressRange * this._last) / this._range,\n        this._progressRange,\n      );\n      return true;\n    }\n\n    return false;\n  }\n}\n","/*\n * NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\n\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\n// bias for colour values\nconst networkBiasShift = 3;\n\nclass Neuron {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n\n  constructor(defaultValue: number) {\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  /**\n   * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\n   * @example\n   * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\n   */\n  toPoint() {\n    return Point.createByRGBA(\n      this.r >> networkBiasShift,\n      this.g >> networkBiasShift,\n      this.b >> networkBiasShift,\n      this.a >> networkBiasShift,\n    );\n  }\n\n  subtract(r: number, g: number, b: number, a: number) {\n    this.r -= r | 0;\n    this.g -= g | 0;\n    this.b -= b | 0;\n    this.a -= a | 0;\n  }\n\n  /*\n   public subtract(r : number, g : number, b : number, a : number) : void {\n   this.r = (-r + this.r) | 0;\n   this.g = (-g + this.g) | 0;\n   this.b = (-b + this.b) | 0;\n   this.a = (-a + this.a) | 0;\n\n   this.r -= r;\n   this.g -= g;\n   this.b -= b;\n   this.a -= a;\n\n   this.r -= r | 0;\n   this.g -= g | 0;\n   this.b -= b | 0;\n   this.a -= a | 0;\n   }\n   */\n}\n\nexport class NeuQuant extends AbstractPaletteQuantizer {\n  /*\n   four primes near 500 - assume no image has a length so large\n   that it is divisible by all four primes\n   */\n  private static readonly _prime1 = 499;\n  private static readonly _prime2 = 491;\n  private static readonly _prime3 = 487;\n  private static readonly _prime4 = 503;\n  private static readonly _minpicturebytes = NeuQuant._prime4;\n\n  // no. of learning cycles\n  private static readonly _nCycles = 100;\n\n  // defs for freq and bias\n  private static readonly _initialBiasShift = 16;\n\n  // bias for fractions\n  private static readonly _initialBias = 1 << NeuQuant._initialBiasShift;\n  private static readonly _gammaShift = 10;\n\n  // gamma = 1024\n  // TODO: why gamma is never used?\n  // private static _gamma : number     = (1 << NeuQuant._gammaShift);\n  private static readonly _betaShift = 10;\n  private static readonly _beta = NeuQuant._initialBias >> NeuQuant._betaShift;\n\n  // beta = 1/1024\n  private static readonly _betaGamma =\n    NeuQuant._initialBias << (NeuQuant._gammaShift - NeuQuant._betaShift);\n\n  /*\n   * for 256 cols, radius starts\n   */\n  private static readonly _radiusBiasShift = 6;\n\n  // at 32.0 biased by 6 bits\n  private static readonly _radiusBias = 1 << NeuQuant._radiusBiasShift;\n\n  // and decreases by a factor of 1/30 each cycle\n  private static readonly _radiusDecrease = 30;\n\n  /* defs for decreasing alpha factor */\n\n  // alpha starts at 1.0\n  private static readonly _alphaBiasShift = 10;\n\n  // biased by 10 bits\n  private static readonly _initAlpha = 1 << NeuQuant._alphaBiasShift;\n\n  /* radBias and alphaRadBias used for radpower calculation */\n  private static readonly _radBiasShift = 8;\n  private static readonly _radBias = 1 << NeuQuant._radBiasShift;\n  private static readonly _alphaRadBiasShift =\n    NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;\n  private static readonly _alphaRadBias = 1 << NeuQuant._alphaRadBiasShift;\n\n  private _pointArray: Point[];\n  private readonly _networkSize: number;\n  private _network!: Neuron[];\n\n  /** sampling factor 1..30 */\n  private readonly _sampleFactor!: number;\n  private _radPower!: number[];\n\n  // bias and freq arrays for learning\n  private _freq!: number[];\n\n  /* for network lookup - really 256 */\n  private _bias!: number[];\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n    );\n  }\n\n  sample(pointContainer: PointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize(): IterableIterator<PaletteQuantizerYieldValue> {\n    this._init();\n\n    yield* this._learn();\n\n    yield {\n      palette: this._buildPalette(),\n      progress: 100,\n    };\n  }\n\n  private _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new Neuron(\n        ((i << (networkBiasShift + 8)) / this._networkSize) | 0,\n      );\n\n      // 1/this._networkSize\n      this._freq[i] = (NeuQuant._initialBias / this._networkSize) | 0;\n      this._bias[i] = 0;\n    }\n  }\n\n  /**\n   * Main Learning Loop\n   */\n  private *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < NeuQuant._minpicturebytes) sampleFactor = 1;\n\n    const alphadec = (30 + (sampleFactor - 1) / 3) | 0;\n    const pointsToSample = (pointsNumber / sampleFactor) | 0;\n\n    let delta = (pointsToSample / NeuQuant._nCycles) | 0;\n    let alpha = NeuQuant._initAlpha;\n    let radius = (this._networkSize >> 3) * NeuQuant._radiusBias;\n\n    let rad = radius >> NeuQuant._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] =\n        (alpha * (((rad * rad - i * i) * NeuQuant._radBias) / (rad * rad))) >>>\n        0;\n    }\n\n    let step;\n    if (pointsNumber < NeuQuant._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % NeuQuant._prime1 !== 0) {\n      step = NeuQuant._prime1;\n    } else if (pointsNumber % NeuQuant._prime2 !== 0) {\n      step = NeuQuant._prime2;\n    } else if (pointsNumber % NeuQuant._prime3 !== 0) {\n      step = NeuQuant._prime3;\n    } else {\n      step = NeuQuant._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n\n      /* alter neighbours */\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= (alpha / alphadec) | 0;\n        radius -= (radius / NeuQuant._radiusDecrease) | 0;\n        rad = radius >> NeuQuant._radiusBiasShift;\n\n        if (rad <= 1) rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] =\n            (alpha *\n              (((rad * rad - j * j) * NeuQuant._radBias) / (rad * rad))) >>>\n            0;\n        }\n      }\n    }\n  }\n\n  private _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  /**\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\n   */\n  private _alterNeighbour(\n    rad: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    al: number,\n  ) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / NeuQuant._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  /**\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   */\n  private _alterSingle(\n    alpha: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    a: number,\n  ) {\n    alpha /= NeuQuant._initAlpha;\n\n    /* alter hit neuron */\n    const n = this._network[i];\n    n.subtract(\n      alpha * (n.r - r),\n      alpha * (n.g - g),\n      alpha * (n.b - b),\n      alpha * (n.a - a),\n    );\n  }\n\n  /**\n   * Search for biased BGR values\n   * description:\n   *    finds closest neuron (min dist) and updates freq\n   *    finds best neuron (min dist-bias) and returns position\n   *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\n   *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\n   *\n   * Original distance equation:\n   *        dist = abs(dR) + abs(dG) + abs(dB)\n   */\n  private _contest(b: number, g: number, r: number, a: number) {\n    const multiplier = (255 * 4) << networkBiasShift;\n\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist =\n        (this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier) |\n        0;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist =\n        dist -\n        (this._bias[i] >> (NeuQuant._initialBiasShift - networkBiasShift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> NeuQuant._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << NeuQuant._gammaShift;\n    }\n    this._freq[bestpos] += NeuQuant._beta;\n    this._bias[bestpos] -= NeuQuant._betaGamma;\n    return bestbiaspos;\n  }\n}\n","/*\n * NeuQuantFloat Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\n// bias for colour values\nconst networkBiasShift = 3;\n\nclass NeuronFloat {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n\n  constructor(defaultValue: number) {\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  /**\n   * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\n   * @example\n   * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\n   */\n  toPoint() {\n    return Point.createByRGBA(\n      this.r >> networkBiasShift,\n      this.g >> networkBiasShift,\n      this.b >> networkBiasShift,\n      this.a >> networkBiasShift,\n    );\n  }\n\n  subtract(r: number, g: number, b: number, a: number) {\n    this.r -= r;\n    this.g -= g;\n    this.b -= b;\n    this.a -= a;\n  }\n}\n\nexport class NeuQuantFloat extends AbstractPaletteQuantizer {\n  /*\n   four primes near 500 - assume no image has a length so large\n   that it is divisible by all four primes\n   */\n  private static readonly _prime1 = 499;\n  private static readonly _prime2 = 491;\n  private static readonly _prime3 = 487;\n  private static readonly _prime4 = 503;\n  private static readonly _minpicturebytes = NeuQuantFloat._prime4;\n\n  // no. of learning cycles\n  private static readonly _nCycles = 100;\n\n  // defs for freq and bias\n  private static readonly _initialBiasShift = 16;\n\n  // bias for fractions\n  private static readonly _initialBias = 1 << NeuQuantFloat._initialBiasShift;\n  private static readonly _gammaShift = 10;\n\n  // gamma = 1024\n  // TODO: why gamma is never used?\n  // private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\n  private static readonly _betaShift = 10;\n  private static readonly _beta =\n    NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift;\n\n  // beta = 1/1024\n  private static readonly _betaGamma =\n    NeuQuantFloat._initialBias <<\n    (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift);\n\n  /*\n   * for 256 cols, radius starts\n   */\n  private static readonly _radiusBiasShift = 6;\n\n  // at 32.0 biased by 6 bits\n  private static readonly _radiusBias = 1 << NeuQuantFloat._radiusBiasShift;\n\n  // and decreases by a factor of 1/30 each cycle\n  private static readonly _radiusDecrease = 30;\n\n  /* defs for decreasing alpha factor */\n\n  // alpha starts at 1.0\n  private static readonly _alphaBiasShift = 10;\n\n  // biased by 10 bits\n  private static readonly _initAlpha = 1 << NeuQuantFloat._alphaBiasShift;\n\n  /* radBias and alphaRadBias used for radpower calculation */\n  private static readonly _radBiasShift = 8;\n  private static readonly _radBias = 1 << NeuQuantFloat._radBiasShift;\n  private static readonly _alphaRadBiasShift =\n    NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\n  private static readonly _alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift;\n\n  private _pointArray!: Point[];\n  private readonly _networkSize!: number;\n  private _network!: NeuronFloat[];\n\n  /** sampling factor 1..30 */\n  private readonly _sampleFactor!: number;\n  private _radPower!: number[];\n\n  // bias and freq arrays for learning\n  private _freq!: number[];\n\n  /* for network lookup - really 256 */\n  private _bias!: number[];\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n    );\n  }\n\n  sample(pointContainer: PointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize() {\n    this._init();\n    yield* this._learn();\n\n    yield {\n      palette: this._buildPalette(),\n      progress: 100,\n    };\n  }\n\n  private _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new NeuronFloat(\n        (i << (networkBiasShift + 8)) / this._networkSize,\n      );\n\n      // 1/this._networkSize\n      this._freq[i] = NeuQuantFloat._initialBias / this._networkSize;\n      this._bias[i] = 0;\n    }\n  }\n\n  /**\n   * Main Learning Loop\n   */\n  private *_learn(): IterableIterator<PaletteQuantizerYieldValue> {\n    let sampleFactor = this._sampleFactor;\n\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < NeuQuantFloat._minpicturebytes) sampleFactor = 1;\n\n    const alphadec = 30 + (sampleFactor - 1) / 3;\n    const pointsToSample = pointsNumber / sampleFactor;\n\n    let delta = (pointsToSample / NeuQuantFloat._nCycles) | 0;\n    let alpha = NeuQuantFloat._initAlpha;\n    let radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\n\n    let rad = radius >> NeuQuantFloat._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] =\n        alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));\n    }\n\n    let step;\n    if (pointsNumber < NeuQuantFloat._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % NeuQuantFloat._prime1 !== 0) {\n      step = NeuQuantFloat._prime1;\n    } else if (pointsNumber % NeuQuantFloat._prime2 !== 0) {\n      step = NeuQuantFloat._prime2;\n    } else if (pointsNumber % NeuQuantFloat._prime3 !== 0) {\n      step = NeuQuantFloat._prime3;\n    } else {\n      step = NeuQuantFloat._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n\n      /* alter neighbours */\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / NeuQuantFloat._radiusDecrease;\n        rad = radius >> NeuQuantFloat._radiusBiasShift;\n\n        if (rad <= 1) rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] =\n            alpha *\n            (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));\n        }\n      }\n    }\n  }\n\n  private _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  /**\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\n   */\n  private _alterNeighbour(\n    rad: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    al: number,\n  ) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  /**\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   */\n  private _alterSingle(\n    alpha: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    a: number,\n  ) {\n    alpha /= NeuQuantFloat._initAlpha;\n\n    /* alter hit neuron */\n    const n = this._network[i];\n    n.subtract(\n      alpha * (n.r - r),\n      alpha * (n.g - g),\n      alpha * (n.b - b),\n      alpha * (n.a - a),\n    );\n  }\n\n  /**\n   * Search for biased BGR values\n   * description:\n   *    finds closest neuron (min dist) and updates freq\n   *    finds best neuron (min dist-bias) and returns position\n   *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\n   *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\n   *\n   * Original distance equation:\n   *        dist = abs(dR) + abs(dG) + abs(dB)\n   */\n  private _contest(b: number, g: number, r: number, al: number) {\n    const multiplier = (255 * 4) << networkBiasShift;\n\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist =\n        this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist =\n        dist -\n        (this._bias[i] >> (NeuQuantFloat._initialBiasShift - networkBiasShift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> NeuQuantFloat._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << NeuQuantFloat._gammaShift;\n    }\n    this._freq[bestpos] += NeuQuantFloat._beta;\n    this._bias[bestpos] -= NeuQuantFloat._betaGamma;\n    return bestbiaspos;\n  }\n}\n","/*\n * Copyright (c) 2015, Leon Sorokin\n * All rights reserved. (MIT Licensed)\n *\n * ColorHistogram.js - an image quantization lib\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * colorHistogram.ts - part of Image Quantization Library\n */\nimport { HueStatistics } from '../../utils/hueStatistics';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { stableSort } from '../../utils/arithmetic';\n\ninterface Box {\n  x: number;\n  y: number;\n  h: number;\n  w: number;\n}\n\nexport class ColorHistogram {\n  private static _boxSize = [64, 64];\n  private static _boxPixels = 2;\n  private static _hueGroups = 10;\n\n  // 1 = by global population, 2 = subregion population threshold\n  private _method: number;\n\n  // HueStatistics instance\n  private _hueStats: HueStatistics;\n\n  private _histogram: { [color: string]: number };\n\n  // # of highest-frequency colors to start with for palette reduction\n  private _initColors: number;\n\n  // if > 0, enables hues stats and min-color retention per group\n  private _minHueCols: number;\n\n  constructor(method: number, colors: number) {\n    // 1 = by global population, 2 = subregion population threshold\n    this._method = method;\n\n    // if > 0, enables hues stats and min-color retention per group\n    this._minHueCols = colors << 2; // opts.minHueCols || 0;\n\n    // # of highest-frequency colors to start with for palette reduction\n    this._initColors = colors << 2;\n\n    // HueStatistics instance\n    this._hueStats = new HueStatistics(\n      ColorHistogram._hueGroups,\n      this._minHueCols,\n    );\n\n    this._histogram = Object.create(null);\n  }\n\n  sample(pointContainer: PointContainer) {\n    switch (this._method) {\n      case 1:\n        this._colorStats1D(pointContainer);\n        break;\n      case 2:\n        this._colorStats2D(pointContainer);\n        break;\n    }\n  }\n\n  getImportanceSortedColorsIDXI32() {\n    // TODO: fix typing issue in stableSort func\n    const sorted = stableSort(\n      Object.keys(this._histogram),\n      (a, b) => this._histogram[b] - this._histogram[a],\n    );\n    if (sorted.length === 0) {\n      return [];\n    }\n\n    let idxi32;\n    switch (this._method) {\n      case 1:\n        const initialColorsLimit = Math.min(sorted.length, this._initColors);\n        const last = sorted[initialColorsLimit - 1];\n        const freq = this._histogram[last];\n\n        idxi32 = sorted.slice(0, initialColorsLimit);\n\n        // add any cut off colors with same freq as last\n        let pos = initialColorsLimit;\n        const len = sorted.length;\n        while (pos < len && this._histogram[sorted[pos]] === freq) {\n          idxi32.push(sorted[pos++]);\n        }\n\n        // inject min huegroup colors\n        this._hueStats.injectIntoArray(idxi32);\n        break;\n\n      case 2:\n        idxi32 = sorted;\n        break;\n\n      default:\n        // TODO: rethink errors\n        throw new Error('Incorrect method');\n    }\n\n    // int32-ify values\n    return idxi32.map((v) => +v);\n  }\n\n  // global top-population\n  private _colorStats1D(pointContainer: PointContainer) {\n    const histG = this._histogram;\n    const pointArray = pointContainer.getPointArray();\n    const len = pointArray.length;\n\n    for (let i = 0; i < len; i++) {\n      const col = pointArray[i].uint32;\n\n      // collect hue stats\n      this._hueStats.check(col);\n\n      if (col in histG) {\n        histG[col]++;\n      } else {\n        histG[col] = 1;\n      }\n    }\n  }\n\n  // population threshold within subregions\n  // FIXME: this can over-reduce (few/no colors same?), need a way to keep\n  // important colors that dont ever reach local thresholds (gradients?)\n  private _colorStats2D(pointContainer: PointContainer) {\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const pointArray = pointContainer.getPointArray();\n\n    const boxW = ColorHistogram._boxSize[0];\n    const boxH = ColorHistogram._boxSize[1];\n    const area = boxW * boxH;\n    const boxes = this._makeBoxes(width, height, boxW, boxH);\n    const histG = this._histogram;\n\n    boxes.forEach((box) => {\n      let effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;\n      if (effc < 2) effc = 2;\n\n      const histL: Record<string, number> = {};\n      this._iterateBox(box, width, (i) => {\n        const col = pointArray[i].uint32;\n\n        // collect hue stats\n        this._hueStats.check(col);\n\n        if (col in histG) {\n          histG[col]++;\n        } else if (col in histL) {\n          if (++histL[col] >= effc) {\n            histG[col] = histL[col];\n          }\n        } else {\n          histL[col] = 1;\n        }\n      });\n    });\n\n    // inject min huegroup colors\n    this._hueStats.injectIntoDictionary(histG);\n  }\n\n  // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\n  private _iterateBox(bbox: Box, wid: number, fn: (i: number) => void) {\n    const b = bbox;\n    const i0 = b.y * wid + b.x;\n    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\n    const incr = wid - b.w + 1;\n\n    let cnt = 0;\n    let i = i0;\n\n    do {\n      fn.call(this, i);\n      i += ++cnt % b.w === 0 ? incr : 1;\n    } while (i <= i1);\n  }\n\n  /**\n   *    partitions a rectangle of width x height into\n   *    array of boxes stepX x stepY (or less)\n   */\n  private _makeBoxes(\n    width: number,\n    height: number,\n    stepX: number,\n    stepY: number,\n  ) {\n    const wrem = width % stepX;\n    const hrem = height % stepY;\n    const xend = width - wrem;\n    const yend = height - hrem;\n    const boxesArray = [];\n\n    for (let y = 0; y < height; y += stepY) {\n      for (let x = 0; x < width; x += stepX) {\n        boxesArray.push({\n          x,\n          y,\n          w: x === xend ? wrem : stepX,\n          h: y === yend ? hrem : stepY,\n        });\n      }\n    }\n\n    return boxesArray;\n  }\n}\n","/*\n * Copyright (c) 2015, Leon Sorokin\n * All rights reserved. (MIT Licensed)\n *\n * RGBQuant.js - an image quantization lib\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgbquant.ts - part of Image Quantization Library\n */\n\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { ColorHistogram } from './colorHistogram';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { stableSort } from '../../utils/arithmetic';\nimport { ProgressTracker } from '../../utils';\n\nclass RemovedColor {\n  readonly index: number;\n  readonly color: Point;\n  readonly distance: number;\n\n  constructor(index: number, color: Point, distance: number) {\n    this.index = index;\n    this.color = color;\n    this.distance = distance;\n  }\n}\n\n// TODO: make input/output image and input/output palettes with instances of class Point only!\nexport class RGBQuant extends AbstractPaletteQuantizer {\n  // desired final palette size\n  private readonly _colors: number;\n\n  // color-distance threshold for initial reduction pass\n  private readonly _initialDistance: number;\n\n  // subsequent passes threshold\n  private readonly _distanceIncrement: number;\n\n  // accumulated histogram\n  private readonly _histogram: ColorHistogram;\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n    method = 2,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    // desired final palette size\n    this._colors = colors;\n\n    // histogram to accumulate\n    this._histogram = new ColorHistogram(method, colors);\n\n    this._initialDistance = 0.01;\n    this._distanceIncrement = 0.005;\n  }\n\n  // gathers histogram info\n  sample(image: PointContainer) {\n    /*\n     var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];\n\n     for (var i = 0, l = pointArray.length; i < l; i++) {\n     var color = pointArray[i];\n     for (var componentIndex = 0; componentIndex < 4; componentIndex++) {\n     if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];\n     if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];\n     }\n     }\n     var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];\n     this._distance.setWhitePoint(rd, gd, bd, ad);\n\n     this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;\n     */\n\n    this._histogram.sample(image);\n  }\n\n  // reduces histogram to palette, remaps & memoizes reduced colors\n  *quantize() {\n    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\n    if (idxi32.length === 0) {\n      throw new Error('No colors in image');\n    }\n\n    yield* this._buildPalette(idxi32);\n  }\n\n  // reduces similar colors from an importance-sorted Uint32 rgba array\n  private *_buildPalette(\n    idxi32: number[],\n  ): IterableIterator<PaletteQuantizerYieldValue> {\n    // reduce histogram to create initial palette\n    // build full rgb palette\n    const palette = new Palette();\n    const colorArray = palette.getPointContainer().getPointArray();\n    const usageArray = new Array(idxi32.length);\n\n    for (let i = 0; i < idxi32.length; i++) {\n      colorArray.push(Point.createByUint32(idxi32[i]));\n      usageArray[i] = 1;\n    }\n\n    const len = colorArray.length;\n    const memDist = [];\n\n    let palLen = len;\n    let thold = this._initialDistance;\n\n    // palette already at or below desired length\n    const tracker = new ProgressTracker(palLen - this._colors, 99);\n    while (palLen > this._colors) {\n      memDist.length = 0;\n\n      // iterate palette\n      for (let i = 0; i < len; i++) {\n        if (tracker.shouldNotify(len - palLen)) {\n          yield {\n            progress: tracker.progress,\n          };\n        }\n\n        if (usageArray[i] === 0) continue;\n        const pxi = colorArray[i];\n        // if (!pxi) continue;\n\n        for (let j = i + 1; j < len; j++) {\n          if (usageArray[j] === 0) continue;\n          const pxj = colorArray[j];\n          // if (!pxj) continue;\n\n          const dist = this._distance.calculateNormalized(pxi, pxj);\n          if (dist < thold) {\n            // store index,rgb,dist\n            memDist.push(new RemovedColor(j, pxj, dist));\n            usageArray[j] = 0;\n            palLen--;\n          }\n        }\n      }\n      // palette reduction pass\n      // console.log(\"palette length: \" + palLen);\n\n      // if palette is still much larger than target, increment by larger initDist\n      thold +=\n        palLen > this._colors * 3\n          ? this._initialDistance\n          : this._distanceIncrement;\n    }\n\n    // if palette is over-reduced, re-add removed colors with largest distances from last round\n    if (palLen < this._colors) {\n      // sort descending\n      stableSort(memDist, (a, b) => b.distance - a.distance);\n\n      let k = 0;\n      while (palLen < this._colors && k < memDist.length) {\n        const removedColor = memDist[k];\n        // re-inject rgb into final palette\n        usageArray[removedColor.index] = 1;\n        palLen++;\n        k++;\n      }\n    }\n\n    let colors = colorArray.length;\n    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n      if (usageArray[colorIndex] === 0) {\n        if (colorIndex !== colors - 1) {\n          colorArray[colorIndex] = colorArray[colors - 1];\n        }\n        --colors;\n      }\n    }\n    colorArray.length = colors;\n\n    palette.sort();\n\n    yield {\n      palette,\n      progress: 100,\n    };\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * wuQuant.ts - part of Image Quantization Library\n */\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\nfunction createArray1D(dimension1: number) {\n  const a = [];\n  for (let k = 0; k < dimension1; k++) {\n    a[k] = 0;\n  }\n  return a;\n}\n\nfunction createArray4D(\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n  dimension4: number,\n): number[][][][] {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = new Array(dimension4);\n        for (let l = 0; l < dimension4; l++) {\n          a[i][j][k][l] = 0;\n        }\n      }\n    }\n  }\n  return a;\n}\n\nfunction createArray3D(\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n): number[][][] {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = 0;\n      }\n    }\n  }\n  return a;\n}\n\nfunction fillArray3D<T>(\n  a: T[][][],\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n  value: T,\n) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = [];\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = [];\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = value;\n      }\n    }\n  }\n}\n\nfunction fillArray1D<T>(a: T[], dimension1: number, value: T) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = value;\n  }\n}\n\nexport class WuColorCube {\n  redMinimum!: number;\n  redMaximum!: number;\n  greenMinimum!: number;\n  greenMaximum!: number;\n  blueMinimum!: number;\n  blueMaximum!: number;\n  volume!: number;\n  alphaMinimum!: number;\n  alphaMaximum!: number;\n}\n\nexport class WuQuant extends AbstractPaletteQuantizer {\n  private static readonly _alpha = 3;\n  private static readonly _red = 2;\n  private static readonly _green = 1;\n  private static readonly _blue = 0;\n\n  private _reds!: number[];\n  private _greens!: number[];\n  private _blues!: number[];\n  private _alphas!: number[];\n  private _sums!: number[];\n\n  private _weights!: number[][][][];\n  private _momentsRed!: number[][][][];\n  private _momentsGreen!: number[][][][];\n  private _momentsBlue!: number[][][][];\n  private _momentsAlpha!: number[][][][];\n  private _moments!: number[][][][];\n  private _table!: number[];\n  private _pixels!: Point[];\n\n  private _cubes!: WuColorCube[];\n  private _colors!: number;\n\n  private _significantBitsPerChannel!: number;\n  private _maxSideIndex!: number;\n  private _alphaMaxSideIndex!: number;\n  private _sideSize!: number;\n  private _alphaSideSize!: number;\n\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n    significantBitsPerChannel = 5,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._setQuality(significantBitsPerChannel);\n    this._initialize(colors);\n  }\n\n  sample(image: PointContainer) {\n    const pointArray = image.getPointArray();\n\n    for (let i = 0, l = pointArray.length; i < l; i++) {\n      this._addColor(pointArray[i]);\n    }\n\n    this._pixels = this._pixels.concat(pointArray);\n  }\n\n  *quantize() {\n    yield* this._preparePalette();\n\n    const palette = new Palette();\n\n    // generates palette\n    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\n      if (this._sums[paletteIndex] > 0) {\n        const sum = this._sums[paletteIndex];\n        const r = this._reds[paletteIndex] / sum;\n        const g = this._greens[paletteIndex] / sum;\n        const b = this._blues[paletteIndex] / sum;\n        const a = this._alphas[paletteIndex] / sum;\n\n        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\n        palette.add(color);\n      }\n    }\n\n    palette.sort();\n\n    yield {\n      palette,\n      progress: 100,\n    };\n  }\n\n  private *_preparePalette() {\n    // preprocess the colors\n    yield* this._calculateMoments();\n\n    let next = 0;\n    const volumeVariance = createArray1D(this._colors);\n\n    // processes the cubes\n    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\n      // if cut is possible; make it\n      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\n        volumeVariance[next] =\n          this._cubes[next].volume > 1\n            ? this._calculateVariance(this._cubes[next])\n            : 0.0;\n        volumeVariance[cubeIndex] =\n          this._cubes[cubeIndex].volume > 1\n            ? this._calculateVariance(this._cubes[cubeIndex])\n            : 0.0;\n      } else {\n        // the cut was not possible, revert the index\n        volumeVariance[next] = 0.0;\n        cubeIndex--;\n      }\n\n      next = 0;\n      let temp = volumeVariance[0];\n\n      for (let index = 1; index <= cubeIndex; ++index) {\n        if (volumeVariance[index] > temp) {\n          temp = volumeVariance[index];\n          next = index;\n        }\n      }\n\n      if (temp <= 0.0) {\n        this._colors = cubeIndex + 1;\n        break;\n      }\n    }\n\n    const lookupRed = [];\n    const lookupGreen = [];\n    const lookupBlue = [];\n    const lookupAlpha = [];\n\n    // precalculates lookup tables\n    for (let k = 0; k < this._colors; ++k) {\n      const weight = WuQuant._volume(this._cubes[k], this._weights);\n\n      if (weight > 0) {\n        lookupRed[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsRed) / weight) | 0;\n        lookupGreen[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsGreen) / weight) | 0;\n        lookupBlue[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsBlue) / weight) | 0;\n        lookupAlpha[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight) | 0;\n      } else {\n        lookupRed[k] = 0;\n        lookupGreen[k] = 0;\n        lookupBlue[k] = 0;\n        lookupAlpha[k] = 0;\n      }\n    }\n\n    this._reds = createArray1D(this._colors + 1);\n    this._greens = createArray1D(this._colors + 1);\n    this._blues = createArray1D(this._colors + 1);\n    this._alphas = createArray1D(this._colors + 1);\n    this._sums = createArray1D(this._colors + 1);\n\n    // scans and adds colors\n    for (let index = 0, l = this._pixels.length; index < l; index++) {\n      const color = this._pixels[index];\n\n      const match = -1;\n\n      let bestMatch = match;\n      let bestDistance = Number.MAX_VALUE;\n\n      for (let lookup = 0; lookup < this._colors; lookup++) {\n        const foundRed = lookupRed[lookup];\n        const foundGreen = lookupGreen[lookup];\n        const foundBlue = lookupBlue[lookup];\n        const foundAlpha = lookupAlpha[lookup];\n\n        const distance = this._distance.calculateRaw(\n          foundRed,\n          foundGreen,\n          foundBlue,\n          foundAlpha,\n          color.r,\n          color.g,\n          color.b,\n          color.a,\n        );\n\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = lookup;\n        }\n      }\n\n      this._reds[bestMatch] += color.r;\n      this._greens[bestMatch] += color.g;\n      this._blues[bestMatch] += color.b;\n      this._alphas[bestMatch] += color.a;\n      this._sums[bestMatch]++;\n    }\n  }\n\n  private _addColor(color: Point) {\n    const bitsToRemove = 8 - this._significantBitsPerChannel;\n    const indexRed = (color.r >> bitsToRemove) + 1;\n    const indexGreen = (color.g >> bitsToRemove) + 1;\n    const indexBlue = (color.b >> bitsToRemove) + 1;\n    const indexAlpha = (color.a >> bitsToRemove) + 1;\n\n    // if(color.a > 10) {\n    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\n    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\n    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\n    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\n    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\n    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] +=\n      this._table[color.r] +\n      this._table[color.g] +\n      this._table[color.b] +\n      this._table[color.a];\n    // }\n  }\n\n  /**\n   * Converts the histogram to a series of _moments.\n   */\n  private *_calculateMoments(): IterableIterator<PaletteQuantizerYieldValue> {\n    const area: number[] = [];\n    const areaRed: number[] = [];\n    const areaGreen: number[] = [];\n    const areaBlue: number[] = [];\n    const areaAlpha: number[] = [];\n    const area2: number[] = [];\n\n    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaRed = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaGreen = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaBlue = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaAlpha = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xarea2 = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n\n    let trackerProgress = 0;\n    const tracker = new ProgressTracker(\n      this._alphaMaxSideIndex * this._maxSideIndex,\n      99,\n    );\n\n    for (\n      let alphaIndex = 1;\n      alphaIndex <= this._alphaMaxSideIndex;\n      ++alphaIndex\n    ) {\n      fillArray3D<number>(\n        xarea,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaRed,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaGreen,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaBlue,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaAlpha,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xarea2,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n\n      for (\n        let redIndex = 1;\n        redIndex <= this._maxSideIndex;\n        ++redIndex, ++trackerProgress\n      ) {\n        if (tracker.shouldNotify(trackerProgress)) {\n          yield {\n            progress: tracker.progress,\n          };\n        }\n\n        fillArray1D<number>(area, this._sideSize, 0);\n        fillArray1D<number>(areaRed, this._sideSize, 0);\n        fillArray1D<number>(areaGreen, this._sideSize, 0);\n        fillArray1D<number>(areaBlue, this._sideSize, 0);\n        fillArray1D<number>(areaAlpha, this._sideSize, 0);\n        fillArray1D<number>(area2, this._sideSize, 0);\n\n        for (\n          let greenIndex = 1;\n          greenIndex <= this._maxSideIndex;\n          ++greenIndex\n        ) {\n          let line = 0;\n          let lineRed = 0;\n          let lineGreen = 0;\n          let lineBlue = 0;\n          let lineAlpha = 0;\n          let line2 = 0.0;\n\n          for (\n            let blueIndex = 1;\n            blueIndex <= this._maxSideIndex;\n            ++blueIndex\n          ) {\n            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineRed +=\n              this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineGreen +=\n              this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineBlue +=\n              this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineAlpha +=\n              this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\n            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\n\n            area[blueIndex] += line;\n            areaRed[blueIndex] += lineRed;\n            areaGreen[blueIndex] += lineGreen;\n            areaBlue[blueIndex] += lineBlue;\n            areaAlpha[blueIndex] += lineAlpha;\n            area2[blueIndex] += line2;\n\n            xarea[redIndex][greenIndex][blueIndex] =\n              xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\n            xareaRed[redIndex][greenIndex][blueIndex] =\n              xareaRed[redIndex - 1][greenIndex][blueIndex] +\n              areaRed[blueIndex];\n            xareaGreen[redIndex][greenIndex][blueIndex] =\n              xareaGreen[redIndex - 1][greenIndex][blueIndex] +\n              areaGreen[blueIndex];\n            xareaBlue[redIndex][greenIndex][blueIndex] =\n              xareaBlue[redIndex - 1][greenIndex][blueIndex] +\n              areaBlue[blueIndex];\n            xareaAlpha[redIndex][greenIndex][blueIndex] =\n              xareaAlpha[redIndex - 1][greenIndex][blueIndex] +\n              areaAlpha[blueIndex];\n            xarea2[redIndex][greenIndex][blueIndex] =\n              xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\n\n            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] +\n              xarea[redIndex][greenIndex][blueIndex];\n            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsRed[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaRed[redIndex][greenIndex][blueIndex];\n            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaGreen[redIndex][greenIndex][blueIndex];\n            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaBlue[redIndex][greenIndex][blueIndex];\n            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaAlpha[redIndex][greenIndex][blueIndex];\n            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] +\n              xarea2[redIndex][greenIndex][blueIndex];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Computes the volume of the cube in a specific moment.\n   */\n  private static _volumeFloat(cube: WuColorCube, moment: number[][][][]) {\n    return (\n      moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMinimum\n      ] -\n        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n          cube.blueMinimum\n        ])\n    );\n  }\n\n  /**\n   * Computes the volume of the cube in a specific moment.\n   */\n  private static _volume(cube: WuColorCube, moment: number[][][][]) {\n    return WuQuant._volumeFloat(cube, moment) | 0;\n  }\n\n  /**\n   * Splits the cube in given position][and color direction.\n   */\n  private static _top(\n    cube: WuColorCube,\n    direction: number,\n    position: number,\n    moment: number[][][][],\n  ) {\n    let result;\n    switch (direction) {\n      case WuQuant._alpha:\n        result =\n          moment[position][cube.redMaximum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[position][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[position][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[position][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (moment[position][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n            moment[position][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[position][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] +\n            moment[position][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._red:\n        result =\n          moment[cube.alphaMaximum][position][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMaximum][position][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][position][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][position][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (moment[cube.alphaMaximum][position][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n            moment[cube.alphaMaximum][position][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][position][cube.greenMaximum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][position][cube.greenMinimum][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._green:\n        result =\n          moment[cube.alphaMaximum][cube.redMaximum][position][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][position][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMaximum][position][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][position][\n            cube.blueMaximum\n          ] -\n          (moment[cube.alphaMaximum][cube.redMaximum][position][\n            cube.blueMinimum\n          ] -\n            moment[cube.alphaMaximum][cube.redMinimum][position][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMaximum][position][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][position][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._blue:\n        result =\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n            position\n          ] -\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            position\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            position\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            position\n          ] -\n          (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            position\n          ] -\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              position\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              position\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              position\n            ]);\n        break;\n      default:\n        throw new Error('impossible');\n    }\n\n    return result | 0;\n  }\n\n  /**\n   * Splits the cube in a given color direction at its minimum.\n   */\n  private static _bottom(\n    cube: WuColorCube,\n    direction: number,\n    moment: number[][][][],\n  ) {\n    switch (direction) {\n      case WuQuant._alpha:\n        return (\n          -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._red:\n        return (\n          -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._green:\n        return (\n          -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._blue:\n        return (\n          -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMinimum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMinimum\n          ] -\n          (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      default:\n        // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?\n        return 0;\n    }\n  }\n\n  /**\n   * Calculates statistical variance for a given cube.\n   */\n  private _calculateVariance(cube: WuColorCube) {\n    const volumeRed = WuQuant._volume(cube, this._momentsRed);\n    const volumeGreen = WuQuant._volume(cube, this._momentsGreen);\n    const volumeBlue = WuQuant._volume(cube, this._momentsBlue);\n    const volumeAlpha = WuQuant._volume(cube, this._momentsAlpha);\n    const volumeMoment = WuQuant._volumeFloat(cube, this._moments);\n    const volumeWeight = WuQuant._volume(cube, this._weights);\n    const distance =\n      volumeRed * volumeRed +\n      volumeGreen * volumeGreen +\n      volumeBlue * volumeBlue +\n      volumeAlpha * volumeAlpha;\n\n    return volumeMoment - distance / volumeWeight;\n  }\n\n  /**\n   * Finds the optimal (maximal) position for the cut.\n   */\n  private _maximize(\n    cube: WuColorCube,\n    direction: number,\n    first: number,\n    last: number,\n    wholeRed: number,\n    wholeGreen: number,\n    wholeBlue: number,\n    wholeAlpha: number,\n    wholeWeight: number,\n  ) {\n    const bottomRed = WuQuant._bottom(cube, direction, this._momentsRed) | 0;\n    const bottomGreen =\n      WuQuant._bottom(cube, direction, this._momentsGreen) | 0;\n    const bottomBlue = WuQuant._bottom(cube, direction, this._momentsBlue) | 0;\n    const bottomAlpha =\n      WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;\n    const bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;\n\n    let result = 0.0;\n    let cutPosition = -1;\n\n    for (let position = first; position < last; ++position) {\n      // determines the cube cut at a certain position\n      let halfRed =\n        bottomRed + WuQuant._top(cube, direction, position, this._momentsRed);\n      let halfGreen =\n        bottomGreen +\n        WuQuant._top(cube, direction, position, this._momentsGreen);\n      let halfBlue =\n        bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue);\n      let halfAlpha =\n        bottomAlpha +\n        WuQuant._top(cube, direction, position, this._momentsAlpha);\n      let halfWeight =\n        bottomWeight + WuQuant._top(cube, direction, position, this._weights);\n\n      // the cube cannot be cut at bottom (this would lead to empty cube)\n      if (halfWeight !== 0) {\n        let halfDistance =\n          halfRed * halfRed +\n          halfGreen * halfGreen +\n          halfBlue * halfBlue +\n          halfAlpha * halfAlpha;\n        let temp = halfDistance / halfWeight;\n\n        halfRed = wholeRed - halfRed;\n        halfGreen = wholeGreen - halfGreen;\n        halfBlue = wholeBlue - halfBlue;\n        halfAlpha = wholeAlpha - halfAlpha;\n        halfWeight = wholeWeight - halfWeight;\n\n        if (halfWeight !== 0) {\n          halfDistance =\n            halfRed * halfRed +\n            halfGreen * halfGreen +\n            halfBlue * halfBlue +\n            halfAlpha * halfAlpha;\n          temp += halfDistance / halfWeight;\n\n          if (temp > result) {\n            result = temp;\n            cutPosition = position;\n          }\n        }\n      }\n    }\n\n    return { max: result, position: cutPosition };\n  }\n\n  // Cuts a cube with another one.\n  private _cut(first: WuColorCube, second: WuColorCube) {\n    let direction;\n\n    const wholeRed = WuQuant._volume(first, this._momentsRed);\n    const wholeGreen = WuQuant._volume(first, this._momentsGreen);\n    const wholeBlue = WuQuant._volume(first, this._momentsBlue);\n    const wholeAlpha = WuQuant._volume(first, this._momentsAlpha);\n    const wholeWeight = WuQuant._volume(first, this._weights);\n\n    const red = this._maximize(\n      first,\n      WuQuant._red,\n      first.redMinimum + 1,\n      first.redMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const green = this._maximize(\n      first,\n      WuQuant._green,\n      first.greenMinimum + 1,\n      first.greenMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const blue = this._maximize(\n      first,\n      WuQuant._blue,\n      first.blueMinimum + 1,\n      first.blueMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const alpha = this._maximize(\n      first,\n      WuQuant._alpha,\n      first.alphaMinimum + 1,\n      first.alphaMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n\n    if (\n      alpha.max >= red.max &&\n      alpha.max >= green.max &&\n      alpha.max >= blue.max\n    ) {\n      direction = WuQuant._alpha;\n\n      // cannot split empty cube\n      if (alpha.position < 0) return false;\n    } else if (\n      red.max >= alpha.max &&\n      red.max >= green.max &&\n      red.max >= blue.max\n    ) {\n      direction = WuQuant._red;\n    } else if (\n      green.max >= alpha.max &&\n      green.max >= red.max &&\n      green.max >= blue.max\n    ) {\n      direction = WuQuant._green;\n    } else {\n      direction = WuQuant._blue;\n    }\n\n    second.redMaximum = first.redMaximum;\n    second.greenMaximum = first.greenMaximum;\n    second.blueMaximum = first.blueMaximum;\n    second.alphaMaximum = first.alphaMaximum;\n\n    // cuts in a certain direction\n    switch (direction) {\n      case WuQuant._red:\n        second.redMinimum = first.redMaximum = red.position;\n        second.greenMinimum = first.greenMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._green:\n        second.greenMinimum = first.greenMaximum = green.position;\n        second.redMinimum = first.redMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._blue:\n        second.blueMinimum = first.blueMaximum = blue.position;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._alpha:\n        second.alphaMinimum = first.alphaMaximum = alpha.position;\n        second.blueMinimum = first.blueMinimum;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        break;\n    }\n\n    // determines the volumes after cut\n    first.volume =\n      (first.redMaximum - first.redMinimum) *\n      (first.greenMaximum - first.greenMinimum) *\n      (first.blueMaximum - first.blueMinimum) *\n      (first.alphaMaximum - first.alphaMinimum);\n    second.volume =\n      (second.redMaximum - second.redMinimum) *\n      (second.greenMaximum - second.greenMinimum) *\n      (second.blueMaximum - second.blueMinimum) *\n      (second.alphaMaximum - second.alphaMinimum);\n\n    // the cut was successful\n    return true;\n  }\n\n  private _initialize(colors: number) {\n    this._colors = colors;\n\n    // creates all the _cubes\n    this._cubes = [];\n\n    // initializes all the _cubes\n    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\n      this._cubes[cubeIndex] = new WuColorCube();\n    }\n\n    // resets the reference minimums\n    this._cubes[0].redMinimum = 0;\n    this._cubes[0].greenMinimum = 0;\n    this._cubes[0].blueMinimum = 0;\n    this._cubes[0].alphaMinimum = 0;\n\n    // resets the reference maximums\n    this._cubes[0].redMaximum = this._maxSideIndex;\n    this._cubes[0].greenMaximum = this._maxSideIndex;\n    this._cubes[0].blueMaximum = this._maxSideIndex;\n    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\n\n    this._weights = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsRed = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsGreen = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsBlue = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsAlpha = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._moments = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n\n    this._table = [];\n    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\n      this._table[tableIndex] = tableIndex * tableIndex;\n    }\n\n    this._pixels = [];\n  }\n\n  private _setQuality(significantBitsPerChannel = 5) {\n    this._significantBitsPerChannel = significantBitsPerChannel;\n    this._maxSideIndex = 1 << this._significantBitsPerChannel;\n    this._alphaMaxSideIndex = this._maxSideIndex;\n\n    this._sideSize = this._maxSideIndex + 1;\n    this._alphaSideSize = this._alphaMaxSideIndex + 1;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\n\nexport { AbstractImageQuantizer } from './imageQuantizer';\nexport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nexport { NearestColor } from './nearestColor';\nexport { ErrorDiffusionArray, ErrorDiffusionArrayKernel } from './array';\nexport { ErrorDiffusionRiemersma } from './riemersma';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\n\nexport abstract class AbstractImageQuantizer {\n  abstract quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue>;\n\n  quantizeSync(pointContainer: PointContainer, palette: Palette) {\n    for (const value of this.quantize(pointContainer, palette)) {\n      if (value.pointContainer) {\n        return value.pointContainer;\n      }\n    }\n\n    throw new Error('unreachable');\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * nearestColor.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nimport { ProgressTracker } from '../utils/progressTracker';\n\nexport class NearestColor extends AbstractImageQuantizer {\n  private _distance: AbstractDistanceCalculator;\n\n  constructor(colorDistanceCalculator: AbstractDistanceCalculator) {\n    super();\n    this._distance = colorDistanceCalculator;\n  }\n\n  /**\n   * Mutates pointContainer\n   */\n  *quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue> {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n\n    const tracker = new ProgressTracker(height, 99);\n    for (let y = 0; y < height; y++) {\n      if (tracker.shouldNotify(y)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n      for (let x = 0, idx = y * width; x < width; x++, idx++) {\n        // Image pixel\n        const point = pointArray[idx];\n        // Reduced pixel\n        point.from(palette.getNearestColor(this._distance, point));\n      }\n    }\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { Point } from '../utils/point';\nimport { inRange0to255Rounded } from '../utils/arithmetic';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nimport { ProgressTracker } from '../utils/progressTracker';\n\n// TODO: is it the best name for this enum \"kernel\"?\nexport enum ErrorDiffusionArrayKernel {\n  FloydSteinberg = 0,\n  FalseFloydSteinberg,\n  Stucki,\n  Atkinson,\n  Jarvis,\n  Burkes,\n  Sierra,\n  TwoSierra,\n  SierraLite,\n}\n\n// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\nexport class ErrorDiffusionArray extends AbstractImageQuantizer {\n  private _minColorDistance: number;\n  private _serpentine: boolean;\n  private _kernel!: number[][];\n  /** true = GIMP, false = XNVIEW */\n  private _calculateErrorLikeGIMP: boolean;\n\n  private _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    kernel: ErrorDiffusionArrayKernel,\n    serpentine = true,\n    minimumColorDistanceToDither = 0,\n    calculateErrorLikeGIMP = false,\n  ) {\n    super();\n    this._setKernel(kernel);\n\n    this._distance = colorDistanceCalculator;\n    this._minColorDistance = minimumColorDistanceToDither;\n    this._serpentine = serpentine;\n    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\n  }\n\n  /**\n   * adapted from http://jsbin.com/iXofIji/2/edit by PAEz\n   * fixed version. it doesn't use image pixels as error storage, also it doesn't have 0.3 + 0.3 + 0.3 + 0.3 = 0 error\n   * Mutates pointContainer\n   */\n  *quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue> {\n    const pointArray = pointContainer.getPointArray();\n    const originalPoint = new Point();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorLines: number[][][] = [];\n\n    let dir = 1;\n    let maxErrorLines = 1;\n\n    // initial error lines (number is taken from dithering kernel)\n    for (const kernel of this._kernel) {\n      const kernelErrorLines = kernel[2] + 1;\n      if (maxErrorLines < kernelErrorLines) maxErrorLines = kernelErrorLines;\n    }\n    for (let i = 0; i < maxErrorLines; i++) {\n      this._fillErrorLine((errorLines[i] = []), width);\n    }\n\n    const tracker = new ProgressTracker(height, 99);\n    for (let y = 0; y < height; y++) {\n      if (tracker.shouldNotify(y)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      // always serpentine\n      if (this._serpentine) dir *= -1;\n\n      const lni = y * width;\n      const xStart = dir === 1 ? 0 : width - 1;\n      const xEnd = dir === 1 ? width : -1;\n\n      // cyclic shift with erasing\n      this._fillErrorLine(errorLines[0], width);\n      // TODO: why it is needed to cast types here?\n      errorLines.push(errorLines.shift() as number[][]);\n\n      const errorLine = errorLines[0];\n      for (\n        let x = xStart, idx = lni + xStart;\n        x !== xEnd;\n        x += dir, idx += dir\n      ) {\n        // Image pixel\n        const point = pointArray[idx];\n        // originalPoint = new Utils.Point(),\n        const error = errorLine[x];\n\n        originalPoint.from(point);\n\n        const correctedPoint = Point.createByRGBA(\n          inRange0to255Rounded(point.r + error[0]),\n          inRange0to255Rounded(point.g + error[1]),\n          inRange0to255Rounded(point.b + error[2]),\n          inRange0to255Rounded(point.a + error[3]),\n        );\n\n        // Reduced pixel\n        const palettePoint = palette.getNearestColor(\n          this._distance,\n          correctedPoint,\n        );\n        point.from(palettePoint);\n\n        // dithering strength\n        if (this._minColorDistance) {\n          const dist = this._distance.calculateNormalized(\n            originalPoint,\n            palettePoint,\n          );\n          if (dist < this._minColorDistance) continue;\n        }\n\n        // Component distance\n        let er;\n        let eg;\n        let eb;\n        let ea;\n        if (this._calculateErrorLikeGIMP) {\n          er = correctedPoint.r - palettePoint.r;\n          eg = correctedPoint.g - palettePoint.g;\n          eb = correctedPoint.b - palettePoint.b;\n          ea = correctedPoint.a - palettePoint.a;\n        } else {\n          er = originalPoint.r - palettePoint.r;\n          eg = originalPoint.g - palettePoint.g;\n          eb = originalPoint.b - palettePoint.b;\n          ea = originalPoint.a - palettePoint.a;\n        }\n\n        const dStart = dir === 1 ? 0 : this._kernel.length - 1;\n        const dEnd = dir === 1 ? this._kernel.length : -1;\n\n        for (let i = dStart; i !== dEnd; i += dir) {\n          const x1 = this._kernel[i][1] * dir;\n          const y1 = this._kernel[i][2];\n\n          if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n            const d = this._kernel[i][0];\n            const e = errorLines[y1][x1 + x];\n\n            e[0] += er * d;\n            e[1] += eg * d;\n            e[2] += eb * d;\n            e[3] += ea * d;\n          }\n        }\n      }\n    }\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n\n  private _fillErrorLine(errorLine: number[][], width: number) {\n    // shrink\n    if (errorLine.length > width) {\n      errorLine.length = width;\n    }\n\n    // reuse existing arrays\n    const l = errorLine.length;\n    for (let i = 0; i < l; i++) {\n      const error = errorLine[i];\n      error[0] = error[1] = error[2] = error[3] = 0;\n    }\n\n    // create missing arrays\n    for (let i = l; i < width; i++) {\n      errorLine[i] = [0.0, 0.0, 0.0, 0.0];\n    }\n  }\n\n  private _setKernel(kernel: ErrorDiffusionArrayKernel) {\n    switch (kernel) {\n      case ErrorDiffusionArrayKernel.FloydSteinberg:\n        this._kernel = [\n          [7 / 16, 1, 0],\n          [3 / 16, -1, 1],\n          [5 / 16, 0, 1],\n          [1 / 16, 1, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.FalseFloydSteinberg:\n        this._kernel = [\n          [3 / 8, 1, 0],\n          [3 / 8, 0, 1],\n          [2 / 8, 1, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Stucki:\n        this._kernel = [\n          [8 / 42, 1, 0],\n          [4 / 42, 2, 0],\n          [2 / 42, -2, 1],\n          [4 / 42, -1, 1],\n          [8 / 42, 0, 1],\n          [4 / 42, 1, 1],\n          [2 / 42, 2, 1],\n          [1 / 42, -2, 2],\n          [2 / 42, -1, 2],\n          [4 / 42, 0, 2],\n          [2 / 42, 1, 2],\n          [1 / 42, 2, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Atkinson:\n        this._kernel = [\n          [1 / 8, 1, 0],\n          [1 / 8, 2, 0],\n          [1 / 8, -1, 1],\n          [1 / 8, 0, 1],\n          [1 / 8, 1, 1],\n          [1 / 8, 0, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Jarvis:\n        this._kernel = [\n          // Jarvis, Judice, and Ninke / JJN?\n          [7 / 48, 1, 0],\n          [5 / 48, 2, 0],\n          [3 / 48, -2, 1],\n          [5 / 48, -1, 1],\n          [7 / 48, 0, 1],\n          [5 / 48, 1, 1],\n          [3 / 48, 2, 1],\n          [1 / 48, -2, 2],\n          [3 / 48, -1, 2],\n          [5 / 48, 0, 2],\n          [3 / 48, 1, 2],\n          [1 / 48, 2, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Burkes:\n        this._kernel = [\n          [8 / 32, 1, 0],\n          [4 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [8 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Sierra:\n        this._kernel = [\n          [5 / 32, 1, 0],\n          [3 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [5 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1],\n          [2 / 32, -1, 2],\n          [3 / 32, 0, 2],\n          [2 / 32, 1, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.TwoSierra:\n        this._kernel = [\n          [4 / 16, 1, 0],\n          [3 / 16, 2, 0],\n          [1 / 16, -2, 1],\n          [2 / 16, -1, 1],\n          [3 / 16, 0, 1],\n          [2 / 16, 1, 1],\n          [1 / 16, 2, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.SierraLite:\n        this._kernel = [\n          [2 / 4, 1, 0],\n          [1 / 4, -1, 1],\n          [1 / 4, 0, 1],\n        ];\n        break;\n\n      default:\n        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);\n    }\n  }\n}\n","import { ProgressTracker } from '../../utils/progressTracker';\nimport { ImageQuantizerYieldValue } from '../imageQuantizerYieldValue';\n\nenum Direction {\n  NONE = 0,\n  UP,\n  LEFT,\n  RIGHT,\n  DOWN,\n}\n\ninterface Data {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  level: number;\n  index: number;\n  tracker: ProgressTracker;\n  callback(x: number, y: number): void;\n}\n\nexport function* hilbertCurve(\n  width: number,\n  height: number,\n  callback: (x: number, y: number) => void,\n) {\n  const maxBound = Math.max(width, height);\n  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);\n  const tracker = new ProgressTracker(width * height, 99);\n  const data = {\n    width,\n    height,\n    level,\n    callback,\n    tracker,\n    index: 0,\n    x: 0,\n    y: 0,\n  };\n  yield* walkHilbert(data, Direction.UP);\n  visit(data, Direction.NONE);\n}\n\nfunction* walkHilbert(\n  data: Data,\n  direction: Direction,\n): IterableIterator<ImageQuantizerYieldValue> {\n  if (data.level < 1) return;\n\n  if (data.tracker.shouldNotify(data.index)) {\n    yield { progress: data.tracker.progress };\n  }\n  data.level--;\n  switch (direction) {\n    case Direction.LEFT:\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.DOWN);\n      break;\n\n    case Direction.RIGHT:\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.UP);\n      break;\n\n    case Direction.UP:\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.RIGHT);\n      break;\n\n    case Direction.DOWN:\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.LEFT);\n      break;\n\n    default:\n      break;\n  }\n  data.level++;\n}\n\nfunction visit(data: Data, direction: Direction) {\n  if (\n    data.x >= 0 &&\n    data.x < data.width &&\n    data.y >= 0 &&\n    data.y < data.height\n  ) {\n    data.callback(data.x, data.y);\n    data.index++;\n  }\n  switch (direction) {\n    case Direction.LEFT:\n      data.x--;\n      break;\n    case Direction.RIGHT:\n      data.x++;\n      break;\n    case Direction.UP:\n      data.y--;\n      break;\n    case Direction.DOWN:\n      data.y++;\n      break;\n  }\n}\n","/**\n * @preserve\n * MIT License\n *\n * Copyright 2015-2018 Igor Bezkrovnyi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * riemersma.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { hilbertCurve } from './spaceFillingCurves/hilbertCurve';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { Point } from '../utils/point';\nimport { inRange0to255Rounded } from '../utils/arithmetic';\n\nexport class ErrorDiffusionRiemersma extends AbstractImageQuantizer {\n  private _distance: AbstractDistanceCalculator;\n  private _weights: number[];\n  private _errorQueueSize: number;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    errorQueueSize = 16,\n    errorPropagation = 1,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._errorQueueSize = errorQueueSize;\n    this._weights = ErrorDiffusionRiemersma._createWeights(\n      errorPropagation,\n      errorQueueSize,\n    );\n  }\n\n  /**\n   * Mutates pointContainer\n   */\n  *quantize(pointContainer: PointContainer, palette: Palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorQueue: Array<{\n      r: number;\n      g: number;\n      b: number;\n      a: number;\n    }> = [];\n\n    let head = 0;\n\n    for (let i = 0; i < this._errorQueueSize; i++) {\n      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };\n    }\n\n    yield* hilbertCurve(width, height, (x, y) => {\n      const p = pointArray[x + y * width];\n      let { r, g, b, a } = p;\n      for (let i = 0; i < this._errorQueueSize; i++) {\n        const weight = this._weights[i];\n        const e = errorQueue[(i + head) % this._errorQueueSize];\n\n        r += e.r * weight;\n        g += e.g * weight;\n        b += e.b * weight;\n        a += e.a * weight;\n      }\n\n      const correctedPoint = Point.createByRGBA(\n        inRange0to255Rounded(r),\n        inRange0to255Rounded(g),\n        inRange0to255Rounded(b),\n        inRange0to255Rounded(a),\n      );\n\n      const quantizedPoint = palette.getNearestColor(\n        this._distance,\n        correctedPoint,\n      );\n\n      // update head and calculate tail\n      head = (head + 1) % this._errorQueueSize;\n      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\n\n      // update error with new value\n      errorQueue[tail].r = p.r - quantizedPoint.r;\n      errorQueue[tail].g = p.g - quantizedPoint.g;\n      errorQueue[tail].b = p.b - quantizedPoint.b;\n      errorQueue[tail].a = p.a - quantizedPoint.a;\n\n      // update point\n      p.from(quantizedPoint);\n    });\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n\n  private static _createWeights(\n    errorPropagation: number,\n    errorQueueSize: number,\n  ) {\n    const weights = [];\n\n    const multiplier = Math.exp(\n      Math.log(errorQueueSize) / (errorQueueSize - 1),\n    );\n    for (let i = 0, next = 1; i < errorQueueSize; i++) {\n      weights[i] = (((next + 0.5) | 0) / errorQueueSize) * errorPropagation;\n      next *= multiplier;\n    }\n\n    return weights;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { ssim } from './ssim';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ssim.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { Y } from '../constants/bt709';\n\n// based on https://github.com/rhys-e/structural-similarity\n// http://en.wikipedia.org/wiki/Structural_similarity\nconst K1 = 0.01;\nconst K2 = 0.03;\n\nexport function ssim(image1: PointContainer, image2: PointContainer) {\n  if (\n    image1.getHeight() !== image2.getHeight() ||\n    image1.getWidth() !== image2.getWidth()\n  ) {\n    throw new Error('Images have different sizes!');\n  }\n\n  const bitsPerComponent = 8;\n  const L = (1 << bitsPerComponent) - 1;\n  const c1 = (K1 * L) ** 2;\n  const c2 = (K2 * L) ** 2;\n\n  let numWindows = 0;\n  let mssim = 0.0;\n\n  // calculate ssim for each window\n  iterate(\n    image1,\n    image2,\n    (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {\n      // calculate variance and covariance\n      let sigxy = 0.0;\n      let sigsqx = 0.0;\n      let sigsqy = 0.0;\n\n      for (let i = 0; i < lumaValues1.length; i++) {\n        sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;\n        sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;\n\n        sigxy +=\n          (lumaValues1[i] - averageLumaValue1) *\n          (lumaValues2[i] - averageLumaValue2);\n      }\n\n      const numPixelsInWin = lumaValues1.length - 1;\n      sigsqx /= numPixelsInWin;\n      sigsqy /= numPixelsInWin;\n      sigxy /= numPixelsInWin;\n\n      // perform ssim calculation on window\n      const numerator =\n        (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\n      const denominator =\n        (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) *\n        (sigsqx + sigsqy + c2);\n      const ssim = numerator / denominator;\n\n      mssim += ssim;\n      numWindows++;\n    },\n  );\n  return mssim / numWindows;\n}\n\nfunction iterate(\n  image1: PointContainer,\n  image2: PointContainer,\n  callback: (\n    lumaValues1: number[],\n    lumaValues2: number[],\n    averageLumaValue1: number,\n    averageLumaValue2: number,\n  ) => void,\n) {\n  const windowSize = 8;\n  const width = image1.getWidth();\n  const height = image1.getHeight();\n\n  for (let y = 0; y < height; y += windowSize) {\n    for (let x = 0; x < width; x += windowSize) {\n      // avoid out-of-width/height\n      const windowWidth = Math.min(windowSize, width - x);\n      const windowHeight = Math.min(windowSize, height - y);\n\n      const lumaValues1 = calculateLumaValuesForWindow(\n        image1,\n        x,\n        y,\n        windowWidth,\n        windowHeight,\n      );\n      const lumaValues2 = calculateLumaValuesForWindow(\n        image2,\n        x,\n        y,\n        windowWidth,\n        windowHeight,\n      );\n      const averageLuma1 = calculateAverageLuma(lumaValues1);\n      const averageLuma2 = calculateAverageLuma(lumaValues2);\n\n      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\n    }\n  }\n}\n\nfunction calculateLumaValuesForWindow(\n  image: PointContainer,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) {\n  const pointArray = image.getPointArray();\n  const lumaValues = [];\n\n  let counter = 0;\n\n  for (let j = y; j < y + height; j++) {\n    const offset = j * image.getWidth();\n    for (let i = x; i < x + width; i++) {\n      const point = pointArray[offset + i];\n      lumaValues[counter] =\n        point.r * Y.RED + point.g * Y.GREEN + point.b * Y.BLUE;\n      counter++;\n    }\n  }\n\n  return lumaValues;\n}\n\nfunction calculateAverageLuma(lumaValues: number[]) {\n  let sumLuma = 0.0;\n  for (const luma of lumaValues) {\n    sumLuma += luma;\n  }\n\n  return sumLuma / lumaValues.length;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * helper.ts - part of Image Quantization Library\n */\nimport * as distance from './distance';\nimport * as image from './image';\nimport * as palette from './palette';\nimport { AbstractDistanceCalculator } from './distance/distanceCalculator';\nimport { PointContainer } from './utils/pointContainer';\nimport { Palette } from './utils/palette';\n\nconst setImmediateImpl =\n  typeof setImmediate === 'function'\n    ? setImmediate\n    : typeof process !== 'undefined' && typeof process?.nextTick === 'function'\n    ? (callback: () => void) => process.nextTick(callback)\n    : (callback: () => void) => setTimeout(callback, 0);\n\nexport type ColorDistanceFormula =\n  | 'cie94-textiles'\n  | 'cie94-graphic-arts'\n  | 'ciede2000'\n  | 'color-metric'\n  | 'euclidean'\n  | 'euclidean-bt709-noalpha'\n  | 'euclidean-bt709'\n  | 'manhattan'\n  | 'manhattan-bt709'\n  | 'manhattan-nommyde'\n  | 'pngquant';\n\nexport type PaletteQuantization =\n  | 'neuquant'\n  | 'neuquant-float'\n  | 'rgbquant'\n  | 'wuquant';\n\nexport type ImageQuantization =\n  | 'nearest'\n  | 'riemersma'\n  | 'floyd-steinberg'\n  | 'false-floyd-steinberg'\n  | 'stucki'\n  | 'atkinson'\n  | 'jarvis'\n  | 'burkes'\n  | 'sierra'\n  | 'two-sierra'\n  | 'sierra-lite';\n\nexport interface ProgressOptions {\n  onProgress?: (progress: number) => void;\n}\n\nexport interface ApplyPaletteOptions {\n  colorDistanceFormula?: ColorDistanceFormula;\n  imageQuantization?: ImageQuantization;\n}\n\nexport interface BuildPaletteOptions {\n  colorDistanceFormula?: ColorDistanceFormula;\n  paletteQuantization?: PaletteQuantization;\n  colors?: number;\n}\n\nexport function buildPaletteSync(\n  images: PointContainer[],\n  {\n    colorDistanceFormula,\n    paletteQuantization,\n    colors,\n  }: BuildPaletteOptions = {},\n) {\n  const distanceCalculator =\n    colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(\n    distanceCalculator,\n    paletteQuantization,\n    colors,\n  );\n  images.forEach((image) => paletteQuantizer.sample(image));\n  return paletteQuantizer.quantizeSync();\n}\n\nexport async function buildPalette(\n  images: PointContainer[],\n  {\n    colorDistanceFormula,\n    paletteQuantization,\n    colors,\n    onProgress,\n  }: BuildPaletteOptions & ProgressOptions = {},\n) {\n  return new Promise<Palette>((resolve, reject) => {\n    const distanceCalculator =\n      colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(\n      distanceCalculator,\n      paletteQuantization,\n      colors,\n    );\n    images.forEach((image) => paletteQuantizer.sample(image));\n\n    let palette: Palette;\n    const iterator = paletteQuantizer.quantize();\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(palette);\n        } else {\n          if (result.value.palette) palette = result.value.palette;\n          if (onProgress) onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\n\nexport function applyPaletteSync(\n  image: PointContainer,\n  palette: Palette,\n  { colorDistanceFormula, imageQuantization }: ApplyPaletteOptions = {},\n) {\n  const distanceCalculator =\n    colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const imageQuantizer = imageQuantizationToImageQuantizer(\n    distanceCalculator,\n    imageQuantization,\n  );\n  return imageQuantizer.quantizeSync(image, palette);\n}\n\nexport async function applyPalette(\n  image: PointContainer,\n  palette: Palette,\n  {\n    colorDistanceFormula,\n    imageQuantization,\n    onProgress,\n  }: ApplyPaletteOptions & ProgressOptions = {},\n) {\n  return new Promise<PointContainer>((resolve, reject) => {\n    const distanceCalculator =\n      colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const imageQuantizer = imageQuantizationToImageQuantizer(\n      distanceCalculator,\n      imageQuantization,\n    );\n\n    let outPointContainer: PointContainer;\n    const iterator = imageQuantizer.quantize(image, palette);\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(outPointContainer);\n        } else {\n          if (result.value.pointContainer) {\n            outPointContainer = result.value.pointContainer;\n          }\n          if (onProgress) onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\n\nfunction colorDistanceFormulaToColorDistance(\n  colorDistanceFormula: ColorDistanceFormula = 'euclidean-bt709',\n) {\n  switch (colorDistanceFormula) {\n    case 'cie94-graphic-arts':\n      return new distance.CIE94GraphicArts();\n    case 'cie94-textiles':\n      return new distance.CIE94Textiles();\n    case 'ciede2000':\n      return new distance.CIEDE2000();\n    case 'color-metric':\n      return new distance.CMetric();\n    case 'euclidean':\n      return new distance.Euclidean();\n    case 'euclidean-bt709':\n      return new distance.EuclideanBT709();\n    case 'euclidean-bt709-noalpha':\n      return new distance.EuclideanBT709NoAlpha();\n    case 'manhattan':\n      return new distance.Manhattan();\n    case 'manhattan-bt709':\n      return new distance.ManhattanBT709();\n    case 'manhattan-nommyde':\n      return new distance.ManhattanNommyde();\n    case 'pngquant':\n      return new distance.PNGQuant();\n    default:\n      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);\n  }\n}\n\nfunction imageQuantizationToImageQuantizer(\n  distanceCalculator: AbstractDistanceCalculator,\n  imageQuantization: ImageQuantization = 'floyd-steinberg',\n) {\n  switch (imageQuantization) {\n    case 'nearest':\n      return new image.NearestColor(distanceCalculator);\n    case 'riemersma':\n      return new image.ErrorDiffusionRiemersma(distanceCalculator);\n    case 'floyd-steinberg':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.FloydSteinberg,\n      );\n    case 'false-floyd-steinberg':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.FalseFloydSteinberg,\n      );\n    case 'stucki':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Stucki,\n      );\n    case 'atkinson':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Atkinson,\n      );\n    case 'jarvis':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Jarvis,\n      );\n    case 'burkes':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Burkes,\n      );\n    case 'sierra':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Sierra,\n      );\n    case 'two-sierra':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.TwoSierra,\n      );\n    case 'sierra-lite':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.SierraLite,\n      );\n    default:\n      throw new Error(`Unknown imageQuantization ${imageQuantization}`);\n  }\n}\n\nfunction paletteQuantizationToPaletteQuantizer(\n  distanceCalculator: AbstractDistanceCalculator,\n  paletteQuantization: PaletteQuantization = 'wuquant',\n  colors = 256,\n) {\n  switch (paletteQuantization) {\n    case 'neuquant':\n      return new palette.NeuQuant(distanceCalculator, colors);\n    case 'rgbquant':\n      return new palette.RGBQuant(distanceCalculator, colors);\n    case 'wuquant':\n      return new palette.WuQuant(distanceCalculator, colors);\n    case 'neuquant-float':\n      return new palette.NeuQuantFloat(distanceCalculator, colors);\n    default:\n      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nimport * as constants from './constants';\nimport * as conversion from './conversion';\nimport * as distance from './distance';\nimport * as palette from './palette';\nimport * as image from './image';\nimport * as quality from './quality';\nimport * as utils from './utils';\n\nexport {\n  buildPalette,\n  buildPaletteSync,\n  applyPalette,\n  applyPaletteSync,\n} from './basicAPI';\n\nexport type {\n  ImageQuantization,\n  PaletteQuantization,\n  ColorDistanceFormula,\n} from './basicAPI';\n\nexport { constants, conversion, distance, palette, image, quality, utils };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,oBAAA,CAAA;AAAA,SAAA,mBAAA;IAAA,OAAA,IAAA;AAAA;;ACAA,IAAA,gBAAA,CAAA;AAAA,SAAA,eAAA;IAAA,GAAA,IAAA;IAAA,GAAA,IAAA;IAAA,GAAA,IAAA;AAAA;AAYO,IAAK,IAAL,aAAA,GAAA,CAAA,CAAK,OAAL;IACL,EAAA,CAAA,EAAA,CAAA,MAAA,GAAM,OAAA,GAAN;IACA,EAAA,CAAA,EAAA,CAAA,QAAA,GAAQ,OAAA,GAAR;IACA,EAAA,CAAA,EAAA,CAAA,OAAA,GAAO,OAAA,GAAP;IACA,EAAA,CAAA,EAAA,CAAA,QAAA,GAAQ,EAAA,GAAR;IAJU,OAAA;AAAA,CAAA,EAAA,KAAA,CAAA;AAOL,IAAK,IAAL,aAAA,GAAA,CAAA,CAAK,OAAL;IACL,EAAA,CAAA,EAAA,CAAA,MAAA,GAAM,KAAA,GAAN;IACA,EAAA,CAAA,EAAA,CAAA,QAAA,GAAQ,IAAA,GAAR;IACA,EAAA,CAAA,EAAA,CAAA,OAAA,GAAO,KAAA,GAAP;IACA,EAAA,CAAA,EAAA,CAAA,QAAA,GAAQ,OAAA,GAAR;IAJU,OAAA;AAAA,CAAA,EAAA,KAAA,CAAA;AAOL,IAAK,IAAL,aAAA,GAAA,CAAA,CAAK,OAAL;IACL,EAAA,CAAA,EAAA,CAAA,MAAA,GAAM,KAAA,GAAN;IACA,EAAA,CAAA,EAAA,CAAA,QAAA,GAAQ,IAAA,GAAR;IACA,EAAA,CAAA,EAAA,CAAA,OAAA,GAAO,KAAA,GAAP;IACA,EAAA,CAAA,EAAA,CAAA,QAAA,GAAQ,MAAA,GAAR;IAJU,OAAA;AAAA,CAAA,EAAA,KAAA,CAAA;;AC1BZ,IAAA,qBAAA,CAAA;AAAA,SAAA,oBAAA;IAAA,SAAA,IAAA;IAAA,SAAA,IAAA;IAAA,SAAA,IAAA;IAAA,SAAA,IAAA;IAAA,SAAA,IAAA;IAAA,SAAA,IAAA;IAAA,SAAA,IAAA;AAAA;;ACOA,SAAA,aAAsB,CAAA,EAAW;IAC/B,OAAO,IAAI,UAAY,CAAA,CAAA,IAAI,KAAA,IAAS,KAAA,KAAU,MAAM,IAAI;AAAA;AAGnD,SAAA,QAAiB,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IAEvD,IAAI,aAAa,IAAI;IACrB,IAAI,aAAa,IAAI;IACrB,IAAI,aAAa,IAAI;IAGrB,OAAO;QACL,GAAG,IAAI,SAAS,IAAI,SAAS,IAAI;QACjC,GAAG,IAAI,SAAS,IAAI,SAAS,IAAI;QACjC,GAAG,IAAI,SAAS,IAAI,SAAS,IAAI;IAAA;AAAA;;ACrBrC,IAAA,qBAAA,CAAA;AAAA,SAAA,oBAAA;IAAA,iBAAA,IAAA;IAAA,eAAA,IAAA;IAAA,sBAAA,IAAA;IAAA,YAAA,IAAA;IAAA,MAAA,IAAA;IAAA,MAAA,IAAA;IAAA,YAAA,IAAA;AAAA;AAAO,SAAA,gBAAyB,CAAA,EAAW;IACzC,OAAO,IAAK,CAAA,KAAK,EAAA,GAAK,GAAA;AAAA;AAGjB,SAAA,KAAc,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IACpD,IAAI,IAAI;IACR,IAAI,IAAI,GAAG,IAAI;IACf,IAAI,IAAI,GAAG,IAAI;IACf,OAAO;AAAA;AAGF,SAAA,KAAc,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IACpD,IAAI,IAAI;IACR,IAAI,IAAI,GAAG,IAAI;IACf,IAAI,IAAI,GAAG,IAAI;IACf,OAAO;AAAA;AAGF,SAAA,WAAoB,KAAA,EAAe,GAAA,EAAa,IAAA,EAAc;IACnE,IAAI,QAAQ,MAAM,QAAQ;IAC1B,IAAI,QAAQ,KAAK,QAAQ;IACzB,OAAO,QAAQ;AAAA;AAGV,SAAA,qBAA8B,CAAA,EAAW;IAC9C,IAAI,KAAK,KAAA,CAAM;IACf,IAAI,IAAI,KAAK,IAAI;SAAA,IACR,IAAI,GAAG,IAAI;IACpB,OAAO;AAAA;AAGF,SAAA,cAAuB,CAAA,EAAW;IACvC,IAAI,IAAI,KAAK,IAAI;SAAA,IACR,IAAI,GAAG,IAAI;IACpB,OAAO;AAAA;AAGF,SAAA,WACL,WAAA,EACA,QAAA,EACA;IACA,MAAM,OAAO,OAAO,WAAA,CAAY,EAAA;IAChC,IAAI;IAEJ,IAAI,SAAS,YAAY,SAAS,UAAU;QAC1C,MAAM,MAAM,aAAA,GAAA,OAAO,MAAA,CAAO;QAC1B,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,MAAA,EAAQ,IAAI,GAAG,IAAK;YAClD,MAAM,MAAM,WAAA,CAAY,EAAA;YACxB,IAAI,GAAA,CAAI,IAAA,IAAQ,GAAA,CAAI,IAAA,KAAS,GAAG;YAChC,GAAA,CAAI,IAAA,GAAO;QAAA;QAGb,SAAS,YAAY,IAAA,CAAK,CAAC,GAAG,IAAM,SAAS,GAAG,MAAM,GAAA,CAAI,EAAA,GAAK,GAAA,CAAI,EAAA;IAAA,OAC9D;QACL,MAAM,OAAO,YAAY,KAAA,CAAM;QAC/B,SAAS,YAAY,IAAA,CACnB,CAAC,GAAG,IAAM,SAAS,GAAG,MAAM,KAAK,OAAA,CAAQ,KAAK,KAAK,OAAA,CAAQ;IAAA;IAI/D,OAAO;AAAA;;AC5CF,SAAA,QAAiB,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IACvD,MAAM,MAAM,KAAK,GAAG,GAAG;IACvB,MAAM,MAAM,KAAK,GAAG,GAAG;IACvB,MAAM,QAAQ,MAAM;IACpB,MAAM,IAAK,CAAA,MAAM,GAAA,IAAO;IAExB,IAAI,IAAI;IACR,IAAI,IAAI,KAAK,IAAI,GAAG,IAAI,QAAS,CAAA,IAAI,MAAM,MAAM,MAAM,MAAM,MAAM,GAAA;IAEnE,IAAI,IAAI;IACR,IAAI,QAAQ,GAAG;QACb,IAAI,QAAQ,GAAG;YACb,IAAK,CAAA,IAAI,CAAA,IAAK;QAAA,OAAA,IACL,QAAQ,GAAG;YACpB,IAAI,IAAK,CAAA,IAAI,CAAA,IAAK;QAAA,OACb;YACL,IAAI,IAAK,CAAA,IAAI,CAAA,IAAK;QAAA;QAGpB,KAAK;QACL,IAAI,IAAI,GAAG,KAAK;IAAA;IAElB,OAAO;QAAE;QAAG;QAAG;IAAA;AAAA;;AC/BjB,IAAM,OAAO;AACb,IAAM,OAAO;AACb,IAAM,OAAO;AAEb,SAAA,MAAe,CAAA,EAAW;IACxB,OAAO,IAAI,UAAW,KAAM,CAAA,IAAI,CAAA,IAAK,QAAQ,IAAI,KAAK;AAAA;AAGjD,SAAA,QAAiB,EAAA,EAAW,EAAA,EAAW,CAAA,EAAW;IACvD,KAAI,MAAM,KAAI;IACd,KAAI,MAAM,KAAI;IACd,IAAI,MAAM,IAAI;IAEd,IAAI,MAAM,KAAI,KAAK,GAAG,MAAM,IAAI,MAAM;IACtC,OAAO;QACL,GAAG,KAAK,GAAA,CAAI,GAAG,MAAM,KAAI;QACzB,GAAG,MAAO,CAAA,KAAI,EAAA;QACd,GAAG,MAAO,CAAA,KAAI,CAAA;IAAA;AAAA;;ACdX,SAAA,QAAiB,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IACvD,MAAM,MAAM,QAAQ,GAAG,GAAG;IAC1B,OAAO,QAAQ,IAAI,CAAA,EAAG,IAAI,CAAA,EAAG,IAAI,CAAA;AAAA;;ACLnC,IAAM,QAAO;AACb,IAAM,QAAO;AACb,IAAM,QAAO;AAEb,SAAA,OAAe,CAAA,EAAW;IACxB,OAAO,IAAI,cAAc,KAAK,IAAK,CAAA,IAAI,KAAK,GAAA,IAAO;AAAA;AAG9C,SAAA,QAAiB,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IACvD,MAAM,KAAK,CAAA,IAAI,EAAA,IAAM;IACrB,MAAM,KAAI,IAAI,MAAM;IACpB,MAAM,IAAI,KAAI,IAAI;IAElB,OAAO;QACL,GAAG,QAAO,OAAM;QAChB,GAAG,QAAO,OAAM;QAChB,GAAG,QAAO,OAAM;IAAA;AAAA;;ACbpB,SAAA,cAAsB,CAAA,EAAW;IAC/B,OAAO,IAAI,WAAY,QAAQ,KAAM,CAAA,IAAI,GAAA,IAAO,QAAQ,QAAQ;AAAA;AAG3D,SAAA,QAAiB,EAAA,EAAW,EAAA,EAAW,CAAA,EAAW;IAEvD,MAAM,IAAI,cAAa,KAAI,SAAS,KAAI,CAAA,SAAU,IAAI,CAAA;IACtD,MAAM,IAAI,cAAa,KAAI,CAAA,SAAU,KAAI,SAAS,IAAI;IACtD,MAAM,IAAI,cAAa,KAAI,SAAS,KAAI,CAAA,QAAS,IAAI;IAErD,OAAO;QACL,GAAG,qBAAqB,IAAI;QAC5B,GAAG,qBAAqB,IAAI;QAC5B,GAAG,qBAAqB,IAAI;IAAA;AAAA;;ACbzB,SAAA,QAAiB,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IACvD,MAAM,MAAM,QAAQ,GAAG,GAAG;IAC1B,OAAO,QAAQ,IAAI,CAAA,EAAG,IAAI,CAAA,EAAG,IAAI,CAAA;AAAA;;ACZnC,IAAA,mBAAA,CAAA;AAAA,SAAA,kBAAA;IAAA,4BAAA,IAAA;IAAA,mBAAA,IAAA;IAAA,mBAAA,IAAA;IAAA,kBAAA,IAAA;IAAA,eAAA,IAAA;IAAA,WAAA,IAAA;IAAA,SAAA,IAAA;IAAA,WAAA,IAAA;IAAA,gBAAA,IAAA;IAAA,uBAAA,IAAA;IAAA,WAAA,IAAA;IAAA,gBAAA,IAAA;IAAA,kBAAA,IAAA;IAAA,UAAA,IAAA;AAAA;;ACSO,IAAA,6BAAA,MAA0C;IAS/C,aAAc;QARJ,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAQR,IAAA,CAAK,YAAA;QAGL,IAAA,CAAK,aAAA,CAAc,KAAK,KAAK,KAAK;IAAA;IAGpC,cAAc,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;QACxD,IAAA,CAAK,WAAA,GAAc;YACjB,GAAG,IAAI,IAAI,MAAM,IAAI;YACrB,GAAG,IAAI,IAAI,MAAM,IAAI;YACrB,GAAG,IAAI,IAAI,MAAM,IAAI;YACrB,GAAG,IAAI,IAAI,MAAM,IAAI;QAAA;QAEvB,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,YAAA,CAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;IAAA;IAG7D,oBAAoB,MAAA,EAAmB,MAAA,EAAmB;QACxD,OACE,IAAA,CAAK,YAAA,CACH,OAAO,CAAA,EACP,OAAO,CAAA,EACP,OAAO,CAAA,EACP,OAAO,CAAA,EACP,OAAO,CAAA,EACP,OAAO,CAAA,EACP,OAAO,CAAA,EACP,OAAO,CAAA,IACL,IAAA,CAAK,YAAA;IAAA;AAAA;;AC/BR,IAAA,gBAAA,cAAqC,2BAA2B;IAWrE,aACE,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA;QACA,MAAM,OAAO,QACX,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,GACpC,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,GACpC,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA;QAEtC,MAAM,OAAO,QACX,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,GACpC,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,GACpC,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA;QAGtC,MAAM,KAAK,KAAK,CAAA,GAAI,KAAK,CAAA;QACzB,MAAM,KAAK,KAAK,CAAA,GAAI,KAAK,CAAA;QACzB,MAAM,KAAK,KAAK,CAAA,GAAI,KAAK,CAAA;QACzB,MAAM,KAAK,KAAK,IAAA,CAAK,KAAK,CAAA,GAAI,KAAK,CAAA,GAAI,KAAK,CAAA,GAAI,KAAK,CAAA;QACrD,MAAM,KAAK,KAAK,IAAA,CAAK,KAAK,CAAA,GAAI,KAAK,CAAA,GAAI,KAAK,CAAA,GAAI,KAAK,CAAA;QACrD,MAAM,KAAK,KAAK;QAEhB,IAAI,SAAS,KAAK,KAAK,KAAK,KAAK,KAAK;QACtC,SAAS,SAAS,IAAI,IAAI,KAAK,IAAA,CAAK;QAEpC,MAAM,SAAU,CAAA,KAAK,EAAA,IAAM,IAAA,CAAK,WAAA,CAAY,CAAA,GAAI,IAAA,CAAK,GAAA;QAGrD,OAAO,KAAK,IAAA,CACT,CAAA,KAAK,IAAA,CAAK,GAAA,KAAQ,IAChB,CAAA,KAAM,CAAA,IAAM,IAAA,CAAK,GAAA,GAAM,EAAA,CAAA,KAAQ,IAC/B,CAAA,SAAU,CAAA,IAAM,IAAA,CAAK,GAAA,GAAM,EAAA,CAAA,KAAQ,IACpC,UAAU;IAAA;AAAA;AAKX,IAAA,gBAAA,cAA4B,cAAc;IACrC,eAAe;QACvB,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAO,OAAO,KAAM;IAAA;AAAA;AAItB,IAAA,mBAAA,cAA+B,cAAc;IACxC,eAAe;QACvB,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAO,OAAO,MAAO;IAAA;AAAA;;ACpEvB,IAAA,aAAA,cAAwB,2BAA2B;IAgB9C,eAAe,CAAA;IAAA,OAEV,aAAa,CAAA,EAAW,EAAA,EAAY;QACjD,MAAM,KAAK,KAAK,KAAA,CAAM,GAAG;QACzB,IAAI,MAAM,GAAG,OAAO;QACpB,OAAO,KAAK,WAAU,YAAA;IAAA;IAAA,OAGT,aAAa,GAAA,EAAa,GAAA,EAAa;QACpD,MAAM,WAAW,OAAO;QACxB,MAAM,MAAM,IAAM,KAAK,IAAA,CAAK,WAAY,CAAA,WAAW,WAAU,SAAA;QAC7D,MAAM,cACJ,WAAU,WAAA,GACV,KAAK,GAAA,CACH,CAAI,CAAA,CAAA,CAAA,MAAM,WAAU,YAAA,IAAgB,WAAU,WAAA,KAAgB,CAAA;QAElE,OAAO,CAAC,KAAK,GAAA,CAAI,IAAM,eAAe;IAAA;IAAA,OAGzB,YAAY,GAAA,EAAa;QACtC,OACE,IACA,OAAO,KAAK,GAAA,CAAI,MAAM,WAAU,WAAA,IAChC,OAAO,KAAK,GAAA,CAAI,MAAM,KACtB,OAAO,KAAK,GAAA,CAAI,MAAM,IAAM,WAAU,UAAA,IACtC,MAAM,KAAK,GAAA,CAAI,MAAM,IAAM,WAAU,WAAA;IAAA;IAAA,OAI1B,eACb,MAAA,EACA,KAAA,EACA,GAAA,EACA,GAAA,EACA;QACA,MAAM,QAAQ,MAAM;QACpB,IAAI,WAAW,GAAG,OAAO;QACzB,IAAI,SAAS,WAAU,YAAA,EAAc,OAAO,QAAQ;QACpD,IAAI,QAAQ,WAAU,YAAA,EAAc;YAClC,OAAQ,CAAA,QAAQ,WAAU,YAAA,IAAgB;QAAA;QAE5C,OAAQ,CAAA,QAAQ,WAAU,YAAA,IAAgB;IAAA;IAAA,OAG7B,eACb,MAAA,EACA,KAAA,EACA,GAAA,EACA,GAAA,EACA;QACA,IAAI;QACJ,IAAI,WAAW,GAAG;YAChB,MAAM;QAAA,OAAA,IACG,SAAS,WAAU,YAAA,EAAc;YAC1C,MAAM,MAAM;QAAA,OAAA,IACH,OAAO,KAAK;YACrB,MAAM,MAAM,MAAM,WAAU,YAAA;QAAA,OACvB;YACL,MAAM,MAAM,MAAM,WAAU,YAAA;QAAA;QAE9B,OAAO,IAAM,KAAK,IAAA,CAAK,UAAU,KAAK,GAAA,CAAI,MAAM;IAAA;IAGlD,aACE,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA;QACA,MAAM,OAAO,QACX,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,GACpC,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,GACpC,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA;QAEtC,MAAM,OAAO,QACX,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,GACpC,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,GACpC,cAAc,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA;QAEtC,MAAM,KAAM,CAAA,KAAK,EAAA,IAAM,IAAA,CAAK,WAAA,CAAY,CAAA,GAAI,WAAU,GAAA;QACtD,MAAM,MAAM,IAAA,CAAK,iBAAA,CAAkB,MAAM;QAEzC,OAAO,KAAK,IAAA,CAAK,MAAM,KAAK;IAAA;IAG9B,kBACE,IAAA,EACA,IAAA,EACA;QAEA,MAAM,KAAK,KAAK,CAAA;QAChB,MAAM,KAAK,KAAK,CAAA;QAChB,MAAM,KAAK,KAAK,CAAA;QAGhB,MAAM,KAAK,KAAK,CAAA;QAChB,MAAM,KAAK,KAAK,CAAA;QAChB,MAAM,KAAK,KAAK,CAAA;QAGhB,MAAM,KAAK,KAAK,IAAA,CAAK,KAAK,KAAK,KAAK;QACpC,MAAM,KAAK,KAAK,IAAA,CAAK,KAAK,KAAK,KAAK;QACpC,MAAM,mBAAqB,CAAA,CAAA,KAAK,EAAA,IAAM,CAAA,KAAQ;QAE9C,MAAM,IACJ,MACC,CAAA,IACC,KAAK,IAAA,CAAK,mBAAoB,CAAA,mBAAmB,WAAU,SAAA,EAAA;QAC/D,MAAM,MAAO,CAAA,IAAM,CAAA,IAAK;QACxB,MAAM,MAAO,CAAA,IAAM,CAAA,IAAK;QAExB,MAAM,MAAM,KAAK,IAAA,CAAK,MAAM,MAAM,KAAK;QACvC,MAAM,MAAM,KAAK,IAAA,CAAK,MAAM,MAAM,KAAK;QACvC,MAAM,SAAS,MAAM;QAGrB,MAAM,MAAM,WAAU,YAAA,CAAa,IAAI;QACvC,MAAM,MAAM,WAAU,YAAA,CAAa,IAAI;QACvC,MAAM,QAAQ,KAAK,GAAA,CAAI,MAAM;QAC7B,MAAM,MAAM,KAAK;QACjB,MAAM,MAAM,MAAM;QAClB,MAAM,MAAM,WAAU,cAAA,CAAe,QAAQ,OAAO,KAAK;QACzD,MAAM,MAAM,WAAU,cAAA,CAAe,QAAQ,OAAO,KAAK;QAEzD,MAAM,IAAI,WAAU,WAAA,CAAY;QAEhC,MAAM,MAAO,CAAA,MAAM,GAAA,IAAO;QAC1B,MAAM,sBAAwB,CAAA,CAAA,KAAK,EAAA,IAAM,IAAM,EAAA,KAAS;QACxD,MAAM,MACJ,IACC,QAAQ,sBAAuB,KAAK,IAAA,CAAK,KAAO;QACnD,MAAM,MAAM,IAAM,QAAQ;QAC1B,MAAM,MAAM,IAAM,QAAQ,IAAI;QAE9B,MAAM,MAAM,WAAU,YAAA,CAAa,KAAK;QAExC,MAAM,QAAQ,MAAM;QACpB,MAAM,QAAQ,MAAM;QACpB,MAAM,QAAQ,MAAM;QAEpB,OAAO,SAAS,IAAI,SAAS,IAAI,SAAS,IAAI,MAAM,QAAQ;IAAA;AAAA;AAhKzD,IAAA,YAAA;AAMmB,cANnB,WAMmB,OAAO,OAAO,MAAO;AACrB,cAPnB,WAOmB,aAAY,MAAM;AAClB,cARnB,WAQmB,gBAAe,gBAAgB;AAC/B,cATnB,WASmB,gBAAe,gBAAgB;AAC/B,cAVnB,WAUmB,eAAc,gBAAgB;AAC9B,cAXnB,WAWmB,cAAa,gBAAgB;AAC7B,cAZnB,WAYmB,eAAc,gBAAgB;AAC9B,cAbnB,WAamB,gBAAe,gBAAgB;AAC/B,cAdnB,WAcmB,eAAc,gBAAgB;;ACjBjD,IAAA,UAAA,cAAsB,2BAA2B;IACtD,aACE,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA;QACA,MAAM,QAAU,CAAA,KAAK,EAAA,IAAM,IAAK,IAAA,CAAK,WAAA,CAAY,CAAA;QACjD,MAAM,IAAK,CAAA,KAAK,EAAA,IAAM,IAAA,CAAK,WAAA,CAAY,CAAA;QACvC,MAAM,IAAK,CAAA,KAAK,EAAA,IAAM,IAAA,CAAK,WAAA,CAAY,CAAA;QACvC,MAAM,IAAK,CAAA,KAAK,EAAA,IAAM,IAAA,CAAK,WAAA,CAAY,CAAA;QACvC,MAAM,KACD,CAAA,CAAA,MAAM,KAAA,IAAS,IAAI,KAAM,CAAA,IAC5B,IAAI,IAAI,IACL,CAAA,CAAA,MAAM,KAAA,IAAS,IAAI,KAAM,CAAA;QAC9B,MAAM,KAAM,CAAA,KAAK,EAAA,IAAM,IAAA,CAAK,WAAA,CAAY,CAAA;QAExC,OAAO,KAAK,IAAA,CAAK,KAAK,KAAK;IAAA;IAGnB,eAAe,CAAA;AAAA;;ACvBpB,IAAA,oBAAA,cAAyC,2BAA2B;IAMzE,aACE,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA;QACA,MAAM,KAAK,KAAK;QAChB,MAAM,KAAK,KAAK;QAChB,MAAM,KAAK,KAAK;QAChB,MAAM,KAAK,KAAK;QAChB,OAAO,KAAK,IAAA,CACV,IAAA,CAAK,GAAA,GAAM,KAAK,KACd,IAAA,CAAK,GAAA,GAAM,KAAK,KAChB,IAAA,CAAK,GAAA,GAAM,KAAK,KAChB,IAAA,CAAK,GAAA,GAAM,KAAK;IAAA;AAAA;AAKjB,IAAA,YAAA,cAAwB,kBAAkB;IACrC,eAAe;QACvB,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;IAAA;AAAA;AAOR,IAAA,iBAAA,cAA6B,kBAAkB;IAC1C,eAAe;QACvB,IAAA,CAAK,GAAA,GAAM,OAAA,OAAA;QACX,IAAA,CAAK,GAAA,GAAM,OAAA,SAAA;QACX,IAAA,CAAK,GAAA,GAAM,OAAA,QAAA;QAEX,IAAA,CAAK,GAAA,GAAM;IAAA;AAAA;AAOR,IAAA,wBAAA,cAAoC,kBAAkB;IACjD,eAAe;QACvB,IAAA,CAAK,GAAA,GAAM,OAAA,OAAA;QACX,IAAA,CAAK,GAAA,GAAM,OAAA,SAAA;QACX,IAAA,CAAK,GAAA,GAAM,OAAA,QAAA;QACX,IAAA,CAAK,GAAA,GAAM;IAAA;AAAA;;AC3DR,IAAA,oBAAA,cAAyC,2BAA2B;IAMzE,aACE,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA;QACA,IAAI,KAAK,KAAK;QACd,IAAI,KAAK,KAAK;QACd,IAAI,KAAK,KAAK;QACd,IAAI,KAAK,KAAK;QACd,IAAI,KAAK,GAAG,KAAK,IAAI;QACrB,IAAI,KAAK,GAAG,KAAK,IAAI;QACrB,IAAI,KAAK,GAAG,KAAK,IAAI;QACrB,IAAI,KAAK,GAAG,KAAK,IAAI;QAErB,OAAO,IAAA,CAAK,GAAA,GAAM,KAAK,IAAA,CAAK,GAAA,GAAM,KAAK,IAAA,CAAK,GAAA,GAAM,KAAK,IAAA,CAAK,GAAA,GAAM;IAAA;AAAA;AAI/D,IAAA,YAAA,cAAwB,kBAAkB;IACrC,eAAe;QACvB,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;IAAA;AAAA;AAQR,IAAA,mBAAA,cAA+B,kBAAkB;IAC5C,eAAe;QACvB,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,GAAA,GAAM;QAEX,IAAA,CAAK,GAAA,GAAM;IAAA;AAAA;AAOR,IAAA,iBAAA,cAA6B,kBAAkB;IAC1C,eAAe;QACvB,IAAA,CAAK,GAAA,GAAM,OAAA,OAAA;QACX,IAAA,CAAK,GAAA,GAAM,OAAA,SAAA;QACX,IAAA,CAAK,GAAA,GAAM,OAAA,QAAA;QAEX,IAAA,CAAK,GAAA,GAAM;IAAA;AAAA;;AC1DR,IAAA,WAAA,cAAuB,2BAA2B;IAiBvD,aACE,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA,EAAA,EACA;QACA,MAAM,SAAU,CAAA,KAAK,EAAA,IAAM,IAAA,CAAK,WAAA,CAAY,CAAA;QAC5C,OACE,IAAA,CAAK,kBAAA,CACH,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,EACtB,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,EACtB,UAEF,IAAA,CAAK,kBAAA,CACH,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,EACtB,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,EACtB,UAEF,IAAA,CAAK,kBAAA,CACH,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,EACtB,KAAK,IAAA,CAAK,WAAA,CAAY,CAAA,EACtB;IAAA;IAKE,mBAAmB,EAAA,EAAW,EAAA,EAAW,MAAA,EAAgB;QAG/D,MAAM,QAAQ,KAAI;QAClB,MAAM,QAAQ,QAAQ;QAEtB,OAAO,QAAQ,QAAQ,QAAQ;IAAA;IAGvB,eAAe,CAAA;AAAA;;ACxE3B,IAAA,kBAAA,CAAA;AAAA,SAAA,iBAAA;IAAA,0BAAA,IAAA;IAAA,gBAAA,IAAA;IAAA,UAAA,IAAA;IAAA,eAAA,IAAA;IAAA,UAAA,IAAA;IAAA,aAAA,IAAA;IAAA,SAAA,IAAA;AAAA;;ACUO,IAAA,2BAAA,MAAwC;IAI7C,eAAe;QACb,KAAA,MAAW,SAAS,IAAA,CAAK,QAAA,GAAY;YACnC,IAAI,MAAM,OAAA,EAAS;gBACjB,OAAO,MAAM,OAAA;YAAA;QAAA;QAIjB,MAAM,IAAI,MAAM;IAAA;AAAA;;ACAb,IAAA,QAAA,MAAiC;IA6CtC,aAAc;QA5Cd,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAwCE,IAAA,CAAK,MAAA,GAAS,CAAA,MAAO;QACrB,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI;QACpC,IAAA,CAAK,IAAA,GAAO,IAAI,MAAM;QACtB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK;QACf,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK;QACf,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK;QACf,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK;IAAA;IAAA,OA3CV,mBAAmB,UAAA,EAAsB;QAC9C,MAAM,QAAQ,IAAI;QAElB,MAAM,CAAA,GAAI,UAAA,CAAW,EAAA,GAAK;QAC1B,MAAM,CAAA,GAAI,UAAA,CAAW,EAAA,GAAK;QAC1B,MAAM,CAAA,GAAI,UAAA,CAAW,EAAA,GAAK;QAC1B,MAAM,CAAA,GAAI,UAAA,CAAW,EAAA,GAAK;QAC1B,MAAM,WAAA;QACN,MAAM,eAAA;QAEN,OAAO;IAAA;IAAA,OAGF,aAAa,GAAA,EAAa,KAAA,EAAe,IAAA,EAAc,KAAA,EAAe;QAC3E,MAAM,QAAQ,IAAI;QAElB,MAAM,CAAA,GAAI,MAAM;QAChB,MAAM,CAAA,GAAI,QAAQ;QAClB,MAAM,CAAA,GAAI,OAAO;QACjB,MAAM,CAAA,GAAI,QAAQ;QAClB,MAAM,WAAA;QACN,MAAM,eAAA;QAEN,OAAO;IAAA;IAAA,OAGF,eAAe,MAAA,EAAgB;QACpC,MAAM,QAAQ,IAAI;QAElB,MAAM,MAAA,GAAS,WAAW;QAC1B,MAAM,SAAA;QACN,MAAM,eAAA;QAEN,OAAO;IAAA;IAoBT,KAAK,KAAA,EAAc;QACjB,IAAA,CAAK,CAAA,GAAI,MAAM,CAAA;QACf,IAAA,CAAK,CAAA,GAAI,MAAM,CAAA;QACf,IAAA,CAAK,CAAA,GAAI,MAAM,CAAA;QACf,IAAA,CAAK,CAAA,GAAI,MAAM,CAAA;QACf,IAAA,CAAK,MAAA,GAAS,MAAM,MAAA;QACpB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,MAAM,CAAA;QACrB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,MAAM,CAAA;QACrB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,MAAM,CAAA;QACrB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,MAAM,CAAA;IAAA;IAiBvB,cAAc,eAAA,EAA0B;QACtC,IAAI,IAAI,IAAA,CAAK,CAAA;QACb,IAAI,IAAI,IAAA,CAAK,CAAA;QACb,IAAI,IAAI,IAAA,CAAK,CAAA;QAEb,IAAI,iBAAiB;YACnB,IAAI,KAAK,GAAA,CAAI,KAAK,MAAM,IAAA,CAAK,CAAA,GAAK,IAAA,CAAK,CAAA,GAAI,IAAK;YAChD,IAAI,KAAK,GAAA,CAAI,KAAK,MAAM,IAAA,CAAK,CAAA,GAAK,IAAA,CAAK,CAAA,GAAI,IAAK;YAChD,IAAI,KAAK,GAAA,CAAI,KAAK,MAAM,IAAA,CAAK,CAAA,GAAK,IAAA,CAAK,CAAA,GAAI,IAAK;QAAA;QAWlD,OAAO,IAAI,OAAA,OAAA,MAAQ,IAAI,OAAA,SAAA,MAAU,IAAI,OAAA,QAAA;IAAA;IAG/B,cAAc;QACpB,IAAA,CAAK,MAAA,GACD,CAAA,IAAA,CAAK,CAAA,IAAK,KAAO,IAAA,CAAK,CAAA,IAAK,KAAO,IAAA,CAAK,CAAA,IAAK,IAAK,IAAA,CAAK,CAAA,MAAO;IAAA;IAG3D,YAAY;QAClB,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,MAAA,GAAS;QACvB,IAAA,CAAK,CAAA,GAAK,IAAA,CAAK,MAAA,KAAW,IAAK;QAC/B,IAAA,CAAK,CAAA,GAAK,IAAA,CAAK,MAAA,KAAW,KAAM;QAChC,IAAA,CAAK,CAAA,GAAK,IAAA,CAAK,MAAA,KAAW,KAAM;IAAA;IAG1B,kBAAkB;QACxB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,IAAA,CAAK,CAAA;QACpB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,IAAA,CAAK,CAAA;QACpB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,IAAA,CAAK,CAAA;QACpB,IAAA,CAAK,IAAA,CAAK,EAAA,GAAK,IAAA,CAAK,CAAA;IAAA;AAAA;;ACtIjB,IAAA,iBAAA,MAAqB;IAK1B,aAAc;QAJG,cAAA,IAAA,EAAA;QACT,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAGN,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,OAAA,GAAU;QACf,IAAA,CAAK,WAAA,GAAc,EAAA;IAAA;IAGrB,WAAW;QACT,OAAO,IAAA,CAAK,MAAA;IAAA;IAGd,YAAY;QACV,OAAO,IAAA,CAAK,OAAA;IAAA;IAGd,SAAS,KAAA,EAAe;QACtB,IAAA,CAAK,MAAA,GAAS;IAAA;IAGhB,UAAU,MAAA,EAAgB;QACxB,IAAA,CAAK,OAAA,GAAU;IAAA;IAGjB,gBAAgB;QACd,OAAO,IAAA,CAAK,WAAA;IAAA;IAGd,QAAQ;QACN,MAAM,QAAQ,IAAI;QAClB,MAAM,MAAA,GAAS,IAAA,CAAK,MAAA;QACpB,MAAM,OAAA,GAAU,IAAA,CAAK,OAAA;QAErB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,WAAA,CAAY,MAAA,EAAQ,IAAI,GAAG,IAAK;YACvD,MAAM,WAAA,CAAY,EAAA,GAAK,MAAM,cAAA,CAC3B,IAAA,CAAK,WAAA,CAAY,EAAA,CAAG,MAAA,GAAS;QAAA;QAIjC,OAAO;IAAA;IAGT,gBAAgB;QACd,MAAM,IAAI,IAAA,CAAK,WAAA,CAAY,MAAA;QAC3B,MAAM,cAAc,IAAI,YAAY;QAEpC,IAAA,IAAS,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,WAAA,CAAY,EAAA,GAAK,IAAA,CAAK,WAAA,CAAY,EAAA,CAAG,MAAA;QAAA;QAGvC,OAAO;IAAA;IAGT,eAAe;QACb,OAAO,IAAI,WAAW,IAAA,CAAK,aAAA,GAAgB,MAAA;IAAA;IAAA,OAGtC,qBAAqB,GAAA,EAAuB;QACjD,MAAM,QAAQ,IAAI,YAAA;QAClB,MAAM,SAAS,IAAI,aAAA;QAEnB,MAAM,SAAS,SAAS,aAAA,CAAc;QACtC,OAAO,KAAA,GAAQ;QACf,OAAO,MAAA,GAAS;QAEhB,MAAM,MAAM,OAAO,UAAA,CAAW;QAC9B,IAAI,SAAA,CAAU,KAAK,GAAG,GAAG,OAAO,QAAQ,GAAG,GAAG,OAAO;QAErD,OAAO,eAAe,qBAAA,CAAsB;IAAA;IAAA,OAGvC,sBAAsB,MAAA,EAA2B;QACtD,MAAM,QAAQ,OAAO,KAAA;QACrB,MAAM,SAAS,OAAO,MAAA;QAEtB,MAAM,MAAM,OAAO,UAAA,CAAW;QAC9B,MAAM,UAAU,IAAI,YAAA,CAAa,GAAG,GAAG,OAAO;QAE9C,OAAO,eAAe,aAAA,CAAc;IAAA;IAAA,OAG/B,cAAc,SAAA,EAAsB;QACzC,MAAM,QAAQ,UAAU,KAAA;QACxB,MAAM,SAAS,UAAU,MAAA;QAEzB,OAAO,eAAe,cAAA,CAAe,UAAU,IAAA,EAAM,OAAO;IAAA;IAAA,OAGvD,eACL,UAAA,EACA,KAAA,EACA,MAAA,EACA;QACA,OAAQ,OAAO,SAAA,CAAU,QAAA,CAAS,IAAA,CAAK;YAAA,KAChC;YAAA,KACA;gBACH;YAAA;gBAGA,aAAa,IAAI,WAAW;QAAA;QAGhC,MAAM,cAAc,IAAI,YAAa,WAA0B,MAAA;QAC/D,OAAO,eAAe,eAAA,CAAgB,aAAa,OAAO;IAAA;IAAA,OAGrD,gBACL,WAAA,EACA,KAAA,EACA,MAAA,EACA;QACA,MAAM,YAAY,IAAI;QAEtB,UAAU,MAAA,GAAS;QACnB,UAAU,OAAA,GAAU;QAEpB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,MAAA,EAAQ,IAAI,GAAG,IAAK;YAClD,UAAU,WAAA,CAAY,EAAA,GAAK,MAAM,cAAA,CAAe,WAAA,CAAY,EAAA,GAAK;QAAA;QAGnE,OAAO;IAAA;IAAA,OAGF,WAAW,MAAA,EAAgB,KAAA,EAAe,MAAA,EAAgB;QAC/D,MAAM,cAAc,IAAI,YACtB,OAAO,MAAA,EACP,OAAO,UAAA,EACP,OAAO,UAAA,GAAa,YAAY,iBAAA;QAElC,OAAO,eAAe,eAAA,CAAgB,aAAa,OAAO;IAAA;AAAA;;AClI9D,IAAM,YAAY;AAEX,SAAA,SAAkB,GAAA,EAAa,cAAA,EAAwB;IAC5D,MAAM,SAAS;IACf,MAAM,MAAM,SAAS;IACrB,MAAM,OAAO,MAAM;IAEnB,IAAA,IAAS,IAAI,GAAG,MAAM,MAAM,MAAM,IAAI,gBAAgB,KAAK,OAAO,IAAK;QACrE,IAAI,OAAO,OAAO,MAAM,MAAM,KAAK,OAAO;IAAA;IAE5C,OAAO;AAAA;AAGF,IAAA,UAAA,MAAc;IAKnB,aAAc;QAJG,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA,eAAuB,EAAA;QAChC,cAAA,IAAA,EAAA,WAAqC,CAAA;QAG3C,IAAA,CAAK,eAAA,GAAkB,IAAI;QAC3B,IAAA,CAAK,eAAA,CAAgB,SAAA,CAAU;QAC/B,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,eAAA,CAAgB,aAAA;IAAA;IAG1C,IAAI,KAAA,EAAc;QAChB,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK;QACtB,IAAA,CAAK,eAAA,CAAgB,QAAA,CAAS,IAAA,CAAK,WAAA,CAAY,MAAA;IAAA;IAGjD,IAAI,KAAA,EAAc;QAChB,IAAA,IAAS,IAAI,IAAA,CAAK,WAAA,CAAY,MAAA,GAAS,GAAG,KAAK,GAAG,IAAK;YACrD,IAAI,MAAM,MAAA,KAAW,IAAA,CAAK,WAAA,CAAY,EAAA,CAAG,MAAA,EAAQ,OAAO;QAAA;QAG1D,OAAO;IAAA;IAIT,gBACE,uBAAA,EACA,KAAA,EACA;QACA,OAAO,IAAA,CAAK,WAAA,CACV,IAAA,CAAK,gBAAA,CAAiB,yBAAyB,SAAS,EAAA;IAAA;IAI5D,oBAAoB;QAClB,OAAO,IAAA,CAAK,eAAA;IAAA;IAiCN,uBAAuB,GAAA,EAAa;QAC1C,OAAO,OAAO,IAAA,CAAK,OAAA,CAAQ,IAAA,KAAS,WAAW,IAAA,CAAK,OAAA,CAAQ,IAAA,GAAO,CAAA;IAAA;IAG7D,iBACN,uBAAA,EACA,KAAA,EACA;QACA,IAAI,MAAM,IAAA,CAAK,sBAAA,CAAuB,KAAK,MAAM,MAAA;QACjD,IAAI,OAAO,GAAG,OAAO;QAErB,IAAI,kBAAkB,OAAO,SAAA;QAE7B,MAAM;QACN,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,WAAA,CAAY,MAAA,EAAQ,IAAI,GAAG,IAAK;YACvD,MAAM,IAAI,IAAA,CAAK,WAAA,CAAY,EAAA;YAC3B,MAAM,WAAW,wBAAwB,YAAA,CACvC,MAAM,CAAA,EACN,MAAM,CAAA,EACN,MAAM,CAAA,EACN,MAAM,CAAA,EACN,EAAE,CAAA,EACF,EAAE,CAAA,EACF,EAAE,CAAA,EACF,EAAE,CAAA;YAGJ,IAAI,WAAW,iBAAiB;gBAC9B,kBAAkB;gBAClB,MAAM;YAAA;QAAA;QAIV,IAAA,CAAK,OAAA,CAAQ,MAAM,MAAA,CAAA,GAAU;QAC7B,OAAO;IAAA;IAsDT,OAAO;QACL,IAAA,CAAK,OAAA,GAAU,CAAA;QACf,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,CAAC,GAAU,MAAa;YAC5C,MAAM,OAAO,QAAQ,EAAE,CAAA,EAAG,EAAE,CAAA,EAAG,EAAE,CAAA;YACjC,MAAM,OAAO,QAAQ,EAAE,CAAA,EAAG,EAAE,CAAA,EAAG,EAAE,CAAA;YAGjC,MAAM,OACJ,EAAE,CAAA,KAAM,EAAE,CAAA,IAAK,EAAE,CAAA,KAAM,EAAE,CAAA,GAAI,IAAI,IAAI,SAAS,KAAK,CAAA,EAAG;YACxD,MAAM,OACJ,EAAE,CAAA,KAAM,EAAE,CAAA,IAAK,EAAE,CAAA,KAAM,EAAE,CAAA,GAAI,IAAI,IAAI,SAAS,KAAK,CAAA,EAAG;YAMxD,MAAM,UAAU,OAAO;YACvB,IAAI,SAAS,OAAO,CAAC;YAMrB,MAAM,KAAK,EAAE,aAAA,CAAc;YAC3B,MAAM,KAAK,EAAE,aAAA,CAAc;YAE3B,IAAI,KAAK,OAAO,GAAG,OAAO,KAAK;YAE/B,MAAM,UAAY,CAAA,KAAK,CAAA,GAAI,MAAO,CAAA,IAAO,CAAA,KAAK,CAAA,GAAI,MAAO,CAAA;YACzD,IAAI,SAAS,OAAO,CAAC;YAErB,OAAO;QAAA;IAAA;AAAA;;ACvNb,IAAA,gBAAA,CAAA;AAAA,SAAA,eAAA;IAAA,eAAA,IAAA;IAAA,SAAA,IAAA;IAAA,OAAA,IAAA;IAAA,gBAAA,IAAA;IAAA,iBAAA,IAAA;IAAA,YAAA,IAAA;AAAA;;ACUA,IAAA,WAAA,MAAe;IAAf,aAVA;QAWE,cAAA,IAAA,EAAA,OAAM;QACN,cAAA,IAAA,EAAA,QAAiB,EAAA;IAAA;AAAA;AAGZ,IAAA,gBAAA,MAAoB;IAMzB,YAAY,SAAA,EAAmB,OAAA,CAAiB;QALxC,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAGN,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,QAAA,GAAW;QAChB,IAAA,CAAK,MAAA,GAAS,EAAA;QAEd,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,IAAK;YACnC,IAAA,CAAK,MAAA,CAAO,EAAA,GAAK,IAAI;QAAA;QAGvB,IAAA,CAAK,WAAA,GAAc;IAAA;IAGrB,MAAM,GAAA,EAAa;QACjB,IAAI,IAAA,CAAK,WAAA,KAAgB,IAAA,CAAK,UAAA,GAAa,GAAG;YAC5C,IAAA,CAAK,KAAA,GAAQ,KAAM,CAAA;QAAA;QAGrB,MAAM,IAAI,MAAM;QAChB,MAAM,IAAK,QAAQ,IAAK;QACxB,MAAM,IAAK,QAAQ,KAAM;QACzB,MAAM,KACJ,MAAM,KAAK,MAAM,IACb,IACA,IAAI,SAAS,QAAQ,GAAG,GAAG,GAAG,CAAA,EAAG,IAAA,CAAK,UAAA;QAC5C,MAAM,KAAK,IAAA,CAAK,MAAA,CAAO,GAAA;QACvB,MAAM,MAAM,IAAA,CAAK,QAAA;QAEjB,GAAG,GAAA;QAEH,IAAI,GAAG,GAAA,GAAM,KAAK;YAChB;QAAA;QAEF,IAAI,GAAG,GAAA,KAAQ,KAAK;YAClB,IAAA,CAAK,WAAA;QAAA;QAGP,IAAI,GAAG,GAAA,IAAO,KAAK;YACjB,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,IAAA,CAAK,IAAA,CAAK;QAAA;IAAA;IAI9B,qBAAqB,KAAA,EAA+B;QAClD,IAAA,IAAS,IAAI,GAAG,KAAK,IAAA,CAAK,UAAA,EAAY,IAAK;YACzC,IAAI,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,GAAA,IAAO,IAAA,CAAK,QAAA,EAAU;gBACvC,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,IAAA,CAAK,OAAA,CAAQ,CAAC,QAAgB;oBAC3C,IAAI,CAAC,KAAA,CAAM,IAAA,EAAM;wBACf,KAAA,CAAM,IAAA,GAAO;oBAAA,OACR;wBACL,KAAA,CAAM,IAAA;oBAAA;gBAAA;YAAA;QAAA;IAAA;IAOhB,gBAAgB,KAAA,EAAiB;QAC/B,IAAA,IAAS,IAAI,GAAG,KAAK,IAAA,CAAK,UAAA,EAAY,IAAK;YACzC,IAAI,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,GAAA,IAAO,IAAA,CAAK,QAAA,EAAU;gBACvC,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,IAAA,CAAK,OAAA,CAAQ,CAAC,QAAiB;oBAC5C,IAAI,MAAM,OAAA,CAAQ,SAAmB,CAAA,GAAI;wBACvC,MAAM,IAAA,CAAK;oBAAA;gBAAA;YAAA;QAAA;IAAA;AAAA;;ACjFhB,IAAA,mBAAA,MAAsB;IAU3B,YAAY,UAAA,EAAoB,aAAA,CAAuB;QAPvD,cAAA,IAAA,EAAA;QAEQ,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAGN,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,cAAA,GAAiB;QACtB,IAAA,CAAK,KAAA,GAAQ,KAAK,GAAA,CAAI,GAAI,IAAA,CAAK,MAAA,GAAU,CAAA,iBAAgB,KAAA,GAAQ,CAAA,IAAM;QACvE,IAAA,CAAK,KAAA,GAAQ,CAAC,IAAA,CAAK,KAAA;QACnB,IAAA,CAAK,QAAA,GAAW;IAAA;IAGlB,aAAa,OAAA,EAAiB;QAC5B,IAAI,UAAU,IAAA,CAAK,KAAA,IAAS,IAAA,CAAK,KAAA,EAAO;YACtC,IAAA,CAAK,KAAA,GAAQ;YACb,IAAA,CAAK,QAAA,GAAW,KAAK,GAAA,CAClB,IAAA,CAAK,cAAA,GAAiB,IAAA,CAAK,KAAA,GAAS,IAAA,CAAK,MAAA,EAC1C,IAAA,CAAK,cAAA;YAEP,OAAO;QAAA;QAGT,OAAO;IAAA;AAAA;AA5BJ,IAAA,kBAAA;AACW,cADX,iBACW,SAAQ;;ACqC1B,IAAM,mBAAmB;AAEzB,IAAA,SAAA,MAAa;IAMX,YAAY,YAAA,CAAsB;QALlC,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAGE,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI;IAAA;IAQtC,UAAU;QACR,OAAO,MAAM,YAAA,CACX,IAAA,CAAK,CAAA,IAAK,kBACV,IAAA,CAAK,CAAA,IAAK,kBACV,IAAA,CAAK,CAAA,IAAK,kBACV,IAAA,CAAK,CAAA,IAAK;IAAA;IAId,SAAS,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;QACnD,IAAA,CAAK,CAAA,IAAK,IAAI;QACd,IAAA,CAAK,CAAA,IAAK,IAAI;QACd,IAAA,CAAK,CAAA,IAAK,IAAI;QACd,IAAA,CAAK,CAAA,IAAK,IAAI;IAAA;AAAA;AAuBX,IAAA,YAAA,cAAuB,yBAAyB;IAwErD,YACE,uBAAA,EACA,SAAS,GAAA,CACT;QACA,KAAA;QAnBM,cAAA,IAAA,EAAA;QACS,cAAA,IAAA,EAAA;QACT,cAAA,IAAA,EAAA;QAGS,cAAA,IAAA,EAAA;QACT,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QACS,cAAA,IAAA,EAAA;QAOf,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,WAAA,GAAc,EAAA;QACnB,IAAA,CAAK,aAAA,GAAgB;QACrB,IAAA,CAAK,YAAA,GAAe;QAEpB,IAAA,CAAK,SAAA,CAAU,aAAA,CACb,OAAO,kBACP,OAAO,kBACP,OAAO,kBACP,OAAO;IAAA;IAIX,OAAO,cAAA,EAAgC;QACrC,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,WAAA,CAAY,MAAA,CAAO,eAAe,aAAA;IAAA;IAAA,CAG3D,WAAyD;QACxD,IAAA,CAAK,KAAA;QAEL,OAAO,IAAA,CAAK,MAAA;QAEZ,MAAM;YACJ,SAAS,IAAA,CAAK,aAAA;YACd,UAAU;QAAA;IAAA;IAIN,QAAQ;QACd,IAAA,CAAK,KAAA,GAAQ,EAAA;QACb,IAAA,CAAK,KAAA,GAAQ,EAAA;QACb,IAAA,CAAK,SAAA,GAAY,EAAA;QACjB,IAAA,CAAK,QAAA,GAAW,EAAA;QAChB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,YAAA,EAAc,IAAK;YAC1C,IAAA,CAAK,QAAA,CAAS,EAAA,GAAK,IAAI,OACnB,CAAA,KAAM,mBAAmB,CAAA,IAAM,IAAA,CAAK,YAAA,GAAgB;YAIxD,IAAA,CAAK,KAAA,CAAM,EAAA,GAAM,UAAS,YAAA,GAAe,IAAA,CAAK,YAAA,GAAgB;YAC9D,IAAA,CAAK,KAAA,CAAM,EAAA,GAAK;QAAA;IAAA;IAAA,CAOX,SAAS;QAChB,IAAI,eAAe,IAAA,CAAK,aAAA;QACxB,MAAM,eAAe,IAAA,CAAK,WAAA,CAAY,MAAA;QACtC,IAAI,eAAe,UAAS,gBAAA,EAAkB,eAAe;QAE7D,MAAM,WAAY,KAAM,CAAA,eAAe,CAAA,IAAK,IAAK;QACjD,MAAM,iBAAkB,eAAe,eAAgB;QAEvD,IAAI,QAAS,iBAAiB,UAAS,QAAA,GAAY;QACnD,IAAI,QAAQ,UAAS,UAAA;QACrB,IAAI,SAAU,CAAA,IAAA,CAAK,YAAA,IAAgB,CAAA,IAAK,UAAS,WAAA;QAEjD,IAAI,MAAM,UAAU,UAAS,gBAAA;QAC7B,IAAI,OAAO,GAAG,MAAM;QAEpB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;YAC5B,IAAA,CAAK,SAAA,CAAU,EAAA,GACZ,QAAW,CAAA,CAAA,MAAM,MAAM,IAAI,CAAA,IAAK,UAAS,QAAA,GAAa,CAAA,MAAM,GAAA,CAAA,MAC7D;QAAA;QAGJ,IAAI;QACJ,IAAI,eAAe,UAAS,gBAAA,EAAkB;YAC5C,OAAO;QAAA,OAAA,IACE,eAAe,UAAS,OAAA,KAAY,GAAG;YAChD,OAAO,UAAS,OAAA;QAAA,OAAA,IACP,eAAe,UAAS,OAAA,KAAY,GAAG;YAChD,OAAO,UAAS,OAAA;QAAA,OAAA,IACP,eAAe,UAAS,OAAA,KAAY,GAAG;YAChD,OAAO,UAAS,OAAA;QAAA,OACX;YACL,OAAO,UAAS,OAAA;QAAA;QAGlB,MAAM,UAAU,IAAI,gBAAgB,gBAAgB;QACpD,IAAA,IAAS,IAAI,GAAG,aAAa,GAAG,IAAI,gBAAkB;YACpD,IAAI,QAAQ,YAAA,CAAa,IAAI;gBAC3B,MAAM;oBACJ,UAAU,QAAQ,QAAA;gBAAA;YAAA;YAItB,MAAM,QAAQ,IAAA,CAAK,WAAA,CAAY,WAAA;YAC/B,MAAM,IAAI,MAAM,CAAA,IAAK;YACrB,MAAM,IAAI,MAAM,CAAA,IAAK;YACrB,MAAM,IAAI,MAAM,CAAA,IAAK;YACrB,MAAM,IAAI,MAAM,CAAA,IAAK;YACrB,MAAM,cAAc,IAAA,CAAK,QAAA,CAAS,GAAG,GAAG,GAAG;YAE3C,IAAA,CAAK,YAAA,CAAa,OAAO,aAAa,GAAG,GAAG,GAAG;YAC/C,IAAI,QAAQ,GAAG,IAAA,CAAK,eAAA,CAAgB,KAAK,aAAa,GAAG,GAAG,GAAG;YAG/D,cAAc;YACd,IAAI,cAAc,cAAc,cAAc;YAC9C;YAEA,IAAI,UAAU,GAAG,QAAQ;YAEzB,IAAI,IAAI,UAAU,GAAG;gBACnB,SAAU,QAAQ,WAAY;gBAC9B,UAAW,SAAS,UAAS,eAAA,GAAmB;gBAChD,MAAM,UAAU,UAAS,gBAAA;gBAEzB,IAAI,OAAO,GAAG,MAAM;gBACpB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;oBAC5B,IAAA,CAAK,SAAA,CAAU,EAAA,GACZ,QACI,CAAA,CAAA,MAAM,MAAM,IAAI,CAAA,IAAK,UAAS,QAAA,GAAa,CAAA,MAAM,GAAA,CAAA,MACtD;gBAAA;YAAA;QAAA;IAAA;IAMF,gBAAgB;QACtB,MAAM,UAAU,IAAI;QAEpB,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,CAAC,WAAW;YAChC,QAAQ,GAAA,CAAI,OAAO,OAAA;QAAA;QAGrB,QAAQ,IAAA;QACR,OAAO;IAAA;IAMD,gBACN,GAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,EAAA,EACA;QACA,IAAI,KAAK,IAAI;QACb,IAAI,KAAK,CAAA,GAAI,KAAK,CAAA;QAElB,IAAI,KAAK,IAAI;QACb,IAAI,KAAK,IAAA,CAAK,YAAA,EAAc,KAAK,IAAA,CAAK,YAAA;QAEtC,IAAI,IAAI,IAAI;QACZ,IAAI,IAAI,IAAI;QACZ,IAAI,IAAI;QAER,MAAO,IAAI,MAAM,IAAI,GAAI;YACvB,MAAM,IAAI,IAAA,CAAK,SAAA,CAAU,IAAA,GAAO,UAAS,aAAA;YACzC,IAAI,IAAI,IAAI;gBACV,MAAM,IAAI,IAAA,CAAK,QAAA,CAAS,IAAA;gBACxB,EAAE,QAAA,CAAS,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,EAAA;YAAA;YAGrE,IAAI,IAAI,IAAI;gBACV,MAAM,IAAI,IAAA,CAAK,QAAA,CAAS,IAAA;gBACxB,EAAE,QAAA,CAAS,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,EAAA;YAAA;QAAA;IAAA;IAQjE,aACN,KAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA;QACA,SAAS,UAAS,UAAA;QAGlB,MAAM,IAAI,IAAA,CAAK,QAAA,CAAS,EAAA;QACxB,EAAE,QAAA,CACA,QAAS,CAAA,EAAE,CAAA,GAAI,CAAA,GACf,QAAS,CAAA,EAAE,CAAA,GAAI,CAAA,GACf,QAAS,CAAA,EAAE,CAAA,GAAI,CAAA,GACf,QAAS,CAAA,EAAE,CAAA,GAAI,CAAA;IAAA;IAeX,SAAS,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;QAC3D,MAAM,aAAc,MAAM,KAAM;QAEhC,IAAI,QAAQ,CAAE,CAAA,KAAK,EAAA;QACnB,IAAI,YAAY;QAChB,IAAI,UAAU,CAAA;QACd,IAAI,cAAc;QAElB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,YAAA,EAAc,IAAK;YAC1C,MAAM,IAAI,IAAA,CAAK,QAAA,CAAS,EAAA;YACxB,MAAM,OACH,IAAA,CAAK,SAAA,CAAU,mBAAA,CAAoB,GAAG;gBAAE;gBAAG;gBAAG;gBAAG;YAAA,KAAO,aACzD;YAEF,IAAI,OAAO,OAAO;gBAChB,QAAQ;gBACR,UAAU;YAAA;YAGZ,MAAM,WACJ,OACC,CAAA,IAAA,CAAK,KAAA,CAAM,EAAA,IAAO,UAAS,iBAAA,GAAoB,gBAAA;YAClD,IAAI,WAAW,WAAW;gBACxB,YAAY;gBACZ,cAAc;YAAA;YAEhB,MAAM,WAAW,IAAA,CAAK,KAAA,CAAM,EAAA,IAAM,UAAS,UAAA;YAC3C,IAAA,CAAK,KAAA,CAAM,EAAA,IAAM;YACjB,IAAA,CAAK,KAAA,CAAM,EAAA,IAAM,YAAY,UAAS,WAAA;QAAA;QAExC,IAAA,CAAK,KAAA,CAAM,QAAA,IAAY,UAAS,KAAA;QAChC,IAAA,CAAK,KAAA,CAAM,QAAA,IAAY,UAAS,UAAA;QAChC,OAAO;IAAA;AAAA;AAvTJ,IAAA,WAAA;AAKmB,cALnB,UAKmB,WAAU;AACV,cANnB,UAMmB,WAAU;AACV,cAPnB,UAOmB,WAAU;AACV,cARnB,UAQmB,WAAU;AACV,cATnB,UASmB,oBAAmB,UAAS,OAAA;AAG5B,cAZnB,UAYmB,YAAW;AAGX,cAfnB,UAemB,qBAAoB;AAGpB,cAlBnB,UAkBmB,gBAAe,KAAK,UAAS,iBAAA;AAC7B,cAnBnB,UAmBmB,eAAc;AAKd,cAxBnB,UAwBmB,cAAa;AACb,cAzBnB,UAyBmB,SAAQ,UAAS,YAAA,IAAgB,UAAS,UAAA;AAG1C,cA5BnB,UA4BmB,cACtB,UAAS,YAAA,IAAiB,UAAS,WAAA,GAAc,UAAS,UAAA;AAKpC,cAlCnB,UAkCmB,oBAAmB;AAGnB,cArCnB,UAqCmB,eAAc,KAAK,UAAS,gBAAA;AAG5B,cAxCnB,UAwCmB,mBAAkB;AAKlB,cA7CnB,UA6CmB,mBAAkB;AAGlB,cAhDnB,UAgDmB,cAAa,KAAK,UAAS,eAAA;AAG3B,cAnDnB,UAmDmB,iBAAgB;AAChB,cApDnB,UAoDmB,YAAW,KAAK,UAAS,aAAA;AACzB,cArDnB,UAqDmB,sBACtB,UAAS,eAAA,GAAkB,UAAS,aAAA;AACd,cAvDnB,UAuDmB,iBAAgB,KAAK,UAAS,kBAAA;;AC9GxD,IAAM,oBAAmB;AAEzB,IAAA,cAAA,MAAkB;IAMhB,YAAY,YAAA,CAAsB;QALlC,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAGE,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI,IAAA,CAAK,CAAA,GAAI;IAAA;IAQtC,UAAU;QACR,OAAO,MAAM,YAAA,CACX,IAAA,CAAK,CAAA,IAAK,mBACV,IAAA,CAAK,CAAA,IAAK,mBACV,IAAA,CAAK,CAAA,IAAK,mBACV,IAAA,CAAK,CAAA,IAAK;IAAA;IAId,SAAS,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;QACnD,IAAA,CAAK,CAAA,IAAK;QACV,IAAA,CAAK,CAAA,IAAK;QACV,IAAA,CAAK,CAAA,IAAK;QACV,IAAA,CAAK,CAAA,IAAK;IAAA;AAAA;AAIP,IAAA,iBAAA,cAA4B,yBAAyB;IA0E1D,YACE,uBAAA,EACA,SAAS,GAAA,CACT;QACA,KAAA;QAnBM,cAAA,IAAA,EAAA;QACS,cAAA,IAAA,EAAA;QACT,cAAA,IAAA,EAAA;QAGS,cAAA,IAAA,EAAA;QACT,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QACS,cAAA,IAAA,EAAA;QAOf,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,WAAA,GAAc,EAAA;QACnB,IAAA,CAAK,aAAA,GAAgB;QACrB,IAAA,CAAK,YAAA,GAAe;QAEpB,IAAA,CAAK,SAAA,CAAU,aAAA,CACb,OAAO,mBACP,OAAO,mBACP,OAAO,mBACP,OAAO;IAAA;IAIX,OAAO,cAAA,EAAgC;QACrC,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,WAAA,CAAY,MAAA,CAAO,eAAe,aAAA;IAAA;IAAA,CAG3D,WAAW;QACV,IAAA,CAAK,KAAA;QACL,OAAO,IAAA,CAAK,MAAA;QAEZ,MAAM;YACJ,SAAS,IAAA,CAAK,aAAA;YACd,UAAU;QAAA;IAAA;IAIN,QAAQ;QACd,IAAA,CAAK,KAAA,GAAQ,EAAA;QACb,IAAA,CAAK,KAAA,GAAQ,EAAA;QACb,IAAA,CAAK,SAAA,GAAY,EAAA;QACjB,IAAA,CAAK,QAAA,GAAW,EAAA;QAChB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,YAAA,EAAc,IAAK;YAC1C,IAAA,CAAK,QAAA,CAAS,EAAA,GAAK,IAAI,YACpB,CAAA,KAAM,oBAAmB,CAAA,IAAM,IAAA,CAAK,YAAA;YAIvC,IAAA,CAAK,KAAA,CAAM,EAAA,GAAK,eAAc,YAAA,GAAe,IAAA,CAAK,YAAA;YAClD,IAAA,CAAK,KAAA,CAAM,EAAA,GAAK;QAAA;IAAA;IAAA,CAOX,SAAuD;QAC9D,IAAI,eAAe,IAAA,CAAK,aAAA;QAExB,MAAM,eAAe,IAAA,CAAK,WAAA,CAAY,MAAA;QACtC,IAAI,eAAe,eAAc,gBAAA,EAAkB,eAAe;QAElE,MAAM,WAAW,KAAM,CAAA,eAAe,CAAA,IAAK;QAC3C,MAAM,iBAAiB,eAAe;QAEtC,IAAI,QAAS,iBAAiB,eAAc,QAAA,GAAY;QACxD,IAAI,QAAQ,eAAc,UAAA;QAC1B,IAAI,SAAU,CAAA,IAAA,CAAK,YAAA,IAAgB,CAAA,IAAK,eAAc,WAAA;QAEtD,IAAI,MAAM,UAAU,eAAc,gBAAA;QAClC,IAAI,OAAO,GAAG,MAAM;QAEpB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;YAC5B,IAAA,CAAK,SAAA,CAAU,EAAA,GACb,QAAW,CAAA,CAAA,MAAM,MAAM,IAAI,CAAA,IAAK,eAAc,QAAA,GAAa,CAAA,MAAM,GAAA,CAAA;QAAA;QAGrE,IAAI;QACJ,IAAI,eAAe,eAAc,gBAAA,EAAkB;YACjD,OAAO;QAAA,OAAA,IACE,eAAe,eAAc,OAAA,KAAY,GAAG;YACrD,OAAO,eAAc,OAAA;QAAA,OAAA,IACZ,eAAe,eAAc,OAAA,KAAY,GAAG;YACrD,OAAO,eAAc,OAAA;QAAA,OAAA,IACZ,eAAe,eAAc,OAAA,KAAY,GAAG;YACrD,OAAO,eAAc,OAAA;QAAA,OAChB;YACL,OAAO,eAAc,OAAA;QAAA;QAGvB,MAAM,UAAU,IAAI,gBAAgB,gBAAgB;QACpD,IAAA,IAAS,IAAI,GAAG,aAAa,GAAG,IAAI,gBAAkB;YACpD,IAAI,QAAQ,YAAA,CAAa,IAAI;gBAC3B,MAAM;oBACJ,UAAU,QAAQ,QAAA;gBAAA;YAAA;YAItB,MAAM,QAAQ,IAAA,CAAK,WAAA,CAAY,WAAA;YAC/B,MAAM,IAAI,MAAM,CAAA,IAAK;YACrB,MAAM,IAAI,MAAM,CAAA,IAAK;YACrB,MAAM,IAAI,MAAM,CAAA,IAAK;YACrB,MAAM,IAAI,MAAM,CAAA,IAAK;YACrB,MAAM,cAAc,IAAA,CAAK,QAAA,CAAS,GAAG,GAAG,GAAG;YAE3C,IAAA,CAAK,YAAA,CAAa,OAAO,aAAa,GAAG,GAAG,GAAG;YAC/C,IAAI,QAAQ,GAAG,IAAA,CAAK,eAAA,CAAgB,KAAK,aAAa,GAAG,GAAG,GAAG;YAG/D,cAAc;YACd,IAAI,cAAc,cAAc,cAAc;YAC9C;YAEA,IAAI,UAAU,GAAG,QAAQ;YAEzB,IAAI,IAAI,UAAU,GAAG;gBACnB,SAAS,QAAQ;gBACjB,UAAU,SAAS,eAAc,eAAA;gBACjC,MAAM,UAAU,eAAc,gBAAA;gBAE9B,IAAI,OAAO,GAAG,MAAM;gBACpB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;oBAC5B,IAAA,CAAK,SAAA,CAAU,EAAA,GACb,QACG,CAAA,CAAA,MAAM,MAAM,IAAI,CAAA,IAAK,eAAc,QAAA,GAAa,CAAA,MAAM,GAAA,CAAA;gBAAA;YAAA;QAAA;IAAA;IAM3D,gBAAgB;QACtB,MAAM,UAAU,IAAI;QAEpB,IAAA,CAAK,QAAA,CAAS,OAAA,CAAQ,CAAC,WAAW;YAChC,QAAQ,GAAA,CAAI,OAAO,OAAA;QAAA;QAGrB,QAAQ,IAAA;QACR,OAAO;IAAA;IAMD,gBACN,GAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,EAAA,EACA;QACA,IAAI,KAAK,IAAI;QACb,IAAI,KAAK,CAAA,GAAI,KAAK,CAAA;QAElB,IAAI,KAAK,IAAI;QACb,IAAI,KAAK,IAAA,CAAK,YAAA,EAAc,KAAK,IAAA,CAAK,YAAA;QAEtC,IAAI,IAAI,IAAI;QACZ,IAAI,IAAI,IAAI;QACZ,IAAI,IAAI;QAER,MAAO,IAAI,MAAM,IAAI,GAAI;YACvB,MAAM,IAAI,IAAA,CAAK,SAAA,CAAU,IAAA,GAAO,eAAc,aAAA;YAC9C,IAAI,IAAI,IAAI;gBACV,MAAM,IAAI,IAAA,CAAK,QAAA,CAAS,IAAA;gBACxB,EAAE,QAAA,CAAS,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,EAAA;YAAA;YAGrE,IAAI,IAAI,IAAI;gBACV,MAAM,IAAI,IAAA,CAAK,QAAA,CAAS,IAAA;gBACxB,EAAE,QAAA,CAAS,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,CAAA,GAAI,IAAK,CAAA,EAAE,CAAA,GAAI,EAAA;YAAA;QAAA;IAAA;IAQjE,aACN,KAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA,CAAA,EACA;QACA,SAAS,eAAc,UAAA;QAGvB,MAAM,IAAI,IAAA,CAAK,QAAA,CAAS,EAAA;QACxB,EAAE,QAAA,CACA,QAAS,CAAA,EAAE,CAAA,GAAI,CAAA,GACf,QAAS,CAAA,EAAE,CAAA,GAAI,CAAA,GACf,QAAS,CAAA,EAAE,CAAA,GAAI,CAAA,GACf,QAAS,CAAA,EAAE,CAAA,GAAI,CAAA;IAAA;IAeX,SAAS,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW,EAAA,EAAY;QAC5D,MAAM,aAAc,MAAM,KAAM;QAEhC,IAAI,QAAQ,CAAE,CAAA,KAAK,EAAA;QACnB,IAAI,YAAY;QAChB,IAAI,UAAU,CAAA;QACd,IAAI,cAAc;QAElB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,YAAA,EAAc,IAAK;YAC1C,MAAM,IAAI,IAAA,CAAK,QAAA,CAAS,EAAA;YACxB,MAAM,OACJ,IAAA,CAAK,SAAA,CAAU,mBAAA,CAAoB,GAAG;gBAAE;gBAAG;gBAAG;gBAAG,GAAG;YAAA,KAAQ;YAE9D,IAAI,OAAO,OAAO;gBAChB,QAAQ;gBACR,UAAU;YAAA;YAGZ,MAAM,WACJ,OACC,CAAA,IAAA,CAAK,KAAA,CAAM,EAAA,IAAO,eAAc,iBAAA,GAAoB,iBAAA;YACvD,IAAI,WAAW,WAAW;gBACxB,YAAY;gBACZ,cAAc;YAAA;YAEhB,MAAM,WAAW,IAAA,CAAK,KAAA,CAAM,EAAA,IAAM,eAAc,UAAA;YAChD,IAAA,CAAK,KAAA,CAAM,EAAA,IAAM;YACjB,IAAA,CAAK,KAAA,CAAM,EAAA,IAAM,YAAY,eAAc,WAAA;QAAA;QAE7C,IAAA,CAAK,KAAA,CAAM,QAAA,IAAY,eAAc,KAAA;QACrC,IAAA,CAAK,KAAA,CAAM,QAAA,IAAY,eAAc,UAAA;QACrC,OAAO;IAAA;AAAA;AAtTJ,IAAA,gBAAA;AAKmB,cALnB,eAKmB,WAAU;AACV,cANnB,eAMmB,WAAU;AACV,cAPnB,eAOmB,WAAU;AACV,cARnB,eAQmB,WAAU;AACV,cATnB,eASmB,oBAAmB,eAAc,OAAA;AAGjC,cAZnB,eAYmB,YAAW;AAGX,cAfnB,eAemB,qBAAoB;AAGpB,cAlBnB,eAkBmB,gBAAe,KAAK,eAAc,iBAAA;AAClC,cAnBnB,eAmBmB,eAAc;AAKd,cAxBnB,eAwBmB,cAAa;AACb,cAzBnB,eAyBmB,SACtB,eAAc,YAAA,IAAgB,eAAc,UAAA;AAGtB,cA7BnB,eA6BmB,cACtB,eAAc,YAAA,IACb,eAAc,WAAA,GAAc,eAAc,UAAA;AAKrB,cApCnB,eAoCmB,oBAAmB;AAGnB,cAvCnB,eAuCmB,eAAc,KAAK,eAAc,gBAAA;AAGjC,cA1CnB,eA0CmB,mBAAkB;AAKlB,cA/CnB,eA+CmB,mBAAkB;AAGlB,cAlDnB,eAkDmB,cAAa,KAAK,eAAc,eAAA;AAGhC,cArDnB,eAqDmB,iBAAgB;AAChB,cAtDnB,eAsDmB,YAAW,KAAK,eAAc,aAAA;AAC9B,cAvDnB,eAuDmB,sBACtB,eAAc,eAAA,GAAkB,eAAc,aAAA;AACxB,cAzDnB,eAyDmB,iBAAgB,KAAK,eAAc,kBAAA;;ACtGtD,IAAA,kBAAA,MAAqB;IAmB1B,YAAY,MAAA,EAAgB,MAAA,CAAgB;QAbpC,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QAEA,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QAIN,IAAA,CAAK,OAAA,GAAU;QAGf,IAAA,CAAK,WAAA,GAAc,UAAU;QAG7B,IAAA,CAAK,WAAA,GAAc,UAAU;QAG7B,IAAA,CAAK,SAAA,GAAY,IAAI,cACnB,gBAAe,UAAA,EACf,IAAA,CAAK,WAAA;QAGP,IAAA,CAAK,UAAA,GAAa,aAAA,GAAA,OAAO,MAAA,CAAO;IAAA;IAGlC,OAAO,cAAA,EAAgC;QACrC,OAAQ,IAAA,CAAK,OAAA;YAAA,KACN;gBACH,IAAA,CAAK,aAAA,CAAc;gBACnB;YAAA,KACG;gBACH,IAAA,CAAK,aAAA,CAAc;gBACnB;QAAA;IAAA;IAIN,kCAAkC;QAEhC,MAAM,SAAS,WACb,OAAO,IAAA,CAAK,IAAA,CAAK,UAAA,GACjB,CAAC,GAAG,IAAM,IAAA,CAAK,UAAA,CAAW,EAAA,GAAK,IAAA,CAAK,UAAA,CAAW,EAAA;QAEjD,IAAI,OAAO,MAAA,KAAW,GAAG;YACvB,OAAO,EAAA;QAAA;QAGT,IAAI;QACJ,OAAQ,IAAA,CAAK,OAAA;YAAA,KACN;gBACH,MAAM,qBAAqB,KAAK,GAAA,CAAI,OAAO,MAAA,EAAQ,IAAA,CAAK,WAAA;gBACxD,MAAM,OAAO,MAAA,CAAO,qBAAqB,EAAA;gBACzC,MAAM,OAAO,IAAA,CAAK,UAAA,CAAW,KAAA;gBAE7B,SAAS,OAAO,KAAA,CAAM,GAAG;gBAGzB,IAAI,MAAM;gBACV,MAAM,MAAM,OAAO,MAAA;gBACnB,MAAO,MAAM,OAAO,IAAA,CAAK,UAAA,CAAW,MAAA,CAAO,IAAA,CAAA,KAAU,KAAM;oBACzD,OAAO,IAAA,CAAK,MAAA,CAAO,MAAA;gBAAA;gBAIrB,IAAA,CAAK,SAAA,CAAU,eAAA,CAAgB;gBAC/B;YAAA,KAEG;gBACH,SAAS;gBACT;YAAA;gBAIA,MAAM,IAAI,MAAM;QAAA;QAIpB,OAAO,OAAO,GAAA,CAAI,CAAC,IAAM,CAAC;IAAA;IAIpB,cAAc,cAAA,EAAgC;QACpD,MAAM,QAAQ,IAAA,CAAK,UAAA;QACnB,MAAM,aAAa,eAAe,aAAA;QAClC,MAAM,MAAM,WAAW,MAAA;QAEvB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;YAC5B,MAAM,MAAM,UAAA,CAAW,EAAA,CAAG,MAAA;YAG1B,IAAA,CAAK,SAAA,CAAU,KAAA,CAAM;YAErB,IAAI,OAAO,OAAO;gBAChB,KAAA,CAAM,IAAA;YAAA,OACD;gBACL,KAAA,CAAM,IAAA,GAAO;YAAA;QAAA;IAAA;IAQX,cAAc,cAAA,EAAgC;QACpD,MAAM,QAAQ,eAAe,QAAA;QAC7B,MAAM,SAAS,eAAe,SAAA;QAC9B,MAAM,aAAa,eAAe,aAAA;QAElC,MAAM,OAAO,gBAAe,QAAA,CAAS,EAAA;QACrC,MAAM,OAAO,gBAAe,QAAA,CAAS,EAAA;QACrC,MAAM,OAAO,OAAO;QACpB,MAAM,QAAQ,IAAA,CAAK,UAAA,CAAW,OAAO,QAAQ,MAAM;QACnD,MAAM,QAAQ,IAAA,CAAK,UAAA;QAEnB,MAAM,OAAA,CAAQ,CAAC,QAAQ;YACrB,IAAI,OAAO,KAAK,KAAA,CAAO,IAAI,CAAA,GAAI,IAAI,CAAA,GAAK,QAAQ,gBAAe,UAAA;YAC/D,IAAI,OAAO,GAAG,OAAO;YAErB,MAAM,QAAgC,CAAA;YACtC,IAAA,CAAK,WAAA,CAAY,KAAK,OAAO,CAAC,MAAM;gBAClC,MAAM,MAAM,UAAA,CAAW,EAAA,CAAG,MAAA;gBAG1B,IAAA,CAAK,SAAA,CAAU,KAAA,CAAM;gBAErB,IAAI,OAAO,OAAO;oBAChB,KAAA,CAAM,IAAA;gBAAA,OAAA,IACG,OAAO,OAAO;oBACvB,IAAI,EAAE,KAAA,CAAM,IAAA,IAAQ,MAAM;wBACxB,KAAA,CAAM,IAAA,GAAO,KAAA,CAAM,IAAA;oBAAA;gBAAA,OAEhB;oBACL,KAAA,CAAM,IAAA,GAAO;gBAAA;YAAA;QAAA;QAMnB,IAAA,CAAK,SAAA,CAAU,oBAAA,CAAqB;IAAA;IAI9B,YAAY,IAAA,EAAW,GAAA,EAAa,EAAA,EAAyB;QACnE,MAAM,IAAI;QACV,MAAM,KAAK,EAAE,CAAA,GAAI,MAAM,EAAE,CAAA;QACzB,MAAM,KAAM,CAAA,EAAE,CAAA,GAAI,EAAE,CAAA,GAAI,CAAA,IAAK,MAAO,CAAA,EAAE,CAAA,GAAI,EAAE,CAAA,GAAI,CAAA;QAChD,MAAM,OAAO,MAAM,EAAE,CAAA,GAAI;QAEzB,IAAI,MAAM;QACV,IAAI,IAAI;QAER,GAAG;YACD,GAAG,IAAA,CAAK,IAAA,EAAM;YACd,KAAK,EAAE,MAAM,EAAE,CAAA,KAAM,IAAI,OAAO;QAAA,QACzB,KAAK,GAAA;IAAA;IAOR,WACN,KAAA,EACA,MAAA,EACA,KAAA,EACA,KAAA,EACA;QACA,MAAM,OAAO,QAAQ;QACrB,MAAM,OAAO,SAAS;QACtB,MAAM,OAAO,QAAQ;QACrB,MAAM,OAAO,SAAS;QACtB,MAAM,aAAa,EAAA;QAEnB,IAAA,IAAS,KAAI,GAAG,KAAI,QAAQ,MAAK,MAAO;YACtC,IAAA,IAAS,KAAI,GAAG,KAAI,OAAO,MAAK,MAAO;gBACrC,WAAW,IAAA,CAAK;oBACd,GAAA;oBACA,GAAA;oBACA,GAAG,OAAM,OAAO,OAAO;oBACvB,GAAG,OAAM,OAAO,OAAO;gBAAA;YAAA;QAAA;QAK7B,OAAO;IAAA;AAAA;AApMJ,IAAA,iBAAA;AACU,cADV,gBACU,YAAW;IAAC;IAAI;CAAA;AAChB,cAFV,gBAEU,cAAa;AACb,cAHV,gBAGU,cAAa;;ACH9B,IAAA,eAAA,MAAmB;IAKjB,YAAY,KAAA,EAAe,KAAA,EAAc,QAAA,CAAkB;QAJlD,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAGP,IAAA,CAAK,KAAA,GAAQ;QACb,IAAA,CAAK,KAAA,GAAQ;QACb,IAAA,CAAK,QAAA,GAAW;IAAA;AAAA;AAKb,IAAA,WAAA,cAAuB,yBAAyB;IAcrD,YACE,uBAAA,EACA,SAAS,GAAA,EACT,SAAS,CAAA,CACT;QACA,KAAA;QAjBe,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QAGA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAQf,IAAA,CAAK,SAAA,GAAY;QAEjB,IAAA,CAAK,OAAA,GAAU;QAGf,IAAA,CAAK,UAAA,GAAa,IAAI,eAAe,QAAQ;QAE7C,IAAA,CAAK,gBAAA,GAAmB;QACxB,IAAA,CAAK,kBAAA,GAAqB;IAAA;IAI5B,OAAO,KAAA,EAAuB;QAiB5B,IAAA,CAAK,UAAA,CAAW,MAAA,CAAO;IAAA;IAAA,CAIxB,WAAW;QACV,MAAM,SAAS,IAAA,CAAK,UAAA,CAAW,+BAAA;QAC/B,IAAI,OAAO,MAAA,KAAW,GAAG;YACvB,MAAM,IAAI,MAAM;QAAA;QAGlB,OAAO,IAAA,CAAK,aAAA,CAAc;IAAA;IAAA,CAInB,cACP,MAAA,EAC8C;QAG9C,MAAM,UAAU,IAAI;QACpB,MAAM,aAAa,QAAQ,iBAAA,GAAoB,aAAA;QAC/C,MAAM,aAAa,IAAI,MAAM,OAAO,MAAA;QAEpC,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,MAAA,EAAQ,IAAK;YACtC,WAAW,IAAA,CAAK,MAAM,cAAA,CAAe,MAAA,CAAO,EAAA;YAC5C,UAAA,CAAW,EAAA,GAAK;QAAA;QAGlB,MAAM,MAAM,WAAW,MAAA;QACvB,MAAM,UAAU,EAAA;QAEhB,IAAI,SAAS;QACb,IAAI,QAAQ,IAAA,CAAK,gBAAA;QAGjB,MAAM,UAAU,IAAI,gBAAgB,SAAS,IAAA,CAAK,OAAA,EAAS;QAC3D,MAAO,SAAS,IAAA,CAAK,OAAA,CAAS;YAC5B,QAAQ,MAAA,GAAS;YAGjB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;gBAC5B,IAAI,QAAQ,YAAA,CAAa,MAAM,SAAS;oBACtC,MAAM;wBACJ,UAAU,QAAQ,QAAA;oBAAA;gBAAA;gBAItB,IAAI,UAAA,CAAW,EAAA,KAAO,GAAG;gBACzB,MAAM,MAAM,UAAA,CAAW,EAAA;gBAGvB,IAAA,IAAS,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;oBAChC,IAAI,UAAA,CAAW,EAAA,KAAO,GAAG;oBACzB,MAAM,MAAM,UAAA,CAAW,EAAA;oBAGvB,MAAM,OAAO,IAAA,CAAK,SAAA,CAAU,mBAAA,CAAoB,KAAK;oBACrD,IAAI,OAAO,OAAO;wBAEhB,QAAQ,IAAA,CAAK,IAAI,aAAa,GAAG,KAAK;wBACtC,UAAA,CAAW,EAAA,GAAK;wBAChB;oBAAA;gBAAA;YAAA;YAQN,SACE,SAAS,IAAA,CAAK,OAAA,GAAU,IACpB,IAAA,CAAK,gBAAA,GACL,IAAA,CAAK,kBAAA;QAAA;QAIb,IAAI,SAAS,IAAA,CAAK,OAAA,EAAS;YAEzB,WAAW,SAAS,CAAC,GAAG,IAAM,EAAE,QAAA,GAAW,EAAE,QAAA;YAE7C,IAAI,IAAI;YACR,MAAO,SAAS,IAAA,CAAK,OAAA,IAAW,IAAI,QAAQ,MAAA,CAAQ;gBAClD,MAAM,eAAe,OAAA,CAAQ,EAAA;gBAE7B,UAAA,CAAW,aAAa,KAAA,CAAA,GAAS;gBACjC;gBACA;YAAA;QAAA;QAIJ,IAAI,SAAS,WAAW,MAAA;QACxB,IAAA,IAAS,aAAa,SAAS,GAAG,cAAc,GAAG,aAAc;YAC/D,IAAI,UAAA,CAAW,WAAA,KAAgB,GAAG;gBAChC,IAAI,eAAe,SAAS,GAAG;oBAC7B,UAAA,CAAW,WAAA,GAAc,UAAA,CAAW,SAAS,EAAA;gBAAA;gBAE/C,EAAE;YAAA;QAAA;QAGN,WAAW,MAAA,GAAS;QAEpB,QAAQ,IAAA;QAER,MAAM;YACJ;YACA,UAAU;QAAA;IAAA;AAAA;;ACjLhB,SAAA,cAAuB,UAAA,EAAoB;IACzC,MAAM,IAAI,EAAA;IACV,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;QACnC,CAAA,CAAE,EAAA,GAAK;IAAA;IAET,OAAO;AAAA;AAGT,SAAA,cACE,UAAA,EACA,UAAA,EACA,UAAA,EACA,UAAA,EACgB;IAChB,MAAM,IAAI,IAAI,MAAM;IACpB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;QACnC,CAAA,CAAE,EAAA,GAAK,IAAI,MAAM;QACjB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;YACnC,CAAA,CAAE,EAAA,CAAG,EAAA,GAAK,IAAI,MAAM;YACpB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;gBACnC,CAAA,CAAE,EAAA,CAAG,EAAA,CAAG,EAAA,GAAK,IAAI,MAAM;gBACvB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;oBACnC,CAAA,CAAE,EAAA,CAAG,EAAA,CAAG,EAAA,CAAG,EAAA,GAAK;gBAAA;YAAA;QAAA;IAAA;IAKxB,OAAO;AAAA;AAGT,SAAA,cACE,UAAA,EACA,UAAA,EACA,UAAA,EACc;IACd,MAAM,IAAI,IAAI,MAAM;IACpB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;QACnC,CAAA,CAAE,EAAA,GAAK,IAAI,MAAM;QACjB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;YACnC,CAAA,CAAE,EAAA,CAAG,EAAA,GAAK,IAAI,MAAM;YACpB,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;gBACnC,CAAA,CAAE,EAAA,CAAG,EAAA,CAAG,EAAA,GAAK;YAAA;QAAA;IAAA;IAInB,OAAO;AAAA;AAGT,SAAA,YACE,CAAA,EACA,UAAA,EACA,UAAA,EACA,UAAA,EACA,KAAA,EACA;IACA,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;QACnC,CAAA,CAAE,EAAA,GAAK,EAAA;QACP,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;YACnC,CAAA,CAAE,EAAA,CAAG,EAAA,GAAK,EAAA;YACV,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;gBACnC,CAAA,CAAE,EAAA,CAAG,EAAA,CAAG,EAAA,GAAK;YAAA;QAAA;IAAA;AAAA;AAMrB,SAAA,YAAwB,CAAA,EAAQ,UAAA,EAAoB,KAAA,EAAU;IAC5D,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,IAAK;QACnC,CAAA,CAAE,EAAA,GAAK;IAAA;AAAA;AAIJ,IAAA,cAAA,MAAkB;IAAlB,aAvFP;QAwFE,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;IAAA;AAAA;AAGK,IAAA,WAAA,cAAsB,yBAAyB;IAgCpD,YACE,uBAAA,EACA,SAAS,GAAA,EACT,4BAA4B,CAAA,CAC5B;QACA,KAAA;QA/BM,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAEA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAEA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAEA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAES,cAAA,IAAA,EAAA;QAQf,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,WAAA,CAAY;QACjB,IAAA,CAAK,WAAA,CAAY;IAAA;IAGnB,OAAO,KAAA,EAAuB;QAC5B,MAAM,aAAa,MAAM,aAAA;QAEzB,IAAA,IAAS,IAAI,GAAG,IAAI,WAAW,MAAA,EAAQ,IAAI,GAAG,IAAK;YACjD,IAAA,CAAK,SAAA,CAAU,UAAA,CAAW,EAAA;QAAA;QAG5B,IAAA,CAAK,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO;IAAA;IAAA,CAGpC,WAAW;QACV,OAAO,IAAA,CAAK,eAAA;QAEZ,MAAM,UAAU,IAAI;QAGpB,IAAA,IAAS,eAAe,GAAG,eAAe,IAAA,CAAK,OAAA,EAAS,eAAgB;YACtE,IAAI,IAAA,CAAK,KAAA,CAAM,aAAA,GAAgB,GAAG;gBAChC,MAAM,MAAM,IAAA,CAAK,KAAA,CAAM,aAAA;gBACvB,MAAM,IAAI,IAAA,CAAK,KAAA,CAAM,aAAA,GAAgB;gBACrC,MAAM,IAAI,IAAA,CAAK,OAAA,CAAQ,aAAA,GAAgB;gBACvC,MAAM,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,GAAgB;gBACtC,MAAM,IAAI,IAAA,CAAK,OAAA,CAAQ,aAAA,GAAgB;gBAEvC,MAAM,QAAQ,MAAM,YAAA,CAAa,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI;gBAC1D,QAAQ,GAAA,CAAI;YAAA;QAAA;QAIhB,QAAQ,IAAA;QAER,MAAM;YACJ;YACA,UAAU;QAAA;IAAA;IAAA,CAIL,kBAAkB;QAEzB,OAAO,IAAA,CAAK,iBAAA;QAEZ,IAAI,OAAO;QACX,MAAM,iBAAiB,cAAc,IAAA,CAAK,OAAA;QAG1C,IAAA,IAAS,YAAY,GAAG,YAAY,IAAA,CAAK,OAAA,EAAS,EAAE,UAAW;YAE7D,IAAI,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,KAAA,EAAO,IAAA,CAAK,MAAA,CAAO,UAAA,GAAa;gBACxD,cAAA,CAAe,KAAA,GACb,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,MAAA,GAAS,IACvB,IAAA,CAAK,kBAAA,CAAmB,IAAA,CAAK,MAAA,CAAO,KAAA,IACpC;gBACN,cAAA,CAAe,UAAA,GACb,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAA,GAAS,IAC5B,IAAA,CAAK,kBAAA,CAAmB,IAAA,CAAK,MAAA,CAAO,UAAA,IACpC;YAAA,OACD;gBAEL,cAAA,CAAe,KAAA,GAAQ;gBACvB;YAAA;YAGF,OAAO;YACP,IAAI,OAAO,cAAA,CAAe,EAAA;YAE1B,IAAA,IAAS,QAAQ,GAAG,SAAS,WAAW,EAAE,MAAO;gBAC/C,IAAI,cAAA,CAAe,MAAA,GAAS,MAAM;oBAChC,OAAO,cAAA,CAAe,MAAA;oBACtB,OAAO;gBAAA;YAAA;YAIX,IAAI,QAAQ,GAAK;gBACf,IAAA,CAAK,OAAA,GAAU,YAAY;gBAC3B;YAAA;QAAA;QAIJ,MAAM,YAAY,EAAA;QAClB,MAAM,cAAc,EAAA;QACpB,MAAM,aAAa,EAAA;QACnB,MAAM,cAAc,EAAA;QAGpB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,OAAA,EAAS,EAAE,EAAG;YACrC,MAAM,SAAS,SAAQ,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,EAAA,EAAI,IAAA,CAAK,QAAA;YAEpD,IAAI,SAAS,GAAG;gBACd,SAAA,CAAU,EAAA,GACP,SAAQ,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,EAAA,EAAI,IAAA,CAAK,WAAA,IAAe,SAAU;gBACjE,WAAA,CAAY,EAAA,GACT,SAAQ,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,EAAA,EAAI,IAAA,CAAK,aAAA,IAAiB,SAAU;gBACnE,UAAA,CAAW,EAAA,GACR,SAAQ,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,EAAA,EAAI,IAAA,CAAK,YAAA,IAAgB,SAAU;gBAClE,WAAA,CAAY,EAAA,GACT,SAAQ,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,EAAA,EAAI,IAAA,CAAK,aAAA,IAAiB,SAAU;YAAA,OAC9D;gBACL,SAAA,CAAU,EAAA,GAAK;gBACf,WAAA,CAAY,EAAA,GAAK;gBACjB,UAAA,CAAW,EAAA,GAAK;gBAChB,WAAA,CAAY,EAAA,GAAK;YAAA;QAAA;QAIrB,IAAA,CAAK,KAAA,GAAQ,cAAc,IAAA,CAAK,OAAA,GAAU;QAC1C,IAAA,CAAK,OAAA,GAAU,cAAc,IAAA,CAAK,OAAA,GAAU;QAC5C,IAAA,CAAK,MAAA,GAAS,cAAc,IAAA,CAAK,OAAA,GAAU;QAC3C,IAAA,CAAK,OAAA,GAAU,cAAc,IAAA,CAAK,OAAA,GAAU;QAC5C,IAAA,CAAK,KAAA,GAAQ,cAAc,IAAA,CAAK,OAAA,GAAU;QAG1C,IAAA,IAAS,QAAQ,GAAG,IAAI,IAAA,CAAK,OAAA,CAAQ,MAAA,EAAQ,QAAQ,GAAG,QAAS;YAC/D,MAAM,QAAQ,IAAA,CAAK,OAAA,CAAQ,MAAA;YAE3B,MAAM,QAAQ,CAAA;YAEd,IAAI,YAAY;YAChB,IAAI,eAAe,OAAO,SAAA;YAE1B,IAAA,IAAS,SAAS,GAAG,SAAS,IAAA,CAAK,OAAA,EAAS,SAAU;gBACpD,MAAM,WAAW,SAAA,CAAU,OAAA;gBAC3B,MAAM,aAAa,WAAA,CAAY,OAAA;gBAC/B,MAAM,YAAY,UAAA,CAAW,OAAA;gBAC7B,MAAM,aAAa,WAAA,CAAY,OAAA;gBAE/B,MAAM,WAAW,IAAA,CAAK,SAAA,CAAU,YAAA,CAC9B,UACA,YACA,WACA,YACA,MAAM,CAAA,EACN,MAAM,CAAA,EACN,MAAM,CAAA,EACN,MAAM,CAAA;gBAGR,IAAI,WAAW,cAAc;oBAC3B,eAAe;oBACf,YAAY;gBAAA;YAAA;YAIhB,IAAA,CAAK,KAAA,CAAM,UAAA,IAAc,MAAM,CAAA;YAC/B,IAAA,CAAK,OAAA,CAAQ,UAAA,IAAc,MAAM,CAAA;YACjC,IAAA,CAAK,MAAA,CAAO,UAAA,IAAc,MAAM,CAAA;YAChC,IAAA,CAAK,OAAA,CAAQ,UAAA,IAAc,MAAM,CAAA;YACjC,IAAA,CAAK,KAAA,CAAM,UAAA;QAAA;IAAA;IAIP,UAAU,KAAA,EAAc;QAC9B,MAAM,eAAe,IAAI,IAAA,CAAK,0BAAA;QAC9B,MAAM,WAAY,CAAA,MAAM,CAAA,IAAK,YAAA,IAAgB;QAC7C,MAAM,aAAc,CAAA,MAAM,CAAA,IAAK,YAAA,IAAgB;QAC/C,MAAM,YAAa,CAAA,MAAM,CAAA,IAAK,YAAA,IAAgB;QAC9C,MAAM,aAAc,CAAA,MAAM,CAAA,IAAK,YAAA,IAAgB;QAG/C,IAAA,CAAK,QAAA,CAAS,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA;QAChD,IAAA,CAAK,WAAA,CAAY,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,IAAc,MAAM,CAAA;QACvE,IAAA,CAAK,aAAA,CAAc,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,IAAc,MAAM,CAAA;QACzE,IAAA,CAAK,YAAA,CAAa,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,IAAc,MAAM,CAAA;QACxE,IAAA,CAAK,aAAA,CAAc,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,IAAc,MAAM,CAAA;QACzE,IAAA,CAAK,QAAA,CAAS,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,IAC9C,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA,CAAA,GAClB,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA,CAAA,GAClB,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA,CAAA,GAClB,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA,CAAA;IAAA;IAAA,CAOb,oBAAkE;QACzE,MAAM,OAAiB,EAAA;QACvB,MAAM,UAAoB,EAAA;QAC1B,MAAM,YAAsB,EAAA;QAC5B,MAAM,WAAqB,EAAA;QAC3B,MAAM,YAAsB,EAAA;QAC5B,MAAM,QAAkB,EAAA;QAExB,MAAM,QAAQ,cAAc,IAAA,CAAK,SAAA,EAAW,IAAA,CAAK,SAAA,EAAW,IAAA,CAAK,SAAA;QACjE,MAAM,WAAW,cACf,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,MAAM,aAAa,cACjB,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,MAAM,YAAY,cAChB,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,MAAM,aAAa,cACjB,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,MAAM,SAAS,cACb,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAGP,IAAI,kBAAkB;QACtB,MAAM,UAAU,IAAI,gBAClB,IAAA,CAAK,kBAAA,GAAqB,IAAA,CAAK,aAAA,EAC/B;QAGF,IAAA,IACM,aAAa,GACjB,cAAc,IAAA,CAAK,kBAAA,EACnB,EAAE,WACF;YACA,YACE,OACA,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL;YAEF,YACE,UACA,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL;YAEF,YACE,YACA,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL;YAEF,YACE,WACA,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL;YAEF,YACE,YACA,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL;YAEF,YACE,QACA,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL;YAGF,IAAA,IACM,WAAW,GACf,YAAY,IAAA,CAAK,aAAA,EACjB,EAAE,UAAU,EAAE,gBACd;gBACA,IAAI,QAAQ,YAAA,CAAa,kBAAkB;oBACzC,MAAM;wBACJ,UAAU,QAAQ,QAAA;oBAAA;gBAAA;gBAItB,YAAoB,MAAM,IAAA,CAAK,SAAA,EAAW;gBAC1C,YAAoB,SAAS,IAAA,CAAK,SAAA,EAAW;gBAC7C,YAAoB,WAAW,IAAA,CAAK,SAAA,EAAW;gBAC/C,YAAoB,UAAU,IAAA,CAAK,SAAA,EAAW;gBAC9C,YAAoB,WAAW,IAAA,CAAK,SAAA,EAAW;gBAC/C,YAAoB,OAAO,IAAA,CAAK,SAAA,EAAW;gBAE3C,IAAA,IACM,aAAa,GACjB,cAAc,IAAA,CAAK,aAAA,EACnB,EAAE,WACF;oBACA,IAAI,OAAO;oBACX,IAAI,UAAU;oBACd,IAAI,YAAY;oBAChB,IAAI,WAAW;oBACf,IAAI,YAAY;oBAChB,IAAI,QAAQ;oBAEZ,IAAA,IACM,YAAY,GAChB,aAAa,IAAA,CAAK,aAAA,EAClB,EAAE,UACF;wBACA,QAAQ,IAAA,CAAK,QAAA,CAAS,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA;wBACxD,WACE,IAAA,CAAK,WAAA,CAAY,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA;wBACrD,aACE,IAAA,CAAK,aAAA,CAAc,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA;wBACvD,YACE,IAAA,CAAK,YAAA,CAAa,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA;wBACtD,aACE,IAAA,CAAK,aAAA,CAAc,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA;wBACvD,SAAS,IAAA,CAAK,QAAA,CAAS,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA;wBAEzD,IAAA,CAAK,UAAA,IAAc;wBACnB,OAAA,CAAQ,UAAA,IAAc;wBACtB,SAAA,CAAU,UAAA,IAAc;wBACxB,QAAA,CAAS,UAAA,IAAc;wBACvB,SAAA,CAAU,UAAA,IAAc;wBACxB,KAAA,CAAM,UAAA,IAAc;wBAEpB,KAAA,CAAM,SAAA,CAAU,WAAA,CAAY,UAAA,GAC1B,KAAA,CAAM,WAAW,EAAA,CAAG,WAAA,CAAY,UAAA,GAAa,IAAA,CAAK,UAAA;wBACpD,QAAA,CAAS,SAAA,CAAU,WAAA,CAAY,UAAA,GAC7B,QAAA,CAAS,WAAW,EAAA,CAAG,WAAA,CAAY,UAAA,GACnC,OAAA,CAAQ,UAAA;wBACV,UAAA,CAAW,SAAA,CAAU,WAAA,CAAY,UAAA,GAC/B,UAAA,CAAW,WAAW,EAAA,CAAG,WAAA,CAAY,UAAA,GACrC,SAAA,CAAU,UAAA;wBACZ,SAAA,CAAU,SAAA,CAAU,WAAA,CAAY,UAAA,GAC9B,SAAA,CAAU,WAAW,EAAA,CAAG,WAAA,CAAY,UAAA,GACpC,QAAA,CAAS,UAAA;wBACX,UAAA,CAAW,SAAA,CAAU,WAAA,CAAY,UAAA,GAC/B,UAAA,CAAW,WAAW,EAAA,CAAG,WAAA,CAAY,UAAA,GACrC,SAAA,CAAU,UAAA;wBACZ,MAAA,CAAO,SAAA,CAAU,WAAA,CAAY,UAAA,GAC3B,MAAA,CAAO,WAAW,EAAA,CAAG,WAAA,CAAY,UAAA,GAAa,KAAA,CAAM,UAAA;wBAEtD,IAAA,CAAK,QAAA,CAAS,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,GAC9C,IAAA,CAAK,QAAA,CAAS,aAAa,EAAA,CAAG,SAAA,CAAU,WAAA,CAAY,UAAA,GACpD,KAAA,CAAM,SAAA,CAAU,WAAA,CAAY,UAAA;wBAC9B,IAAA,CAAK,WAAA,CAAY,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,GACjD,IAAA,CAAK,WAAA,CAAY,aAAa,EAAA,CAAG,SAAA,CAAU,WAAA,CACzC,UAAA,GACE,QAAA,CAAS,SAAA,CAAU,WAAA,CAAY,UAAA;wBACrC,IAAA,CAAK,aAAA,CAAc,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,GACnD,IAAA,CAAK,aAAA,CAAc,aAAa,EAAA,CAAG,SAAA,CAAU,WAAA,CAC3C,UAAA,GACE,UAAA,CAAW,SAAA,CAAU,WAAA,CAAY,UAAA;wBACvC,IAAA,CAAK,YAAA,CAAa,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,GAClD,IAAA,CAAK,YAAA,CAAa,aAAa,EAAA,CAAG,SAAA,CAAU,WAAA,CAC1C,UAAA,GACE,SAAA,CAAU,SAAA,CAAU,WAAA,CAAY,UAAA;wBACtC,IAAA,CAAK,aAAA,CAAc,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,GACnD,IAAA,CAAK,aAAA,CAAc,aAAa,EAAA,CAAG,SAAA,CAAU,WAAA,CAC3C,UAAA,GACE,UAAA,CAAW,SAAA,CAAU,WAAA,CAAY,UAAA;wBACvC,IAAA,CAAK,QAAA,CAAS,WAAA,CAAY,SAAA,CAAU,WAAA,CAAY,UAAA,GAC9C,IAAA,CAAK,QAAA,CAAS,aAAa,EAAA,CAAG,SAAA,CAAU,WAAA,CAAY,UAAA,GACpD,MAAA,CAAO,SAAA,CAAU,WAAA,CAAY,UAAA;oBAAA;gBAAA;YAAA;QAAA;IAAA;IAAA,OAU1B,aAAa,IAAA,EAAmB,MAAA,EAAwB;QACrE,OACE,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEN,CAAA,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC/C,KAAK,WAAA,CAAA,GAEL,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA;IAAA;IAAA,OAQE,QAAQ,IAAA,EAAmB,MAAA,EAAwB;QAChE,OAAO,SAAQ,YAAA,CAAa,MAAM,UAAU;IAAA;IAAA,OAM/B,KACb,IAAA,EACA,SAAA,EACA,QAAA,EACA,MAAA,EACA;QACA,IAAI;QACJ,OAAQ;YAAA,KACD,SAAQ,MAAA;gBACX,SACE,MAAA,CAAO,SAAA,CAAU,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CACrC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,SAAA,CAAU,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CACrC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,SAAA,CAAU,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CACrC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,SAAA,CAAU,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CACrC,KAAK,WAAA,CAAA,GAEN,CAAA,MAAA,CAAO,SAAA,CAAU,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CACtC,KAAK,WAAA,CAAA,GAEL,MAAA,CAAO,SAAA,CAAU,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CACrC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,SAAA,CAAU,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CACrC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,SAAA,CAAU,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CACrC,KAAK,WAAA,CAAA;gBAEX;YAAA,KAEG,SAAQ,IAAA;gBACX,SACE,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,SAAA,CAAU,KAAK,YAAA,CAAA,CACvC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,SAAA,CAAU,KAAK,YAAA,CAAA,CACvC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,SAAA,CAAU,KAAK,YAAA,CAAA,CACvC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,SAAA,CAAU,KAAK,YAAA,CAAA,CACvC,KAAK,WAAA,CAAA,GAEN,CAAA,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,SAAA,CAAU,KAAK,YAAA,CAAA,CACxC,KAAK,WAAA,CAAA,GAEL,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,SAAA,CAAU,KAAK,YAAA,CAAA,CACvC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,SAAA,CAAU,KAAK,YAAA,CAAA,CACvC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,SAAA,CAAU,KAAK,YAAA,CAAA,CACvC,KAAK,WAAA,CAAA;gBAEX;YAAA,KAEG,SAAQ,MAAA;gBACX,SACE,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,SAAA,CACzC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,SAAA,CACzC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,SAAA,CACzC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,SAAA,CACzC,KAAK,WAAA,CAAA,GAEN,CAAA,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,SAAA,CAC1C,KAAK,WAAA,CAAA,GAEL,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,SAAA,CACzC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,SAAA,CACzC,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,SAAA,CACzC,KAAK,WAAA,CAAA;gBAEX;YAAA,KAEG,SAAQ,KAAA;gBACX,SACE,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,SAAA,GAEF,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,SAAA,GAEF,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,SAAA,GAEF,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,SAAA,GAED,CAAA,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC/C,SAAA,GAEA,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,SAAA,GAEF,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,SAAA,GAEF,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,SAAA;gBAEN;YAAA;gBAEA,MAAM,IAAI,MAAM;QAAA;QAGpB,OAAO,SAAS;IAAA;IAAA,OAMH,QACb,IAAA,EACA,SAAA,EACA,MAAA,EACA;QACA,OAAQ;YAAA,KACD,SAAQ,MAAA;gBACX,OACE,CAAC,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC/C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEN,CAAA,CAAC,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAChD,KAAK,WAAA,CAAA,GAEL,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA;YAAA,KAIR,SAAQ,IAAA;gBACX,OACE,CAAC,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC/C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEN,CAAA,CAAC,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAChD,KAAK,WAAA,CAAA,GAEL,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA;YAAA,KAIR,SAAQ,MAAA;gBACX,OACE,CAAC,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC/C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEN,CAAA,CAAC,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAChD,KAAK,WAAA,CAAA,GAEL,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA;YAAA,KAIR,SAAQ,KAAA;gBACX,OACE,CAAC,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC/C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEN,CAAA,CAAC,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAChD,KAAK,WAAA,CAAA,GAEL,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA,GAEP,MAAA,CAAO,KAAK,YAAA,CAAA,CAAc,KAAK,UAAA,CAAA,CAAY,KAAK,YAAA,CAAA,CAC9C,KAAK,WAAA,CAAA;YAAA;gBAMX,OAAO;QAAA;IAAA;IAOL,mBAAmB,IAAA,EAAmB;QAC5C,MAAM,YAAY,SAAQ,OAAA,CAAQ,MAAM,IAAA,CAAK,WAAA;QAC7C,MAAM,cAAc,SAAQ,OAAA,CAAQ,MAAM,IAAA,CAAK,aAAA;QAC/C,MAAM,aAAa,SAAQ,OAAA,CAAQ,MAAM,IAAA,CAAK,YAAA;QAC9C,MAAM,cAAc,SAAQ,OAAA,CAAQ,MAAM,IAAA,CAAK,aAAA;QAC/C,MAAM,eAAe,SAAQ,YAAA,CAAa,MAAM,IAAA,CAAK,QAAA;QACrD,MAAM,eAAe,SAAQ,OAAA,CAAQ,MAAM,IAAA,CAAK,QAAA;QAChD,MAAM,WACJ,YAAY,YACZ,cAAc,cACd,aAAa,aACb,cAAc;QAEhB,OAAO,eAAe,WAAW;IAAA;IAM3B,UACN,IAAA,EACA,SAAA,EACA,KAAA,EACA,IAAA,EACA,QAAA,EACA,UAAA,EACA,SAAA,EACA,UAAA,EACA,WAAA,EACA;QACA,MAAM,YAAY,SAAQ,OAAA,CAAQ,MAAM,WAAW,IAAA,CAAK,WAAA,IAAe;QACvE,MAAM,cACJ,SAAQ,OAAA,CAAQ,MAAM,WAAW,IAAA,CAAK,aAAA,IAAiB;QACzD,MAAM,aAAa,SAAQ,OAAA,CAAQ,MAAM,WAAW,IAAA,CAAK,YAAA,IAAgB;QACzE,MAAM,cACJ,SAAQ,OAAA,CAAQ,MAAM,WAAW,IAAA,CAAK,aAAA,IAAiB;QACzD,MAAM,eAAe,SAAQ,OAAA,CAAQ,MAAM,WAAW,IAAA,CAAK,QAAA,IAAY;QAEvE,IAAI,SAAS;QACb,IAAI,cAAc,CAAA;QAElB,IAAA,IAAS,WAAW,OAAO,WAAW,MAAM,EAAE,SAAU;YAEtD,IAAI,UACF,YAAY,SAAQ,IAAA,CAAK,MAAM,WAAW,UAAU,IAAA,CAAK,WAAA;YAC3D,IAAI,YACF,cACA,SAAQ,IAAA,CAAK,MAAM,WAAW,UAAU,IAAA,CAAK,aAAA;YAC/C,IAAI,WACF,aAAa,SAAQ,IAAA,CAAK,MAAM,WAAW,UAAU,IAAA,CAAK,YAAA;YAC5D,IAAI,YACF,cACA,SAAQ,IAAA,CAAK,MAAM,WAAW,UAAU,IAAA,CAAK,aAAA;YAC/C,IAAI,aACF,eAAe,SAAQ,IAAA,CAAK,MAAM,WAAW,UAAU,IAAA,CAAK,QAAA;YAG9D,IAAI,eAAe,GAAG;gBACpB,IAAI,eACF,UAAU,UACV,YAAY,YACZ,WAAW,WACX,YAAY;gBACd,IAAI,OAAO,eAAe;gBAE1B,UAAU,WAAW;gBACrB,YAAY,aAAa;gBACzB,WAAW,YAAY;gBACvB,YAAY,aAAa;gBACzB,aAAa,cAAc;gBAE3B,IAAI,eAAe,GAAG;oBACpB,eACE,UAAU,UACV,YAAY,YACZ,WAAW,WACX,YAAY;oBACd,QAAQ,eAAe;oBAEvB,IAAI,OAAO,QAAQ;wBACjB,SAAS;wBACT,cAAc;oBAAA;gBAAA;YAAA;QAAA;QAMtB,OAAO;YAAE,KAAK;YAAQ,UAAU;QAAA;IAAA;IAI1B,KAAK,KAAA,EAAoB,MAAA,EAAqB;QACpD,IAAI;QAEJ,MAAM,WAAW,SAAQ,OAAA,CAAQ,OAAO,IAAA,CAAK,WAAA;QAC7C,MAAM,aAAa,SAAQ,OAAA,CAAQ,OAAO,IAAA,CAAK,aAAA;QAC/C,MAAM,YAAY,SAAQ,OAAA,CAAQ,OAAO,IAAA,CAAK,YAAA;QAC9C,MAAM,aAAa,SAAQ,OAAA,CAAQ,OAAO,IAAA,CAAK,aAAA;QAC/C,MAAM,cAAc,SAAQ,OAAA,CAAQ,OAAO,IAAA,CAAK,QAAA;QAEhD,MAAM,MAAM,IAAA,CAAK,SAAA,CACf,OACA,SAAQ,IAAA,EACR,MAAM,UAAA,GAAa,GACnB,MAAM,UAAA,EACN,UACA,YACA,WACA,YACA;QAEF,MAAM,QAAQ,IAAA,CAAK,SAAA,CACjB,OACA,SAAQ,MAAA,EACR,MAAM,YAAA,GAAe,GACrB,MAAM,YAAA,EACN,UACA,YACA,WACA,YACA;QAEF,MAAM,OAAO,IAAA,CAAK,SAAA,CAChB,OACA,SAAQ,KAAA,EACR,MAAM,WAAA,GAAc,GACpB,MAAM,WAAA,EACN,UACA,YACA,WACA,YACA;QAEF,MAAM,QAAQ,IAAA,CAAK,SAAA,CACjB,OACA,SAAQ,MAAA,EACR,MAAM,YAAA,GAAe,GACrB,MAAM,YAAA,EACN,UACA,YACA,WACA,YACA;QAGF,IACE,MAAM,GAAA,IAAO,IAAI,GAAA,IACjB,MAAM,GAAA,IAAO,MAAM,GAAA,IACnB,MAAM,GAAA,IAAO,KAAK,GAAA,EAClB;YACA,YAAY,SAAQ,MAAA;YAGpB,IAAI,MAAM,QAAA,GAAW,GAAG,OAAO;QAAA,OAAA,IAE/B,IAAI,GAAA,IAAO,MAAM,GAAA,IACjB,IAAI,GAAA,IAAO,MAAM,GAAA,IACjB,IAAI,GAAA,IAAO,KAAK,GAAA,EAChB;YACA,YAAY,SAAQ,IAAA;QAAA,OAAA,IAEpB,MAAM,GAAA,IAAO,MAAM,GAAA,IACnB,MAAM,GAAA,IAAO,IAAI,GAAA,IACjB,MAAM,GAAA,IAAO,KAAK,GAAA,EAClB;YACA,YAAY,SAAQ,MAAA;QAAA,OACf;YACL,YAAY,SAAQ,KAAA;QAAA;QAGtB,OAAO,UAAA,GAAa,MAAM,UAAA;QAC1B,OAAO,YAAA,GAAe,MAAM,YAAA;QAC5B,OAAO,WAAA,GAAc,MAAM,WAAA;QAC3B,OAAO,YAAA,GAAe,MAAM,YAAA;QAG5B,OAAQ;YAAA,KACD,SAAQ,IAAA;gBACX,OAAO,UAAA,GAAa,MAAM,UAAA,GAAa,IAAI,QAAA;gBAC3C,OAAO,YAAA,GAAe,MAAM,YAAA;gBAC5B,OAAO,WAAA,GAAc,MAAM,WAAA;gBAC3B,OAAO,YAAA,GAAe,MAAM,YAAA;gBAC5B;YAAA,KAEG,SAAQ,MAAA;gBACX,OAAO,YAAA,GAAe,MAAM,YAAA,GAAe,MAAM,QAAA;gBACjD,OAAO,UAAA,GAAa,MAAM,UAAA;gBAC1B,OAAO,WAAA,GAAc,MAAM,WAAA;gBAC3B,OAAO,YAAA,GAAe,MAAM,YAAA;gBAC5B;YAAA,KAEG,SAAQ,KAAA;gBACX,OAAO,WAAA,GAAc,MAAM,WAAA,GAAc,KAAK,QAAA;gBAC9C,OAAO,UAAA,GAAa,MAAM,UAAA;gBAC1B,OAAO,YAAA,GAAe,MAAM,YAAA;gBAC5B,OAAO,YAAA,GAAe,MAAM,YAAA;gBAC5B;YAAA,KAEG,SAAQ,MAAA;gBACX,OAAO,YAAA,GAAe,MAAM,YAAA,GAAe,MAAM,QAAA;gBACjD,OAAO,WAAA,GAAc,MAAM,WAAA;gBAC3B,OAAO,UAAA,GAAa,MAAM,UAAA;gBAC1B,OAAO,YAAA,GAAe,MAAM,YAAA;gBAC5B;QAAA;QAIJ,MAAM,MAAA,GACH,CAAA,MAAM,UAAA,GAAa,MAAM,UAAA,IACzB,CAAA,MAAM,YAAA,GAAe,MAAM,YAAA,IAC3B,CAAA,MAAM,WAAA,GAAc,MAAM,WAAA,IAC1B,CAAA,MAAM,YAAA,GAAe,MAAM,YAAA;QAC9B,OAAO,MAAA,GACJ,CAAA,OAAO,UAAA,GAAa,OAAO,UAAA,IAC3B,CAAA,OAAO,YAAA,GAAe,OAAO,YAAA,IAC7B,CAAA,OAAO,WAAA,GAAc,OAAO,WAAA,IAC5B,CAAA,OAAO,YAAA,GAAe,OAAO,YAAA;QAGhC,OAAO;IAAA;IAGD,YAAY,MAAA,EAAgB;QAClC,IAAA,CAAK,OAAA,GAAU;QAGf,IAAA,CAAK,MAAA,GAAS,EAAA;QAGd,IAAA,IAAS,YAAY,GAAG,YAAY,QAAQ,YAAa;YACvD,IAAA,CAAK,MAAA,CAAO,UAAA,GAAa,IAAI;QAAA;QAI/B,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,UAAA,GAAa;QAC5B,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,YAAA,GAAe;QAC9B,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,WAAA,GAAc;QAC7B,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,YAAA,GAAe;QAG9B,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,UAAA,GAAa,IAAA,CAAK,aAAA;QACjC,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,YAAA,GAAe,IAAA,CAAK,aAAA;QACnC,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,WAAA,GAAc,IAAA,CAAK,aAAA;QAClC,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,YAAA,GAAe,IAAA,CAAK,kBAAA;QAEnC,IAAA,CAAK,QAAA,GAAW,cACd,IAAA,CAAK,cAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,IAAA,CAAK,WAAA,GAAc,cACjB,IAAA,CAAK,cAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,IAAA,CAAK,aAAA,GAAgB,cACnB,IAAA,CAAK,cAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,IAAA,CAAK,YAAA,GAAe,cAClB,IAAA,CAAK,cAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,IAAA,CAAK,aAAA,GAAgB,cACnB,IAAA,CAAK,cAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAEP,IAAA,CAAK,QAAA,GAAW,cACd,IAAA,CAAK,cAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA,EACL,IAAA,CAAK,SAAA;QAGP,IAAA,CAAK,MAAA,GAAS,EAAA;QACd,IAAA,IAAS,aAAa,GAAG,aAAa,KAAK,EAAE,WAAY;YACvD,IAAA,CAAK,MAAA,CAAO,WAAA,GAAc,aAAa;QAAA;QAGzC,IAAA,CAAK,OAAA,GAAU,EAAA;IAAA;IAGT,YAAY,4BAA4B,CAAA,EAAG;QACjD,IAAA,CAAK,0BAAA,GAA6B;QAClC,IAAA,CAAK,aAAA,GAAgB,KAAK,IAAA,CAAK,0BAAA;QAC/B,IAAA,CAAK,kBAAA,GAAqB,IAAA,CAAK,aAAA;QAE/B,IAAA,CAAK,SAAA,GAAY,IAAA,CAAK,aAAA,GAAgB;QACtC,IAAA,CAAK,cAAA,GAAiB,IAAA,CAAK,kBAAA,GAAqB;IAAA;AAAA;AA9/B7C,IAAA,UAAA;AACmB,cADnB,SACmB,UAAS;AACT,cAFnB,SAEmB,QAAO;AACP,cAHnB,SAGmB,UAAS;AACT,cAJnB,SAImB,SAAQ;;ACvGlC,IAAA,gBAAA,CAAA;AAAA,SAAA,eAAA;IAAA,wBAAA,IAAA;IAAA,qBAAA,IAAA;IAAA,2BAAA,IAAA;IAAA,yBAAA,IAAA;IAAA,cAAA,IAAA;AAAA;;ACWO,IAAA,yBAAA,MAAsC;IAM3C,aAAa,cAAA,EAAgC,OAAA,EAAkB;QAC7D,KAAA,MAAW,SAAS,IAAA,CAAK,QAAA,CAAS,gBAAgB,SAAU;YAC1D,IAAI,MAAM,cAAA,EAAgB;gBACxB,OAAO,MAAM,cAAA;YAAA;QAAA;QAIjB,MAAM,IAAI,MAAM;IAAA;AAAA;;ACVb,IAAA,eAAA,cAA2B,uBAAuB;IAGvD,YAAY,uBAAA,CAAqD;QAC/D,KAAA;QAHM,cAAA,IAAA,EAAA;QAIN,IAAA,CAAK,SAAA,GAAY;IAAA;IAAA,CAMlB,SACC,cAAA,EACA,OAAA,EAC4C;QAC5C,MAAM,aAAa,eAAe,aAAA;QAClC,MAAM,QAAQ,eAAe,QAAA;QAC7B,MAAM,SAAS,eAAe,SAAA;QAE9B,MAAM,UAAU,IAAI,gBAAgB,QAAQ;QAC5C,IAAA,IAAS,KAAI,GAAG,KAAI,QAAQ,KAAK;YAC/B,IAAI,QAAQ,YAAA,CAAa,KAAI;gBAC3B,MAAM;oBACJ,UAAU,QAAQ,QAAA;gBAAA;YAAA;YAGtB,IAAA,IAAS,KAAI,GAAG,MAAM,KAAI,OAAO,KAAI,OAAO,MAAK,MAAO;gBAEtD,MAAM,QAAQ,UAAA,CAAW,IAAA;gBAEzB,MAAM,IAAA,CAAK,QAAQ,eAAA,CAAgB,IAAA,CAAK,SAAA,EAAW;YAAA;QAAA;QAIvD,MAAM;YACJ;YACA,UAAU;QAAA;IAAA;AAAA;;ACjCT,IAAK,4BAAL,aAAA,GAAA,CAAA,CAAK,+BAAL;IACL,0BAAA,CAAA,0BAAA,CAAA,iBAAA,GAAiB,EAAA,GAAjB;IACA,0BAAA,CAAA,0BAAA,CAAA,sBAAA,GAAA,EAAA,GAAA;IACA,0BAAA,CAAA,0BAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IACA,0BAAA,CAAA,0BAAA,CAAA,WAAA,GAAA,EAAA,GAAA;IACA,0BAAA,CAAA,0BAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IACA,0BAAA,CAAA,0BAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IACA,0BAAA,CAAA,0BAAA,CAAA,SAAA,GAAA,EAAA,GAAA;IACA,0BAAA,CAAA,0BAAA,CAAA,YAAA,GAAA,EAAA,GAAA;IACA,0BAAA,CAAA,0BAAA,CAAA,aAAA,GAAA,EAAA,GAAA;IATU,OAAA;AAAA,CAAA,EAAA,6BAAA,CAAA;AAaL,IAAA,sBAAA,cAAkC,uBAAuB;IAS9D,YACE,uBAAA,EACA,MAAA,EACA,aAAa,IAAA,EACb,+BAA+B,CAAA,EAC/B,yBAAyB,KAAA,CACzB;QACA,KAAA;QAfM,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAEA,cAAA,IAAA,EAAA;QAEA,cAAA,IAAA,EAAA;QAUN,IAAA,CAAK,UAAA,CAAW;QAEhB,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,iBAAA,GAAoB;QACzB,IAAA,CAAK,WAAA,GAAc;QACnB,IAAA,CAAK,uBAAA,GAA0B;IAAA;IAAA,CAQhC,SACC,cAAA,EACA,OAAA,EAC4C;QAC5C,MAAM,aAAa,eAAe,aAAA;QAClC,MAAM,gBAAgB,IAAI;QAC1B,MAAM,QAAQ,eAAe,QAAA;QAC7B,MAAM,SAAS,eAAe,SAAA;QAC9B,MAAM,aAA2B,EAAA;QAEjC,IAAI,MAAM;QACV,IAAI,gBAAgB;QAGpB,KAAA,MAAW,UAAU,IAAA,CAAK,OAAA,CAAS;YACjC,MAAM,mBAAmB,MAAA,CAAO,EAAA,GAAK;YACrC,IAAI,gBAAgB,kBAAkB,gBAAgB;QAAA;QAExD,IAAA,IAAS,IAAI,GAAG,IAAI,eAAe,IAAK;YACtC,IAAA,CAAK,cAAA,CAAgB,UAAA,CAAW,EAAA,GAAK,EAAA,EAAK;QAAA;QAG5C,MAAM,UAAU,IAAI,gBAAgB,QAAQ;QAC5C,IAAA,IAAS,KAAI,GAAG,KAAI,QAAQ,KAAK;YAC/B,IAAI,QAAQ,YAAA,CAAa,KAAI;gBAC3B,MAAM;oBACJ,UAAU,QAAQ,QAAA;gBAAA;YAAA;YAKtB,IAAI,IAAA,CAAK,WAAA,EAAa,OAAO,CAAA;YAE7B,MAAM,MAAM,KAAI;YAChB,MAAM,SAAS,QAAQ,IAAI,IAAI,QAAQ;YACvC,MAAM,OAAO,QAAQ,IAAI,QAAQ,CAAA;YAGjC,IAAA,CAAK,cAAA,CAAe,UAAA,CAAW,EAAA,EAAI;YAEnC,WAAW,IAAA,CAAK,WAAW,KAAA;YAE3B,MAAM,YAAY,UAAA,CAAW,EAAA;YAC7B,IAAA,IACM,KAAI,QAAQ,MAAM,MAAM,QAC5B,OAAM,MACN,MAAK,KAAK,OAAO,IACjB;gBAEA,MAAM,QAAQ,UAAA,CAAW,IAAA;gBAEzB,MAAM,QAAQ,SAAA,CAAU,GAAA;gBAExB,cAAc,IAAA,CAAK;gBAEnB,MAAM,iBAAiB,MAAM,YAAA,CAC3B,qBAAqB,MAAM,CAAA,GAAI,KAAA,CAAM,EAAA,GACrC,qBAAqB,MAAM,CAAA,GAAI,KAAA,CAAM,EAAA,GACrC,qBAAqB,MAAM,CAAA,GAAI,KAAA,CAAM,EAAA,GACrC,qBAAqB,MAAM,CAAA,GAAI,KAAA,CAAM,EAAA;gBAIvC,MAAM,eAAe,QAAQ,eAAA,CAC3B,IAAA,CAAK,SAAA,EACL;gBAEF,MAAM,IAAA,CAAK;gBAGX,IAAI,IAAA,CAAK,iBAAA,EAAmB;oBAC1B,MAAM,OAAO,IAAA,CAAK,SAAA,CAAU,mBAAA,CAC1B,eACA;oBAEF,IAAI,OAAO,IAAA,CAAK,iBAAA,EAAmB;gBAAA;gBAIrC,IAAI;gBACJ,IAAI;gBACJ,IAAI;gBACJ,IAAI;gBACJ,IAAI,IAAA,CAAK,uBAAA,EAAyB;oBAChC,KAAK,eAAe,CAAA,GAAI,aAAa,CAAA;oBACrC,KAAK,eAAe,CAAA,GAAI,aAAa,CAAA;oBACrC,KAAK,eAAe,CAAA,GAAI,aAAa,CAAA;oBACrC,KAAK,eAAe,CAAA,GAAI,aAAa,CAAA;gBAAA,OAChC;oBACL,KAAK,cAAc,CAAA,GAAI,aAAa,CAAA;oBACpC,KAAK,cAAc,CAAA,GAAI,aAAa,CAAA;oBACpC,KAAK,cAAc,CAAA,GAAI,aAAa,CAAA;oBACpC,KAAK,cAAc,CAAA,GAAI,aAAa,CAAA;gBAAA;gBAGtC,MAAM,SAAS,QAAQ,IAAI,IAAI,IAAA,CAAK,OAAA,CAAQ,MAAA,GAAS;gBACrD,MAAM,OAAO,QAAQ,IAAI,IAAA,CAAK,OAAA,CAAQ,MAAA,GAAS,CAAA;gBAE/C,IAAA,IAAS,IAAI,QAAQ,MAAM,MAAM,KAAK,IAAK;oBACzC,MAAM,KAAK,IAAA,CAAK,OAAA,CAAQ,EAAA,CAAG,EAAA,GAAK;oBAChC,MAAM,KAAK,IAAA,CAAK,OAAA,CAAQ,EAAA,CAAG,EAAA;oBAE3B,IAAI,KAAK,MAAK,KAAK,KAAK,KAAI,SAAS,KAAK,MAAK,KAAK,KAAK,KAAI,QAAQ;wBACnE,MAAM,IAAI,IAAA,CAAK,OAAA,CAAQ,EAAA,CAAG,EAAA;wBAC1B,MAAM,IAAI,UAAA,CAAW,GAAA,CAAI,KAAK,GAAA;wBAE9B,CAAA,CAAE,EAAA,IAAM,KAAK;wBACb,CAAA,CAAE,EAAA,IAAM,KAAK;wBACb,CAAA,CAAE,EAAA,IAAM,KAAK;wBACb,CAAA,CAAE,EAAA,IAAM,KAAK;oBAAA;gBAAA;YAAA;QAAA;QAMrB,MAAM;YACJ;YACA,UAAU;QAAA;IAAA;IAIN,eAAe,SAAA,EAAuB,KAAA,EAAe;QAE3D,IAAI,UAAU,MAAA,GAAS,OAAO;YAC5B,UAAU,MAAA,GAAS;QAAA;QAIrB,MAAM,IAAI,UAAU,MAAA;QACpB,IAAA,IAAS,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,MAAM,QAAQ,SAAA,CAAU,EAAA;YACxB,KAAA,CAAM,EAAA,GAAK,KAAA,CAAM,EAAA,GAAK,KAAA,CAAM,EAAA,GAAK,KAAA,CAAM,EAAA,GAAK;QAAA;QAI9C,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,IAAK;YAC9B,SAAA,CAAU,EAAA,GAAK;gBAAC;gBAAK;gBAAK;gBAAK;aAAA;QAAA;IAAA;IAI3B,WAAW,MAAA,EAAmC;QACpD,OAAQ;YAAA,KACD,EAAA,kBAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;iBAAA;gBAEd;YAAA,KAEG,EAAA,uBAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBACb;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;oBACX;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;oBACX;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;iBAAA;gBAEb;YAAA,KAEG,EAAA,UAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;iBAAA;gBAEd;YAAA,KAEG,EAAA,YAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBACb;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;oBACX;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;oBACX;wBAAC,IAAI;wBAAG,CAAA;wBAAI;qBAAA;oBACZ;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;oBACX;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;oBACX;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;iBAAA;gBAEb;YAAA,KAEG,EAAA,UAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBAEb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;iBAAA;gBAEd;YAAA,KAEG,EAAA,UAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;iBAAA;gBAEd;YAAA,KAEG,EAAA,UAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;iBAAA;gBAEd;YAAA,KAEG,EAAA,aAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI,CAAA;wBAAI;qBAAA;oBACb;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;oBACZ;wBAAC,IAAI;wBAAI;wBAAG;qBAAA;iBAAA;gBAEd;YAAA,KAEG,EAAA,cAAA;gBACH,IAAA,CAAK,OAAA,GAAU;oBACb;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;oBACX;wBAAC,IAAI;wBAAG,CAAA;wBAAI;qBAAA;oBACZ;wBAAC,IAAI;wBAAG;wBAAG;qBAAA;iBAAA;gBAEb;YAAA;gBAGA,MAAM,IAAI,MAAM,CAAA,sCAAA,EAAyC,QAAA;QAAA;IAAA;AAAA;;ACnS1D,UAAA,aACL,KAAA,EACA,MAAA,EACA,QAAA,EACA;IACA,MAAM,WAAW,KAAK,GAAA,CAAI,OAAO;IACjC,MAAM,QAAQ,KAAK,KAAA,CAAM,KAAK,GAAA,CAAI,YAAY,KAAK,GAAA,CAAI,KAAK;IAC5D,MAAM,UAAU,IAAI,gBAAgB,QAAQ,QAAQ;IACpD,MAAM,OAAO;QACX;QACA;QACA;QACA;QACA;QACA,OAAO;QACP,GAAG;QACH,GAAG;IAAA;IAEL,OAAO,YAAY,MAAM,EAAA,MAAA;IACzB,MAAM,MAAM,EAAA,QAAA;AAAA;AAGd,UAAA,YACE,IAAA,EACA,SAAA,EAC4C;IAC5C,IAAI,KAAK,KAAA,GAAQ,GAAG;IAEpB,IAAI,KAAK,OAAA,CAAQ,YAAA,CAAa,KAAK,KAAA,GAAQ;QACzC,MAAM;YAAE,UAAU,KAAK,OAAA,CAAQ,QAAA;QAAA;IAAA;IAEjC,KAAK,KAAA;IACL,OAAQ;QAAA,KACD,EAAA,QAAA;YACH,OAAO,YAAY,MAAM,EAAA,MAAA;YACzB,MAAM,MAAM,EAAA,SAAA;YACZ,OAAO,YAAY,MAAM,EAAA,QAAA;YACzB,MAAM,MAAM,EAAA,QAAA;YACZ,OAAO,YAAY,MAAM,EAAA,QAAA;YACzB,MAAM,MAAM,EAAA,QAAA;YACZ,OAAO,YAAY,MAAM,EAAA,QAAA;YACzB;QAAA,KAEG,EAAA,SAAA;YACH,OAAO,YAAY,MAAM,EAAA,QAAA;YACzB,MAAM,MAAM,EAAA,QAAA;YACZ,OAAO,YAAY,MAAM,EAAA,SAAA;YACzB,MAAM,MAAM,EAAA,MAAA;YACZ,OAAO,YAAY,MAAM,EAAA,SAAA;YACzB,MAAM,MAAM,EAAA,SAAA;YACZ,OAAO,YAAY,MAAM,EAAA,MAAA;YACzB;QAAA,KAEG,EAAA,MAAA;YACH,OAAO,YAAY,MAAM,EAAA,QAAA;YACzB,MAAM,MAAM,EAAA,QAAA;YACZ,OAAO,YAAY,MAAM,EAAA,MAAA;YACzB,MAAM,MAAM,EAAA,SAAA;YACZ,OAAO,YAAY,MAAM,EAAA,MAAA;YACzB,MAAM,MAAM,EAAA,MAAA;YACZ,OAAO,YAAY,MAAM,EAAA,SAAA;YACzB;QAAA,KAEG,EAAA,QAAA;YACH,OAAO,YAAY,MAAM,EAAA,SAAA;YACzB,MAAM,MAAM,EAAA,MAAA;YACZ,OAAO,YAAY,MAAM,EAAA,QAAA;YACzB,MAAM,MAAM,EAAA,QAAA;YACZ,OAAO,YAAY,MAAM,EAAA,QAAA;YACzB,MAAM,MAAM,EAAA,QAAA;YACZ,OAAO,YAAY,MAAM,EAAA,QAAA;YACzB;QAAA;YAGA;IAAA;IAEJ,KAAK,KAAA;AAAA;AAGP,SAAA,MAAe,IAAA,EAAY,SAAA,EAAsB;IAC/C,IACE,KAAK,CAAA,IAAK,KACV,KAAK,CAAA,GAAI,KAAK,KAAA,IACd,KAAK,CAAA,IAAK,KACV,KAAK,CAAA,GAAI,KAAK,MAAA,EACd;QACA,KAAK,QAAA,CAAS,KAAK,CAAA,EAAG,KAAK,CAAA;QAC3B,KAAK,KAAA;IAAA;IAEP,OAAQ;QAAA,KACD,EAAA,QAAA;YACH,KAAK,CAAA;YACL;QAAA,KACG,EAAA,SAAA;YACH,KAAK,CAAA;YACL;QAAA,KACG,EAAA,MAAA;YACH,KAAK,CAAA;YACL;QAAA,KACG,EAAA,QAAA;YACH,KAAK,CAAA;YACL;IAAA;AAAA;;ACzFC,IAAA,0BAAA,cAAsC,uBAAuB;IAKlE,YACE,uBAAA,EACA,iBAAiB,EAAA,EACjB,mBAAmB,CAAA,CACnB;QACA,KAAA;QATM,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA;QAQN,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,eAAA,GAAkB;QACvB,IAAA,CAAK,QAAA,GAAW,wBAAwB,cAAA,CACtC,kBACA;IAAA;IAAA,CAOH,SAAS,cAAA,EAAgC,OAAA,EAAkB;QAC1D,MAAM,aAAa,eAAe,aAAA;QAClC,MAAM,QAAQ,eAAe,QAAA;QAC7B,MAAM,SAAS,eAAe,SAAA;QAC9B,MAAM,aAKD,EAAA;QAEL,IAAI,OAAO;QAEX,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,eAAA,EAAiB,IAAK;YAC7C,UAAA,CAAW,EAAA,GAAK;gBAAE,GAAG;gBAAG,GAAG;gBAAG,GAAG;gBAAG,GAAG;YAAA;QAAA;QAGzC,OAAO,aAAa,OAAO,QAAQ,CAAC,IAAG,OAAM;YAC3C,MAAM,IAAI,UAAA,CAAW,KAAI,KAAI,MAAA;YAC7B,IAAI,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA,EAAG,CAAA,EAAA,GAAM;YACrB,IAAA,IAAS,IAAI,GAAG,IAAI,IAAA,CAAK,eAAA,EAAiB,IAAK;gBAC7C,MAAM,SAAS,IAAA,CAAK,QAAA,CAAS,EAAA;gBAC7B,MAAM,IAAI,UAAA,CAAY,CAAA,IAAI,IAAA,IAAQ,IAAA,CAAK,eAAA,CAAA;gBAEvC,KAAK,EAAE,CAAA,GAAI;gBACX,KAAK,EAAE,CAAA,GAAI;gBACX,KAAK,EAAE,CAAA,GAAI;gBACX,KAAK,EAAE,CAAA,GAAI;YAAA;YAGb,MAAM,iBAAiB,MAAM,YAAA,CAC3B,qBAAqB,IACrB,qBAAqB,IACrB,qBAAqB,IACrB,qBAAqB;YAGvB,MAAM,iBAAiB,QAAQ,eAAA,CAC7B,IAAA,CAAK,SAAA,EACL;YAIF,OAAQ,CAAA,OAAO,CAAA,IAAK,IAAA,CAAK,eAAA;YACzB,MAAM,OAAQ,CAAA,OAAO,IAAA,CAAK,eAAA,GAAkB,CAAA,IAAK,IAAA,CAAK,eAAA;YAGtD,UAAA,CAAW,KAAA,CAAM,CAAA,GAAI,EAAE,CAAA,GAAI,eAAe,CAAA;YAC1C,UAAA,CAAW,KAAA,CAAM,CAAA,GAAI,EAAE,CAAA,GAAI,eAAe,CAAA;YAC1C,UAAA,CAAW,KAAA,CAAM,CAAA,GAAI,EAAE,CAAA,GAAI,eAAe,CAAA;YAC1C,UAAA,CAAW,KAAA,CAAM,CAAA,GAAI,EAAE,CAAA,GAAI,eAAe,CAAA;YAG1C,EAAE,IAAA,CAAK;QAAA;QAGT,MAAM;YACJ;YACA,UAAU;QAAA;IAAA;IAAA,OAIC,eACb,gBAAA,EACA,cAAA,EACA;QACA,MAAM,UAAU,EAAA;QAEhB,MAAM,aAAa,KAAK,GAAA,CACtB,KAAK,GAAA,CAAI,kBAAmB,CAAA,iBAAiB,CAAA;QAE/C,IAAA,IAAS,IAAI,GAAG,OAAO,GAAG,IAAI,gBAAgB,IAAK;YACjD,OAAA,CAAQ,EAAA,GAAQ,CAAA,OAAO,MAAO,CAAA,IAAK,iBAAkB;YACrD,QAAQ;QAAA;QAGV,OAAO;IAAA;AAAA;;ACpIX,IAAA,kBAAA,CAAA;AAAA,SAAA,iBAAA;IAAA,MAAA,IAAA;AAAA;;ACYA,IAAM,KAAK;AACX,IAAM,KAAK;AAEJ,SAAA,KAAc,MAAA,EAAwB,MAAA,EAAwB;IACnE,IACE,OAAO,SAAA,OAAgB,OAAO,SAAA,MAC9B,OAAO,QAAA,OAAe,OAAO,QAAA,IAC7B;QACA,MAAM,IAAI,MAAM;IAAA;IAGlB,MAAM,mBAAmB;IACzB,MAAM,IAAK,CAAA,KAAK,gBAAA,IAAoB;IACpC,MAAM,KAAM,CAAA,KAAK,CAAA,KAAM;IACvB,MAAM,KAAM,CAAA,KAAK,CAAA,KAAM;IAEvB,IAAI,aAAa;IACjB,IAAI,QAAQ;IAGZ,QACE,QACA,QACA,CAAC,aAAa,aAAa,mBAAmB,sBAAsB;QAElE,IAAI,QAAQ;QACZ,IAAI,SAAS;QACb,IAAI,SAAS;QAEb,IAAA,IAAS,IAAI,GAAG,IAAI,YAAY,MAAA,EAAQ,IAAK;YAC3C,UAAW,CAAA,WAAA,CAAY,EAAA,GAAK,iBAAA,KAAsB;YAClD,UAAW,CAAA,WAAA,CAAY,EAAA,GAAK,iBAAA,KAAsB;YAElD,SACG,CAAA,WAAA,CAAY,EAAA,GAAK,iBAAA,IACjB,CAAA,WAAA,CAAY,EAAA,GAAK,iBAAA;QAAA;QAGtB,MAAM,iBAAiB,YAAY,MAAA,GAAS;QAC5C,UAAU;QACV,UAAU;QACV,SAAS;QAGT,MAAM,YACH,CAAA,IAAI,oBAAoB,oBAAoB,EAAA,IAAO,CAAA,IAAI,QAAQ,EAAA;QAClE,MAAM,cACH,CAAA,qBAAqB,IAAI,qBAAqB,IAAI,EAAA,IAClD,CAAA,SAAS,SAAS,EAAA;QACrB,MAAM,QAAO,YAAY;QAEzB,SAAS;QACT;IAAA;IAGJ,OAAO,QAAQ;AAAA;AAGjB,SAAA,QACE,MAAA,EACA,MAAA,EACA,QAAA,EAMA;IACA,MAAM,aAAa;IACnB,MAAM,QAAQ,OAAO,QAAA;IACrB,MAAM,SAAS,OAAO,SAAA;IAEtB,IAAA,IAAS,KAAI,GAAG,KAAI,QAAQ,MAAK,WAAY;QAC3C,IAAA,IAAS,KAAI,GAAG,KAAI,OAAO,MAAK,WAAY;YAE1C,MAAM,cAAc,KAAK,GAAA,CAAI,YAAY,QAAQ;YACjD,MAAM,eAAe,KAAK,GAAA,CAAI,YAAY,SAAS;YAEnD,MAAM,cAAc,6BAClB,QACA,IACA,IACA,aACA;YAEF,MAAM,cAAc,6BAClB,QACA,IACA,IACA,aACA;YAEF,MAAM,eAAe,qBAAqB;YAC1C,MAAM,eAAe,qBAAqB;YAE1C,SAAS,aAAa,aAAa,cAAc;QAAA;IAAA;AAAA;AAKvD,SAAA,6BACE,KAAA,EACA,EAAA,EACA,EAAA,EACA,KAAA,EACA,MAAA,EACA;IACA,MAAM,aAAa,MAAM,aAAA;IACzB,MAAM,aAAa,EAAA;IAEnB,IAAI,UAAU;IAEd,IAAA,IAAS,IAAI,IAAG,IAAI,KAAI,QAAQ,IAAK;QACnC,MAAM,SAAS,IAAI,MAAM,QAAA;QACzB,IAAA,IAAS,IAAI,IAAG,IAAI,KAAI,OAAO,IAAK;YAClC,MAAM,QAAQ,UAAA,CAAW,SAAS,EAAA;YAClC,UAAA,CAAW,QAAA,GACT,MAAM,CAAA,GAAI,OAAA,OAAA,MAAQ,MAAM,CAAA,GAAI,OAAA,SAAA,MAAU,MAAM,CAAA,GAAI,OAAA,QAAA;YAClD;QAAA;IAAA;IAIJ,OAAO;AAAA;AAGT,SAAA,qBAA8B,UAAA,EAAsB;IAClD,IAAI,UAAU;IACd,KAAA,MAAW,QAAQ,WAAY;QAC7B,WAAW;IAAA;IAGb,OAAO,UAAU,WAAW,MAAA;AAAA;;ACjI9B,IAAM,mBACJ,OAAO,iBAAiB,aACpB,eACA,OAAO,YAAY,eAAe,OAAO,CAAA,WAAA,OAAA,KAAA,IAAA,QAAS,QAAA,MAAa,aAC/D,CAAC,WAAyB,QAAQ,QAAA,CAAS,YAC3C,CAAC,WAAyB,WAAW,UAAU;AAiD9C,SAAA,iBACL,MAAA,EACA,EACE,oBAAA,EACA,mBAAA,EACA,MAAA,EAAA,GACuB,CAAA,CAAA,EACzB;IACA,MAAM,qBACJ,oCAAoC;IACtC,MAAM,mBAAmB,sCACvB,oBACA,qBACA;IAEF,OAAO,OAAA,CAAQ,CAAC,QAAU,iBAAiB,MAAA,CAAO;IAClD,OAAO,iBAAiB,YAAA;AAAA;AAG1B,eAAA,aACE,MAAA,EACA,EACE,oBAAA,EACA,mBAAA,EACA,MAAA,EACA,UAAA,EAAA,GACyC,CAAA,CAAA,EAC3C;IACA,OAAO,IAAI,QAAiB,CAAC,SAAS,WAAW;QAC/C,MAAM,qBACJ,oCAAoC;QACtC,MAAM,mBAAmB,sCACvB,oBACA,qBACA;QAEF,OAAO,OAAA,CAAQ,CAAC,QAAU,iBAAiB,MAAA,CAAO;QAElD,IAAI;QACJ,MAAM,WAAW,iBAAiB,QAAA;QAClC,MAAM,OAAO,MAAM;YACjB,IAAI;gBACF,MAAM,SAAS,SAAS,IAAA;gBACxB,IAAI,OAAO,IAAA,EAAM;oBACf,QAAQ;gBAAA,OACH;oBACL,IAAI,OAAO,KAAA,CAAM,OAAA,EAAS,UAAU,OAAO,KAAA,CAAM,OAAA;oBACjD,IAAI,YAAY,WAAW,OAAO,KAAA,CAAM,QAAA;oBACxC,iBAAiB;gBAAA;YAAA,EAAA,OAEZ,OAAP;gBACA,OAAO;YAAA;QAAA;QAGX,iBAAiB;IAAA;AAAA;AAId,SAAA,iBACL,KAAA,EACA,OAAA,EACA,EAAE,oBAAA,EAAsB,iBAAA,EAAA,GAA2C,CAAA,CAAA,EACnE;IACA,MAAM,qBACJ,oCAAoC;IACtC,MAAM,iBAAiB,kCACrB,oBACA;IAEF,OAAO,eAAe,YAAA,CAAa,OAAO;AAAA;AAG5C,eAAA,aACE,KAAA,EACA,OAAA,EACA,EACE,oBAAA,EACA,iBAAA,EACA,UAAA,EAAA,GACyC,CAAA,CAAA,EAC3C;IACA,OAAO,IAAI,QAAwB,CAAC,SAAS,WAAW;QACtD,MAAM,qBACJ,oCAAoC;QACtC,MAAM,iBAAiB,kCACrB,oBACA;QAGF,IAAI;QACJ,MAAM,WAAW,eAAe,QAAA,CAAS,OAAO;QAChD,MAAM,OAAO,MAAM;YACjB,IAAI;gBACF,MAAM,SAAS,SAAS,IAAA;gBACxB,IAAI,OAAO,IAAA,EAAM;oBACf,QAAQ;gBAAA,OACH;oBACL,IAAI,OAAO,KAAA,CAAM,cAAA,EAAgB;wBAC/B,oBAAoB,OAAO,KAAA,CAAM,cAAA;oBAAA;oBAEnC,IAAI,YAAY,WAAW,OAAO,KAAA,CAAM,QAAA;oBACxC,iBAAiB;gBAAA;YAAA,EAAA,OAEZ,OAAP;gBACA,OAAO;YAAA;QAAA;QAGX,iBAAiB;IAAA;AAAA;AAIrB,SAAA,oCACE,uBAA6C,iBAAA,EAC7C;IACA,OAAQ;QAAA,KACD;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA,KACjB;YACH,OAAO,IAAa;QAAA;YAEpB,MAAM,IAAI,MAAM,CAAA,6BAAA,EAAgC,sBAAA;IAAA;AAAA;AAItD,SAAA,kCACE,kBAAA,EACA,oBAAuC,iBAAA,EACvC;IACA,OAAQ;QAAA,KACD;YACH,OAAO,IAAU,aAAa;QAAA,KAC3B;YACH,OAAO,IAAU,wBAAwB;QAAA,KACtC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,kBAAA;QAAA,KAEC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,uBAAA;QAAA,KAEC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,UAAA;QAAA,KAEC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,YAAA;QAAA,KAEC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,UAAA;QAAA,KAEC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,UAAA;QAAA,KAEC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,UAAA;QAAA,KAEC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,aAAA;QAAA,KAEC;YACH,OAAO,IAAU,oBACf,oBACA,EAAA,cAAA;QAAA;YAGF,MAAM,IAAI,MAAM,CAAA,0BAAA,EAA6B,mBAAA;IAAA;AAAA;AAInD,SAAA,sCACE,kBAAA,EACA,sBAA2C,SAAA,EAC3C,SAAS,GAAA,EACT;IACA,OAAQ;QAAA,KACD;YACH,OAAO,IAAY,SAAS,oBAAoB;QAAA,KAC7C;YACH,OAAO,IAAY,SAAS,oBAAoB;QAAA,KAC7C;YACH,OAAO,IAAY,QAAQ,oBAAoB;QAAA,KAC5C;YACH,OAAO,IAAY,cAAc,oBAAoB;QAAA;YAErD,MAAM,IAAI,MAAM,CAAA,4BAAA,EAA+B,qBAAA;IAAA;AAAA","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]}},
    {"offset": {"line": 6129, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}